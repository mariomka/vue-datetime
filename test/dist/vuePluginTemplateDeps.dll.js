var vuePluginTemplateDeps =
/** ****/ (function (modules) { // webpackBootstrap
/** ****/ 	// The module cache
  /** ****/ 	var installedModules = {}
/** ****/
/** ****/ 	// The require function
  /** ****/ 	function __webpack_require__ (moduleId) {
/** ****/
/** ****/ 		// Check if module is in cache
    /** ****/ 		if (installedModules[moduleId]) {
      /** ****/ 			return installedModules[moduleId].exports
    /** ****/ 		}
/** ****/ 		// Create a new module (and put it into the cache)
    /** ****/ 		var module = installedModules[moduleId] = {
      /** ****/ 			i: moduleId,
      /** ****/ 			l: false,
      /** ****/ 			exports: {}
    /** ****/ 		}
/** ****/
/** ****/ 		// Execute the module function
    /** ****/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)
/** ****/
/** ****/ 		// Flag the module as loaded
    /** ****/ 		module.l = true
/** ****/
/** ****/ 		// Return the exports of the module
    /** ****/ 		return module.exports
  /** ****/ 	}
/** ****/
/** ****/
/** ****/ 	// expose the modules object (__webpack_modules__)
  /** ****/ 	__webpack_require__.m = modules
/** ****/
/** ****/ 	// expose the module cache
  /** ****/ 	__webpack_require__.c = installedModules
/** ****/
/** ****/ 	// identity function for calling harmony imports with the correct context
  /** ****/ 	__webpack_require__.i = function (value) { return value }
/** ****/
/** ****/ 	// define getter function for harmony exports
  /** ****/ 	__webpack_require__.d = function (exports, name, getter) {
    /** ****/ 		if (!__webpack_require__.o(exports, name)) {
      /** ****/ 			Object.defineProperty(exports, name, {
        /** ****/ 				configurable: false,
        /** ****/ 				enumerable: true,
        /** ****/ 				get: getter
      /** ****/ 			})
    /** ****/ 		}
  /** ****/ 	}
/** ****/
/** ****/ 	// getDefaultExport function for compatibility with non-harmony modules
  /** ****/ 	__webpack_require__.n = function (module) {
    /** ****/ 		var getter = module && module.__esModule
/** ****/ 			? function getDefault () { return module['default'] }
/** ****/ 			: function getModuleExports () { return module }
    /** ****/ 		__webpack_require__.d(getter, 'a', getter)
    /** ****/ 		return getter
  /** ****/ 	}
/** ****/
/** ****/ 	// Object.prototype.hasOwnProperty.call
  /** ****/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property) }
/** ****/
/** ****/ 	// __webpack_public_path__
  /** ****/ 	__webpack_require__.p = ''
/** ****/
/** ****/ 	// Load entry module and return exports
  /** ****/ 	return __webpack_require__(__webpack_require__.s = 464)
/** ****/ })([
/* 0 */
  /** */ function (module, exports, __webpack_require__) {
    var global = __webpack_require__(2)
    var core = __webpack_require__(15)
    var ctx = __webpack_require__(20)
    var hide = __webpack_require__(22)
    var PROTOTYPE = 'prototype'

    var $export = function (type, name, source) {
      var IS_FORCED = type & $export.F
      var IS_GLOBAL = type & $export.G
      var IS_STATIC = type & $export.S
      var IS_PROTO = type & $export.P
      var IS_BIND = type & $export.B
      var IS_WRAP = type & $export.W
      var exports = IS_GLOBAL ? core : core[name] || (core[name] = {})
      var expProto = exports[PROTOTYPE]
      var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
      var key, own, out
      if (IS_GLOBAL) source = name
      for (key in source) {
    // contains in native
        own = !IS_FORCED && target && target[key] !== undefined
        if (own && key in exports) continue
    // export native or passed
        out = own ? target[key] : source[key]
    // prevent global pollution for namespaces
        exports[key] = IS_GLOBAL && typeof target[key] !== 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C()
            case 1: return new C(a)
            case 2: return new C(a, b)
          } return new C(a, b, c)
        } return C.apply(this, arguments)
      }
      F[PROTOTYPE] = C[PROTOTYPE]
      return F
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out === 'function' ? ctx(Function.call, out) : out
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
        if (IS_PROTO) {
          (exports.virtual || (exports.virtual = {}))[key] = out
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
          if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out)
        }
      }
    }
// type bitmap
    $export.F = 1   // forced
    $export.G = 2   // global
    $export.S = 4   // static
    $export.P = 8   // proto
    $export.B = 16  // bind
    $export.W = 32  // wrap
    $export.U = 64  // safe
    $export.R = 128 // real proto method for `library`
    module.exports = $export
  /** */ },
/* 1 */
  /** */ function (module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4)
    module.exports = function (it) {
      if (!isObject(it)) throw TypeError(it + ' is not an object!')
      return it
    }
  /** */ },
/* 2 */
  /** */ function (module, exports) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global = module.exports = typeof window !== 'undefined' && window.Math == Math
  ? window : typeof self !== 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')()
    if (typeof __g === 'number') __g = global // eslint-disable-line no-undef
  /** */ },
/* 3 */
  /** */ function (module, exports) {
    if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
      module.exports = function inherits (ctor, superCtor) {
        ctor.super_ = superCtor
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        })
      }
    } else {
  // old school shim for old browsers
      module.exports = function inherits (ctor, superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () {}
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
      }
    }
  /** */ },
/* 4 */
  /** */ function (module, exports) {
    module.exports = function (it) {
      return typeof it === 'object' ? it !== null : typeof it === 'function'
    }
  /** */ },
/* 5 */
  /** */ function (module, exports) {
    module.exports = function (exec) {
      try {
        return !!exec()
      } catch (e) {
        return true
      }
    }
  /** */ },
/* 6 */
  /** */ function (module, exports) {
    var g

// This works in non-strict mode
    g = (function () {
      return this
    })()

    try {
	// This works if eval is allowed (see CSP)
      g = g || Function('return this')() || (1, eval)('this')
    } catch (e) {
	// This works if the window reference is available
      if (typeof window === 'object') { g = window }
    }

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

    module.exports = g
  /** */ },
/* 7 */
  /** */ function (module, exports) {
// shim for using process in browser
    var process = module.exports = {}

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

    var cachedSetTimeout
    var cachedClearTimeout

    function defaultSetTimout () {
      throw new Error('setTimeout has not been defined')
    }
    function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined')
    }
    (function () {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout
        } else {
          cachedSetTimeout = defaultSetTimout
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout
        } else {
          cachedClearTimeout = defaultClearTimeout
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout
      }
    }())
    function runTimeout (fun) {
      if (cachedSetTimeout === setTimeout) {
        // normal enviroments in sane situations
        return setTimeout(fun, 0)
      }
    // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout
        return setTimeout(fun, 0)
      }
      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0)
      } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
          return cachedSetTimeout.call(null, fun, 0)
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
          return cachedSetTimeout.call(this, fun, 0)
        }
      }
    }
    function runClearTimeout (marker) {
      if (cachedClearTimeout === clearTimeout) {
        // normal enviroments in sane situations
        return clearTimeout(marker)
      }
    // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout
        return clearTimeout(marker)
      }
      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker)
      } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
          return cachedClearTimeout.call(null, marker)
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
          return cachedClearTimeout.call(this, marker)
        }
      }
    }
    var queue = []
    var draining = false
    var currentQueue
    var queueIndex = -1

    function cleanUpNextTick () {
      if (!draining || !currentQueue) {
        return
      }
      draining = false
      if (currentQueue.length) {
        queue = currentQueue.concat(queue)
      } else {
        queueIndex = -1
      }
      if (queue.length) {
        drainQueue()
      }
    }

    function drainQueue () {
      if (draining) {
        return
      }
      var timeout = runTimeout(cleanUpNextTick)
      draining = true

      var len = queue.length
      while (len) {
        currentQueue = queue
        queue = []
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run()
          }
        }
        queueIndex = -1
        len = queue.length
      }
      currentQueue = null
      draining = false
      runClearTimeout(timeout)
    }

    process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1)
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i]
        }
      }
      queue.push(new Item(fun, args))
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue)
      }
    }

// v8 likes predictible objects
    function Item (fun, array) {
      this.fun = fun
      this.array = array
    }
    Item.prototype.run = function () {
      this.fun.apply(null, this.array)
    }
    process.title = 'browser'
    process.browser = true
    process.env = {}
    process.argv = []
    process.version = '' // empty string to avoid regexp issues
    process.versions = {}

    function noop () {}

    process.on = noop
    process.addListener = noop
    process.once = noop
    process.off = noop
    process.removeListener = noop
    process.removeAllListeners = noop
    process.emit = noop
    process.prependListener = noop
    process.prependOnceListener = noop

    process.listeners = function (name) { return [] }

    process.binding = function (name) {
      throw new Error('process.binding is not supported')
    }

    process.cwd = function () { return '/' }
    process.chdir = function (dir) {
      throw new Error('process.chdir is not supported')
    }
    process.umask = function () { return 0 }
  /** */ },
/* 8 */
  /** */ function (module, exports, __webpack_require__) {
// 7.1.15 ToLength
    var toInteger = __webpack_require__(29)
    var min = Math.min
    module.exports = function (it) {
      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0 // pow(2, 53) - 1 == 9007199254740991
    }
  /** */ },
/* 9 */
  /** */ function (module, exports, __webpack_require__) {
    var store = __webpack_require__(73)('wks')
    var uid = __webpack_require__(52)
    var Symbol = __webpack_require__(2).Symbol
    var USE_SYMBOL = typeof Symbol === 'function'

    var $exports = module.exports = function (name) {
      return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name))
    }

    $exports.store = store
  /** */ },
/* 10 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (process) { /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
      exports = module.exports = __webpack_require__(418)
      exports.log = log
      exports.formatArgs = formatArgs
      exports.save = save
      exports.load = load
      exports.useColors = useColors
      exports.storage = typeof chrome !== 'undefined' &&
               typeof chrome.storage !== 'undefined'
                  ? chrome.storage.local
                  : localstorage()

/**
 * Colors.
 */

      exports.colors = [
        'lightseagreen',
        'forestgreen',
        'goldenrod',
        'dodgerblue',
        'darkorchid',
        'crimson'
      ]

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

      function useColors () {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
        if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
          return true
        }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
        return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      }

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

      exports.formatters.j = function (v) {
        try {
          return JSON.stringify(v)
        } catch (err) {
          return '[UnexpectedJSONParseError]: ' + err.message
        }
      }

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

      function formatArgs (args) {
        var useColors = this.useColors

        args[0] = (useColors ? '%c' : '') +
    this.namespace +
    (useColors ? ' %c' : ' ') +
    args[0] +
    (useColors ? '%c ' : ' ') +
    '+' + exports.humanize(this.diff)

        if (!useColors) return

        var c = 'color: ' + this.color
        args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
        var index = 0
        var lastC = 0
        args[0].replace(/%[a-zA-Z%]/g, function (match) {
          if (match === '%%') return
          index++
          if (match === '%c') {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
            lastC = index
          }
        })

        args.splice(lastC, 0, c)
      }

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

      function log () {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
        return typeof console === 'object' &&
    console.log &&
    Function.prototype.apply.call(console.log, console, arguments)
      }

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

      function save (namespaces) {
        try {
          if (namespaces == null) {
            exports.storage.removeItem('debug')
          } else {
            exports.storage.debug = namespaces
          }
        } catch (e) {}
      }

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

      function load () {
        var r
        try {
          r = exports.storage.debug
        } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
        if (!r && typeof process !== 'undefined' && 'env' in process) {
          r = process.env.DEBUG
        }

        return r
      }

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

      exports.enable(load())

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

      function localstorage () {
        try {
          return window.localStorage
        } catch (e) {}
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 11 */
  /** */ function (module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1)
    var IE8_DOM_DEFINE = __webpack_require__(130)
    var toPrimitive = __webpack_require__(40)
    var dP = Object.defineProperty

    exports.f = __webpack_require__(12) ? Object.defineProperty : function defineProperty (O, P, Attributes) {
      anObject(O)
      P = toPrimitive(P, true)
      anObject(Attributes)
      if (IE8_DOM_DEFINE) {
        try {
          return dP(O, P, Attributes)
        } catch (e) { /* empty */ }
      }
      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!')
      if ('value' in Attributes) O[P] = Attributes.value
      return O
    }
  /** */ },
/* 12 */
  /** */ function (module, exports, __webpack_require__) {
// Thank's IE8 for his funny defineProperty
    module.exports = !__webpack_require__(5)(function () {
      return Object.defineProperty({}, 'a', { get: function () { return 7 } }).a != 7
    })
  /** */ },
/* 13 */
  /** */ function (module, exports, __webpack_require__) {
// 7.1.13 ToObject(argument)
    var defined = __webpack_require__(30)
    module.exports = function (it) {
      return Object(defined(it))
    }
  /** */ },
/* 14 */
  /** */ function (module, exports) {
    module.exports = function (it) {
      if (typeof it !== 'function') throw TypeError(it + ' is not a function!')
      return it
    }
  /** */ },
/* 15 */
  /** */ function (module, exports) {
    var core = module.exports = { version: '2.5.1' }
    if (typeof __e === 'number') __e = core // eslint-disable-line no-undef
  /** */ },
/* 16 */
  /** */ function (module, exports, __webpack_require__) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
    var IObject = __webpack_require__(56)
    var defined = __webpack_require__(30)
    module.exports = function (it) {
      return IObject(defined(it))
    }
  /** */ },
/* 17 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      EventTarget = __webpack_require__(157)

    function EventEmitter () {
      EventTarget.call(this)
    }

    inherits(EventEmitter, EventTarget)

    EventEmitter.prototype.removeAllListeners = function (type) {
      if (type) {
        delete this._listeners[type]
      } else {
        this._listeners = {}
      }
    }

    EventEmitter.prototype.once = function (type, listener) {
      var self = this,
        fired = false

      function g () {
        self.removeListener(type, g)

        if (!fired) {
          fired = true
          listener.apply(this, arguments)
        }
      }

      this.on(type, g)
    }

    EventEmitter.prototype.emit = function () {
      var type = arguments[0]
      var listeners = this._listeners[type]
      if (!listeners) {
        return
      }
  // equivalent of Array.prototype.slice.call(arguments, 1);
      var l = arguments.length
      var args = new Array(l - 1)
      for (var ai = 1; ai < l; ai++) {
        args[ai - 1] = arguments[ai]
      }
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].apply(this, args)
      }
    }

    EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener
    EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener

    module.exports.EventEmitter = EventEmitter
  /** */ },
/* 18 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
    var has = __webpack_require__(21)
    var toObject = __webpack_require__(13)
    var IE_PROTO = __webpack_require__(98)('IE_PROTO')
    var ObjectProto = Object.prototype

    module.exports = Object.getPrototypeOf || function (O) {
      O = toObject(O)
      if (has(O, IE_PROTO)) return O[IE_PROTO]
      if (typeof O.constructor === 'function' && O instanceof O.constructor) {
        return O.constructor.prototype
      } return O instanceof Object ? ObjectProto : null
    }
  /** */ },
/* 19 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var fails = __webpack_require__(5)
    var defined = __webpack_require__(30)
    var quot = /"/g
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
    var createHTML = function (string, tag, attribute, value) {
      var S = String(defined(string))
      var p1 = '<' + tag
      if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"'
      return p1 + '>' + S + '</' + tag + '>'
    }
    module.exports = function (NAME, exec) {
      var O = {}
      O[NAME] = exec(createHTML)
      $export($export.P + $export.F * fails(function () {
        var test = ''[NAME]('"')
        return test !== test.toLowerCase() || test.split('"').length > 3
      }), 'String', O)
    }
  /** */ },
/* 20 */
  /** */ function (module, exports, __webpack_require__) {
// optional / simple context binding
    var aFunction = __webpack_require__(14)
    module.exports = function (fn, that, length) {
      aFunction(fn)
      if (that === undefined) return fn
      switch (length) {
        case 1: return function (a) {
          return fn.call(that, a)
        }
        case 2: return function (a, b) {
          return fn.call(that, a, b)
        }
        case 3: return function (a, b, c) {
          return fn.call(that, a, b, c)
        }
      }
      return function (/* ...args */) {
        return fn.apply(that, arguments)
      }
    }
  /** */ },
/* 21 */
  /** */ function (module, exports) {
    var hasOwnProperty = {}.hasOwnProperty
    module.exports = function (it, key) {
      return hasOwnProperty.call(it, key)
    }
  /** */ },
/* 22 */
  /** */ function (module, exports, __webpack_require__) {
    var dP = __webpack_require__(11)
    var createDesc = __webpack_require__(39)
    module.exports = __webpack_require__(12) ? function (object, key, value) {
      return dP.f(object, key, createDesc(1, value))
    } : function (object, key, value) {
      object[key] = value
      return object
    }
  /** */ },
/* 23 */
  /** */ function (module, exports, __webpack_require__) {
    var pIE = __webpack_require__(58)
    var createDesc = __webpack_require__(39)
    var toIObject = __webpack_require__(16)
    var toPrimitive = __webpack_require__(40)
    var has = __webpack_require__(21)
    var IE8_DOM_DEFINE = __webpack_require__(130)
    var gOPD = Object.getOwnPropertyDescriptor

    exports.f = __webpack_require__(12) ? gOPD : function getOwnPropertyDescriptor (O, P) {
      O = toIObject(O)
      P = toPrimitive(P, true)
      if (IE8_DOM_DEFINE) {
        try {
          return gOPD(O, P)
        } catch (e) { /* empty */ }
      }
      if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
    }
  /** */ },
/* 24 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var URL = __webpack_require__(171)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:utils:url')
      }

      module.exports = {
        getOrigin: function (url) {
          if (!url) {
            return null
          }

          var p = new URL(url)
          if (p.protocol === 'file:') {
            return null
          }

          var port = p.port
          if (!port) {
            port = (p.protocol === 'https:') ? '443' : '80'
          }

          return p.protocol + '//' + p.hostname + ':' + port
        },

        isOriginEqual: function (a, b) {
          var res = this.getOrigin(a) === this.getOrigin(b)
          debug('same', a, b, res)
          return res
        },

        isSchemeEqual: function (a, b) {
          return (a.split(':')[0] === b.split(':')[0])
        },

        addPath: function (url, path) {
          var qs = url.split('?')
          return qs[0] + path + (qs[1] ? '?' + qs[1] : '')
        },

        addQuery: function (url, q) {
          return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q))
        }
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 25 */
  /** */ function (module, exports, __webpack_require__) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
    var ctx = __webpack_require__(20)
    var IObject = __webpack_require__(56)
    var toObject = __webpack_require__(13)
    var toLength = __webpack_require__(8)
    var asc = __webpack_require__(80)
    module.exports = function (TYPE, $create) {
      var IS_MAP = TYPE == 1
      var IS_FILTER = TYPE == 2
      var IS_SOME = TYPE == 3
      var IS_EVERY = TYPE == 4
      var IS_FIND_INDEX = TYPE == 6
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX
      var create = $create || asc
      return function ($this, callbackfn, that) {
        var O = toObject($this)
        var self = IObject(O)
        var f = ctx(callbackfn, that, 3)
        var length = toLength(self.length)
        var index = 0
        var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
        var val, res
        for (;length > index; index++) {
          if (NO_HOLES || index in self) {
            val = self[index]
            res = f(val, index, O)
            if (TYPE) {
              if (IS_MAP) result[index] = res   // map
              else if (res) {
                switch (TYPE) {
                  case 3: return true             // some
                  case 5: return val              // find
                  case 6: return index            // findIndex
                  case 2: result.push(val)        // filter
                }
              } else if (IS_EVERY) return false // every
            }
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result
      }
    }
  /** */ },
/* 26 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var fails = __webpack_require__(5)

    module.exports = function (method, arg) {
      return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
        arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null)
      })
    }
  /** */ },
/* 27 */
  /** */ function (module, exports) {
    var toString = {}.toString

    module.exports = function (it) {
      return toString.call(it).slice(8, -1)
    }
  /** */ },
/* 28 */
  /** */ function (module, exports, __webpack_require__) {
// most Object methods by ES6 should accept primitives
    var $export = __webpack_require__(0)
    var core = __webpack_require__(15)
    var fails = __webpack_require__(5)
    module.exports = function (KEY, exec) {
      var fn = (core.Object || {})[KEY] || Object[KEY]
      var exp = {}
      exp[KEY] = exec(fn)
      $export($export.S + $export.F * fails(function () { fn(1) }), 'Object', exp)
    }
  /** */ },
/* 29 */
  /** */ function (module, exports) {
// 7.1.4 ToInteger
    var ceil = Math.ceil
    var floor = Math.floor
    module.exports = function (it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it)
    }
  /** */ },
/* 30 */
  /** */ function (module, exports) {
// 7.2.1 RequireObjectCoercible(argument)
    module.exports = function (it) {
      if (it == undefined) throw TypeError("Can't call method on  " + it)
      return it
    }
  /** */ },
/* 31 */
  /** */ function (module, exports, __webpack_require__) {
    var Map = __webpack_require__(153)
    var $export = __webpack_require__(0)
    var shared = __webpack_require__(73)('metadata')
    var store = shared.store || (shared.store = new (__webpack_require__(155))())

    var getOrCreateMetadataMap = function (target, targetKey, create) {
      var targetMetadata = store.get(target)
      if (!targetMetadata) {
        if (!create) return undefined
        store.set(target, targetMetadata = new Map())
      }
      var keyMetadata = targetMetadata.get(targetKey)
      if (!keyMetadata) {
        if (!create) return undefined
        targetMetadata.set(targetKey, keyMetadata = new Map())
      } return keyMetadata
    }
    var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
      var metadataMap = getOrCreateMetadataMap(O, P, false)
      return metadataMap === undefined ? false : metadataMap.has(MetadataKey)
    }
    var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
      var metadataMap = getOrCreateMetadataMap(O, P, false)
      return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey)
    }
    var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
      getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue)
    }
    var ordinaryOwnMetadataKeys = function (target, targetKey) {
      var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
      var keys = []
      if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key) })
      return keys
    }
    var toMetaKey = function (it) {
      return it === undefined || typeof it === 'symbol' ? it : String(it)
    }
    var exp = function (O) {
      $export($export.S, 'Reflect', O)
    }

    module.exports = {
      store: store,
      map: getOrCreateMetadataMap,
      has: ordinaryHasOwnMetadata,
      get: ordinaryGetOwnMetadata,
      set: ordinaryDefineOwnMetadata,
      keys: ordinaryOwnMetadataKeys,
      key: toMetaKey,
      exp: exp
    }
  /** */ },
/* 32 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    if (__webpack_require__(12)) {
      var LIBRARY = __webpack_require__(46)
      var global = __webpack_require__(2)
      var fails = __webpack_require__(5)
      var $export = __webpack_require__(0)
      var $typed = __webpack_require__(75)
      var $buffer = __webpack_require__(104)
      var ctx = __webpack_require__(20)
      var anInstance = __webpack_require__(43)
      var propertyDesc = __webpack_require__(39)
      var hide = __webpack_require__(22)
      var redefineAll = __webpack_require__(47)
      var toInteger = __webpack_require__(29)
      var toLength = __webpack_require__(8)
      var toIndex = __webpack_require__(150)
      var toAbsoluteIndex = __webpack_require__(49)
      var toPrimitive = __webpack_require__(40)
      var has = __webpack_require__(21)
      var classof = __webpack_require__(44)
      var isObject = __webpack_require__(4)
      var toObject = __webpack_require__(13)
      var isArrayIter = __webpack_require__(87)
      var create = __webpack_require__(37)
      var getPrototypeOf = __webpack_require__(18)
      var gOPN = __webpack_require__(57).f
      var getIterFn = __webpack_require__(60)
      var uid = __webpack_require__(52)
      var wks = __webpack_require__(9)
      var createArrayMethod = __webpack_require__(25)
      var createArrayIncludes = __webpack_require__(64)
      var speciesConstructor = __webpack_require__(74)
      var ArrayIterators = __webpack_require__(106)
      var Iterators = __webpack_require__(45)
      var $iterDetect = __webpack_require__(88)
      var setSpecies = __webpack_require__(48)
      var arrayFill = __webpack_require__(79)
      var arrayCopyWithin = __webpack_require__(121)
      var $DP = __webpack_require__(11)
      var $GOPD = __webpack_require__(23)
      var dP = $DP.f
      var gOPD = $GOPD.f
      var RangeError = global.RangeError
      var TypeError = global.TypeError
      var Uint8Array = global.Uint8Array
      var ARRAY_BUFFER = 'ArrayBuffer'
      var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER
      var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'
      var PROTOTYPE = 'prototype'
      var ArrayProto = Array[PROTOTYPE]
      var $ArrayBuffer = $buffer.ArrayBuffer
      var $DataView = $buffer.DataView
      var arrayForEach = createArrayMethod(0)
      var arrayFilter = createArrayMethod(2)
      var arraySome = createArrayMethod(3)
      var arrayEvery = createArrayMethod(4)
      var arrayFind = createArrayMethod(5)
      var arrayFindIndex = createArrayMethod(6)
      var arrayIncludes = createArrayIncludes(true)
      var arrayIndexOf = createArrayIncludes(false)
      var arrayValues = ArrayIterators.values
      var arrayKeys = ArrayIterators.keys
      var arrayEntries = ArrayIterators.entries
      var arrayLastIndexOf = ArrayProto.lastIndexOf
      var arrayReduce = ArrayProto.reduce
      var arrayReduceRight = ArrayProto.reduceRight
      var arrayJoin = ArrayProto.join
      var arraySort = ArrayProto.sort
      var arraySlice = ArrayProto.slice
      var arrayToString = ArrayProto.toString
      var arrayToLocaleString = ArrayProto.toLocaleString
      var ITERATOR = wks('iterator')
      var TAG = wks('toStringTag')
      var TYPED_CONSTRUCTOR = uid('typed_constructor')
      var DEF_CONSTRUCTOR = uid('def_constructor')
      var ALL_CONSTRUCTORS = $typed.CONSTR
      var TYPED_ARRAY = $typed.TYPED
      var VIEW = $typed.VIEW
      var WRONG_LENGTH = 'Wrong length!'

      var $map = createArrayMethod(1, function (O, length) {
        return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length)
      })

      var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
        return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1
      })

      var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
        new Uint8Array(1).set({})
      })

      var toOffset = function (it, BYTES) {
        var offset = toInteger(it)
        if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!')
        return offset
      }

      var validate = function (it) {
        if (isObject(it) && TYPED_ARRAY in it) return it
        throw TypeError(it + ' is not a typed array!')
      }

      var allocate = function (C, length) {
        if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
          throw TypeError('It is not a typed array constructor!')
        } return new C(length)
      }

      var speciesFromList = function (O, list) {
        return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list)
      }

      var fromList = function (C, list) {
        var index = 0
        var length = list.length
        var result = allocate(C, length)
        while (length > index) result[index] = list[index++]
        return result
      }

      var addGetter = function (it, key, internal) {
        dP(it, key, { get: function () { return this._d[internal] } })
      }

      var $from = function from (source /* , mapfn, thisArg */) {
        var O = toObject(source)
        var aLen = arguments.length
        var mapfn = aLen > 1 ? arguments[1] : undefined
        var mapping = mapfn !== undefined
        var iterFn = getIterFn(O)
        var i, length, values, result, step, iterator
        if (iterFn != undefined && !isArrayIter(iterFn)) {
          for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
            values.push(step.value)
          } O = values
        }
        if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2)
        for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
          result[i] = mapping ? mapfn(O[i], i) : O[i]
        }
        return result
      }

      var $of = function of (/* ...items */) {
        var index = 0
        var length = arguments.length
        var result = allocate(this, length)
        while (length > index) result[index] = arguments[index++]
        return result
      }

  // iOS Safari 6.x fails here
      var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)) })

      var $toLocaleString = function toLocaleString () {
        return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments)
      }

      var proto = {
        copyWithin: function copyWithin (target, start /* , end */) {
          return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined)
        },
        every: function every (callbackfn /* , thisArg */) {
          return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)
        },
        fill: function fill (value /* , start, end */) { // eslint-disable-line no-unused-vars
          return arrayFill.apply(validate(this), arguments)
        },
        filter: function filter (callbackfn /* , thisArg */) {
          return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined))
        },
        find: function find (predicate /* , thisArg */) {
          return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined)
        },
        findIndex: function findIndex (predicate /* , thisArg */) {
          return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined)
        },
        forEach: function forEach (callbackfn /* , thisArg */) {
          arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)
        },
        indexOf: function indexOf (searchElement /* , fromIndex */) {
          return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined)
        },
        includes: function includes (searchElement /* , fromIndex */) {
          return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined)
        },
        join: function join (separator) { // eslint-disable-line no-unused-vars
          return arrayJoin.apply(validate(this), arguments)
        },
        lastIndexOf: function lastIndexOf (searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
          return arrayLastIndexOf.apply(validate(this), arguments)
        },
        map: function map (mapfn /* , thisArg */) {
          return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined)
        },
        reduce: function reduce (callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
          return arrayReduce.apply(validate(this), arguments)
        },
        reduceRight: function reduceRight (callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
          return arrayReduceRight.apply(validate(this), arguments)
        },
        reverse: function reverse () {
          var that = this
          var length = validate(that).length
          var middle = Math.floor(length / 2)
          var index = 0
          var value
          while (index < middle) {
            value = that[index]
            that[index++] = that[--length]
            that[length] = value
          } return that
        },
        some: function some (callbackfn /* , thisArg */) {
          return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)
        },
        sort: function sort (comparefn) {
          return arraySort.call(validate(this), comparefn)
        },
        subarray: function subarray (begin, end) {
          var O = validate(this)
          var length = O.length
          var $begin = toAbsoluteIndex(begin, length)
          return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      )
        }
      }

      var $slice = function slice (start, end) {
        return speciesFromList(this, arraySlice.call(validate(this), start, end))
      }

      var $set = function set (arrayLike /* , offset */) {
        validate(this)
        var offset = toOffset(arguments[1], 1)
        var length = this.length
        var src = toObject(arrayLike)
        var len = toLength(src.length)
        var index = 0
        if (len + offset > length) throw RangeError(WRONG_LENGTH)
        while (index < len) this[offset + index] = src[index++]
      }

      var $iterators = {
        entries: function entries () {
          return arrayEntries.call(validate(this))
        },
        keys: function keys () {
          return arrayKeys.call(validate(this))
        },
        values: function values () {
          return arrayValues.call(validate(this))
        }
      }

      var isTAIndex = function (target, key) {
        return isObject(target) &&
      target[TYPED_ARRAY] &&
      typeof key !== 'symbol' &&
      key in target &&
      String(+key) == String(key)
      }
      var $getDesc = function getOwnPropertyDescriptor (target, key) {
        return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key)
      }
      var $setDesc = function defineProperty (target, key, desc) {
        if (isTAIndex(target, key = toPrimitive(key, true)) &&
      isObject(desc) &&
      has(desc, 'value') &&
      !has(desc, 'get') &&
      !has(desc, 'set') &&
      // TODO: add validation descriptor w/o calling accessors
      !desc.configurable &&
      (!has(desc, 'writable') || desc.writable) &&
      (!has(desc, 'enumerable') || desc.enumerable)
    ) {
          target[key] = desc.value
          return target
        } return dP(target, key, desc)
      }

      if (!ALL_CONSTRUCTORS) {
        $GOPD.f = $getDesc
        $DP.f = $setDesc
      }

      $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
        getOwnPropertyDescriptor: $getDesc,
        defineProperty: $setDesc
      })

      if (fails(function () { arrayToString.call({}) })) {
        arrayToString = arrayToLocaleString = function toString () {
          return arrayJoin.call(this)
        }
      }

      var $TypedArrayPrototype$ = redefineAll({}, proto)
      redefineAll($TypedArrayPrototype$, $iterators)
      hide($TypedArrayPrototype$, ITERATOR, $iterators.values)
      redefineAll($TypedArrayPrototype$, {
        slice: $slice,
        set: $set,
        constructor: function () { /* noop */ },
        toString: arrayToString,
        toLocaleString: $toLocaleString
      })
      addGetter($TypedArrayPrototype$, 'buffer', 'b')
      addGetter($TypedArrayPrototype$, 'byteOffset', 'o')
      addGetter($TypedArrayPrototype$, 'byteLength', 'l')
      addGetter($TypedArrayPrototype$, 'length', 'e')
      dP($TypedArrayPrototype$, TAG, {
        get: function () { return this[TYPED_ARRAY] }
      })

  // eslint-disable-next-line max-statements
      module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
        CLAMPED = !!CLAMPED
        var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
        var GETTER = 'get' + KEY
        var SETTER = 'set' + KEY
        var TypedArray = global[NAME]
        var Base = TypedArray || {}
        var TAC = TypedArray && getPrototypeOf(TypedArray)
        var FORCED = !TypedArray || !$typed.ABV
        var O = {}
        var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE]
        var getter = function (that, index) {
          var data = that._d
          return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN)
        }
        var setter = function (that, index, value) {
          var data = that._d
          if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff
          data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN)
        }
        var addElement = function (that, index) {
          dP(that, index, {
            get: function () {
              return getter(this, index)
            },
            set: function (value) {
              return setter(this, index, value)
            },
            enumerable: true
          })
        }
        if (FORCED) {
          TypedArray = wrapper(function (that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME, '_d')
            var index = 0
            var offset = 0
            var buffer, byteLength, length, klass
            if (!isObject(data)) {
              length = toIndex(data)
              byteLength = length * BYTES
              buffer = new $ArrayBuffer(byteLength)
            } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
              buffer = data
              offset = toOffset($offset, BYTES)
              var $len = data.byteLength
              if ($length === undefined) {
                if ($len % BYTES) throw RangeError(WRONG_LENGTH)
                byteLength = $len - offset
                if (byteLength < 0) throw RangeError(WRONG_LENGTH)
              } else {
                byteLength = toLength($length) * BYTES
                if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH)
              }
              length = byteLength / BYTES
            } else if (TYPED_ARRAY in data) {
              return fromList(TypedArray, data)
            } else {
              return $from.call(TypedArray, data)
            }
            hide(that, '_d', {
              b: buffer,
              o: offset,
              l: byteLength,
              e: length,
              v: new $DataView(buffer)
            })
            while (index < length) addElement(that, index++)
          })
          TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$)
          hide(TypedArrayPrototype, 'constructor', TypedArray)
        } else if (!fails(function () {
          TypedArray(1)
        }) || !fails(function () {
          new TypedArray(-1) // eslint-disable-line no-new
        }) || !$iterDetect(function (iter) {
          new TypedArray() // eslint-disable-line no-new
          new TypedArray(null) // eslint-disable-line no-new
          new TypedArray(1.5) // eslint-disable-line no-new
          new TypedArray(iter) // eslint-disable-line no-new
        }, true)) {
          TypedArray = wrapper(function (that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME)
            var klass
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
            if (!isObject(data)) return new Base(toIndex(data))
            if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
              return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data)
            }
            if (TYPED_ARRAY in data) return fromList(TypedArray, data)
            return $from.call(TypedArray, data)
          })
          arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
            if (!(key in TypedArray)) hide(TypedArray, key, Base[key])
          })
          TypedArray[PROTOTYPE] = TypedArrayPrototype
          if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray
        }
        var $nativeIterator = TypedArrayPrototype[ITERATOR]
        var CORRECT_ITER_NAME = !!$nativeIterator &&
      ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
        var $iterator = $iterators.values
        hide(TypedArray, TYPED_CONSTRUCTOR, true)
        hide(TypedArrayPrototype, TYPED_ARRAY, NAME)
        hide(TypedArrayPrototype, VIEW, true)
        hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray)

        if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
          dP(TypedArrayPrototype, TAG, {
            get: function () { return NAME }
          })
        }

        O[NAME] = TypedArray

        $export($export.G + $export.W + $export.F * (TypedArray != Base), O)

        $export($export.S, NAME, {
          BYTES_PER_ELEMENT: BYTES
        })

        $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1) }), NAME, {
          from: $from,
          of: $of
        })

        if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES)

        $export($export.P, NAME, proto)

        setSpecies(NAME)

        $export($export.P + $export.F * FORCED_SET, NAME, { set: $set })

        $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators)

        if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString

        $export($export.P + $export.F * fails(function () {
          new TypedArray(1).slice()
        }), NAME, { slice: $slice })

        $export($export.P + $export.F * (fails(function () {
          return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
        }) || !fails(function () {
          TypedArrayPrototype.toLocaleString.call([1, 2])
        })), NAME, { toLocaleString: $toLocaleString })

        Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator
        if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator)
      }
    } else module.exports = function () { /* empty */ }
  /** */ },
/* 33 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (module, global) {
      var __WEBPACK_AMD_DEFINE_RESULT__/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = 'function' === 'function' && __webpack_require__(463)

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    'function': true,
    'object': true
  }

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
    freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global === 'object' && global

  if (freeGlobal && (freeGlobal['global'] === freeGlobal || freeGlobal['window'] === freeGlobal || freeGlobal['self'] === freeGlobal)) {
    root = freeGlobal
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext (context, exports) {
    context || (context = root['Object']())
    exports || (exports = root['Object']())

    // Native constructor aliases.
    var Number = context['Number'] || root['Number'],
      String = context['String'] || root['String'],
      Object = context['Object'] || root['Object'],
      Date = context['Date'] || root['Date'],
      SyntaxError = context['SyntaxError'] || root['SyntaxError'],
      TypeError = context['TypeError'] || root['TypeError'],
      Math = context['Math'] || root['Math'],
      nativeJSON = context['JSON'] || root['JSON']

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON === 'object' && nativeJSON) {
      exports.stringify = nativeJSON.stringify
      exports.parse = nativeJSON.parse
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
      getClass = objectProto.toString,
      isProperty, forEach, undef

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292)
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has (name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name]
      }
      var isSupported
      if (name == 'bug-string-char-index') {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = 'a'[0] != 'a'
      } else if (name == 'json') {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has('json-stringify') && has('json-parse')
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}'
        // Test `JSON.stringify`.
        if (name == 'json-stringify') {
          var stringify = exports.stringify, stringifySupported = typeof stringify === 'function' && isExtended
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1
            }).toJSON = value
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === '0' &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === '0' &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === '1' &&
                stringify([value]) == '[1]' &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == '[null]' &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == 'null' &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == '[null,null,null]' &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ 'a': [value, true, false, null, '\x00\b\n\f\r\t'] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === '1' &&
                stringify([1, 2], null, 1) == '[\n 1,\n 2\n]' &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"'
            } catch (exception) {
              stringifySupported = false
            }
          }
          isSupported = stringifySupported
        }
        // Test `JSON.parse`.
        if (name == 'json-parse') {
          var parse = exports.parse
          if (typeof parse === 'function') {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse('0') === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized)
                var parseSupported = value['a'].length == 5 && value['a'][0] === 1
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"')
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse('01') !== 1
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse('1.') !== 1
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false
            }
          }
          isSupported = parseSupported
        }
      }
      return has[name] = !!isSupported
    }

    if (!has('json')) {
      // Common `[[Class]]` name aliases.
      var functionClass = '[object Function]',
        dateClass = '[object Date]',
        numberClass = '[object Number]',
        stringClass = '[object String]',
        arrayClass = '[object Array]',
        booleanClass = '[object Boolean]'

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has('bug-string-char-index')

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400)
        }
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            'toString': 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this)
              // Restore the original prototype chain.
              this.__proto__ = original
              return result
            }
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype
              return property in this && !(property in parent && this[property] === parent[property])
            }
          }
          members = null
          return isProperty.call(this, property)
        }
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0
        }).prototype.valueOf = 0

        // Iterate over a new instance of the `Properties` class.
        members = new Properties()
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++
          }
        }
        Properties = members = null

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ['valueOf', 'toString', 'toLocaleString', 'propertyIsEnumerable', 'isPrototypeOf', 'hasOwnProperty', 'constructor']
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length
            var hasProperty = !isFunction && typeof object.constructor !== 'function' && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == 'prototype') && hasProperty.call(object, property)) {
                callback(property)
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          }
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == 'prototype') && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property)
              }
            }
          }
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor
            for (property in object) {
              if (!(isFunction && property == 'prototype') && isProperty.call(object, property) && !(isConstructor = property === 'constructor')) {
                callback(property)
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = 'constructor'))) {
              callback(property)
            }
          }
        }
        return forEach(object, callback)
      }

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has('json-stringify')) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: '\\\\',
          34: '\\"',
          8: '\\b',
          12: '\\f',
          10: '\\n',
          13: '\\r',
          9: '\\t'
        }

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = '000000'
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width)
        }

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = '\\u00'
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10
          var symbols = useCharIndex && (charIndexBuggy ? value.split('') : value)
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index)
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode]
                break
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16))
                  break
                }
                result += useCharIndex ? symbols[index] : value.charAt(index)
            }
          }
          return result + '"'
        }

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result
          try {
            // Necessary for host object support.
            value = object[property]
          } catch (exception) {}
          if (typeof value === 'object' && value) {
            className = getClass.call(value)
            if (className == dateClass && !isProperty.call(value, 'toJSON')) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5)
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month)
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24
                  minutes = floor(time / 6e4) % 60
                  seconds = floor(time / 1e3) % 60
                  milliseconds = time % 1e3
                } else {
                  year = value.getUTCFullYear()
                  month = value.getUTCMonth()
                  date = value.getUTCDate()
                  hours = value.getUTCHours()
                  minutes = value.getUTCMinutes()
                  seconds = value.getUTCSeconds()
                  milliseconds = value.getUTCMilliseconds()
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? '-' : '+') + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  '-' + toPaddedString(2, month + 1) + '-' + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  'T' + toPaddedString(2, hours) + ':' + toPaddedString(2, minutes) + ':' + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  '.' + toPaddedString(3, milliseconds) + 'Z'
              } else {
                value = null
              }
            } else if (typeof value.toJSON === 'function' && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, 'toJSON'))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property)
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value)
          }
          if (value === null) {
            return 'null'
          }
          className = getClass.call(value)
          if (className == booleanClass) {
            // Booleans are represented literally.
            return '' + value
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? '' + value : 'null'
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote('' + value)
          }
          // Recursively serialize objects and arrays.
          if (typeof value === 'object') {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError()
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value)
            results = []
            // Save the current indentation level and indent one additional level.
            prefix = indentation
            indentation += whitespace
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack)
                results.push(element === undef ? 'null' : element)
              }
              result = results.length ? (whitespace ? '[\n' + indentation + results.join(',\n' + indentation) + '\n' + prefix + ']' : ('[' + results.join(',') + ']')) : '[]'
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack)
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ':' + (whitespace ? ' ' : '') + element)
                }
              })
              result = results.length ? (whitespace ? '{\n' + indentation + results.join(',\n' + indentation) + '\n' + prefix + '}' : ('{' + results.join(',') + '}')) : '{}'
            }
            // Remove the object from the traversed object stack.
            stack.pop()
            return result
          }
        }

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {}
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = '', width > 10 && (width = 10); whitespace.length < width; whitespace += ' ');
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10)
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize('', (value = {}, value[''] = source, value), callback, properties, whitespace, '', [])
        }
      }

      // Public: Parses a JSON source string.
      if (!has('json-parse')) {
        var fromCharCode = String.fromCharCode

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: '\\',
          34: '"',
          47: '/',
          98: '\b',
          116: '\t',
          110: '\n',
          102: '\f',
          114: '\r'
        }

        // Internal: Stores the parser state.
        var Index, Source

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null
          throw SyntaxError()
        }

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode
          while (Index < length) {
            charCode = source.charCodeAt(Index)
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++
                break
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index]
                Index++
                return value
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = '@', Index++; Index < length;) {
                  charCode = source.charCodeAt(Index)
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort()
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index)
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode]
                        Index++
                        break
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index)
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort()
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode('0x' + source.slice(begin, Index))
                        break
                      default:
                        // Invalid escape sequence.
                        abort()
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break
                    }
                    charCode = source.charCodeAt(Index)
                    begin = Index
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index)
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index)
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++
                  return value
                }
                // Unterminated string.
                abort()
              default:
                // Parse numbers and literals.
                begin = Index
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true
                  charCode = source.charCodeAt(++Index)
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort()
                  }
                  isSigned = false
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort()
                    }
                    Index = position
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index)
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index)
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort()
                    }
                    Index = position
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index)
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort()
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == 'true') {
                  Index += 4
                  return true
                } else if (source.slice(Index, Index + 5) == 'false') {
                  Index += 5
                  return false
                } else if (source.slice(Index, Index + 4) == 'null') {
                  Index += 4
                  return null
                }
                // Unrecognized token.
                abort()
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return '$'
        }

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers
          if (value == '$') {
            // Unexpected end of input.
            abort()
          }
          if (typeof value === 'string') {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == '@') {
              // Remove the sentinel `@` character.
              return value.slice(1)
            }
            // Parse object and array literals.
            if (value == '[') {
              // Parses a JSON array, returning a new JavaScript array.
              results = []
              for (;; hasMembers || (hasMembers = true)) {
                value = lex()
                // A closing square bracket marks the end of the array literal.
                if (value == ']') {
                  break
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ',') {
                    value = lex()
                    if (value == ']') {
                      // Unexpected trailing `,` in array literal.
                      abort()
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort()
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ',') {
                  abort()
                }
                results.push(get(value))
              }
              return results
            } else if (value == '{') {
              // Parses a JSON object, returning a new JavaScript object.
              results = {}
              for (;; hasMembers || (hasMembers = true)) {
                value = lex()
                // A closing curly brace marks the end of the object literal.
                if (value == '}') {
                  break
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ',') {
                    value = lex()
                    if (value == '}') {
                      // Unexpected trailing `,` in object literal.
                      abort()
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort()
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == ',' || typeof value !== 'string' || (charIndexBuggy ? value.charAt(0) : value[0]) != '@' || lex() != ':') {
                  abort()
                }
                results[value.slice(1)] = get(lex())
              }
              return results
            }
            // Unexpected token encountered.
            abort()
          }
          return value
        }

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback)
          if (element === undef) {
            delete source[property]
          } else {
            source[property] = element
          }
        }

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length
          if (typeof value === 'object' && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback)
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback)
              })
            }
          }
          return callback.call(source, property, value)
        }

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value
          Index = 0
          Source = '' + source
          result = get(lex())
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != '$') {
            abort()
          }
          // Reset the parser state.
          Index = Source = null
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[''] = result, value), '', callback) : result
        }
      }
    }

    exports['runInContext'] = runInContext
    return exports
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports)
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
      previousJSON = root['JSON3'],
      isRestored = false

    var JSON3 = runInContext(root, (root['JSON3'] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      'noConflict': function () {
        if (!isRestored) {
          isRestored = true
          root.JSON = nativeJSON
          root['JSON3'] = previousJSON
          nativeJSON = previousJSON = null
        }
        return JSON3
      }
    }))

    root.JSON = {
      'parse': JSON3.parse,
      'stringify': JSON3.stringify
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return JSON3
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  }
}).call(this)
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(172)(module), __webpack_require__(6)))
  /** */ },
/* 34 */
  /** */ function (module, exports) {
    module.exports = function () { /* empty */ }
  /** */ },
/* 35 */
  /** */ function (module, exports, __webpack_require__) {
    var ctx = __webpack_require__(20)
    var call = __webpack_require__(133)
    var isArrayIter = __webpack_require__(87)
    var anObject = __webpack_require__(1)
    var toLength = __webpack_require__(8)
    var getIterFn = __webpack_require__(60)
    var BREAK = {}
    var RETURN = {}
    var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
      var iterFn = ITERATOR ? function () { return iterable } : getIterFn(iterable)
      var f = ctx(fn, that, entries ? 2 : 1)
      var index = 0
      var length, step, iterator, result
      if (typeof iterFn !== 'function') throw TypeError(iterable + ' is not iterable!')
  // fast case for arrays with default iterator
      if (isArrayIter(iterFn)) {
        for (length = toLength(iterable.length); length > index; index++) {
          result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index])
          if (result === BREAK || result === RETURN) return result
        }
      } else {
        for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
          result = call(iterator, f, step.value, entries)
          if (result === BREAK || result === RETURN) return result
        }
      }
    }
    exports.BREAK = BREAK
    exports.RETURN = RETURN
  /** */ },
/* 36 */
  /** */ function (module, exports, __webpack_require__) {
    var META = __webpack_require__(52)('meta')
    var isObject = __webpack_require__(4)
    var has = __webpack_require__(21)
    var setDesc = __webpack_require__(11).f
    var id = 0
    var isExtensible = Object.isExtensible || function () {
      return true
    }
    var FREEZE = !__webpack_require__(5)(function () {
      return isExtensible(Object.preventExtensions({}))
    })
    var setMeta = function (it) {
      setDesc(it, META, { value: {
        i: 'O' + ++id, // object ID
        w: {}          // weak collections IDs
      }})
    }
    var fastKey = function (it, create) {
  // return primitive with prefix
      if (!isObject(it)) return typeof it === 'symbol' ? it : (typeof it === 'string' ? 'S' : 'P') + it
      if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F'
    // not necessary to add metadata
        if (!create) return 'E'
    // add missing metadata
        setMeta(it)
  // return object ID
      } return it[META].i
    }
    var getWeak = function (it, create) {
      if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true
    // not necessary to add metadata
        if (!create) return false
    // add missing metadata
        setMeta(it)
  // return hash weak collections IDs
      } return it[META].w
    }
// add metadata on freeze-family methods calling
    var onFreeze = function (it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it)
      return it
    }
    var meta = module.exports = {
      KEY: META,
      NEED: false,
      fastKey: fastKey,
      getWeak: getWeak,
      onFreeze: onFreeze
    }
  /** */ },
/* 37 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
    var anObject = __webpack_require__(1)
    var dPs = __webpack_require__(138)
    var enumBugKeys = __webpack_require__(83)
    var IE_PROTO = __webpack_require__(98)('IE_PROTO')
    var Empty = function () { /* empty */ }
    var PROTOTYPE = 'prototype'

// Create object with fake `null` prototype: use iframe Object with cleared prototype
    var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
      var iframe = __webpack_require__(82)('iframe')
      var i = enumBugKeys.length
      var lt = '<'
      var gt = '>'
      var iframeDocument
      iframe.style.display = 'none'
      __webpack_require__(85).appendChild(iframe)
      iframe.src = 'javascript:' // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
      iframeDocument = iframe.contentWindow.document
      iframeDocument.open()
      iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt)
      iframeDocument.close()
      createDict = iframeDocument.F
      while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]
      return createDict()
    }

    module.exports = Object.create || function create (O, Properties) {
      var result
      if (O !== null) {
        Empty[PROTOTYPE] = anObject(O)
        result = new Empty()
        Empty[PROTOTYPE] = null
    // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O
      } else result = createDict()
      return Properties === undefined ? result : dPs(result, Properties)
    }
  /** */ },
/* 38 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
    var $keys = __webpack_require__(140)
    var enumBugKeys = __webpack_require__(83)

    module.exports = Object.keys || function keys (O) {
      return $keys(O, enumBugKeys)
    }
  /** */ },
/* 39 */
  /** */ function (module, exports) {
    module.exports = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      }
    }
  /** */ },
/* 40 */
  /** */ function (module, exports, __webpack_require__) {
// 7.1.1 ToPrimitive(input [, PreferredType])
    var isObject = __webpack_require__(4)
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
    module.exports = function (it, S) {
      if (!isObject(it)) return it
      var fn, val
      if (S && typeof (fn = it.toString) === 'function' && !isObject(val = fn.call(it))) return val
      if (typeof (fn = it.valueOf) === 'function' && !isObject(val = fn.call(it))) return val
      if (!S && typeof (fn = it.toString) === 'function' && !isObject(val = fn.call(it))) return val
      throw TypeError("Can't convert object to primitive value")
    }
  /** */ },
/* 41 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) {
      var random = __webpack_require__(55)

      var onUnload = {},
        afterUnload = false,
    // detect google chrome packaged apps because they don't allow the 'unload' event
        isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime

      module.exports = {
        attachEvent: function (event, listener) {
          if (typeof global.addEventListener !== 'undefined') {
            global.addEventListener(event, listener, false)
          } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
            global.document.attachEvent('on' + event, listener)
      // I get 'window' for ie8.
            global.attachEvent('on' + event, listener)
          }
        },

        detachEvent: function (event, listener) {
          if (typeof global.addEventListener !== 'undefined') {
            global.removeEventListener(event, listener, false)
          } else if (global.document && global.detachEvent) {
            global.document.detachEvent('on' + event, listener)
            global.detachEvent('on' + event, listener)
          }
        },

        unloadAdd: function (listener) {
          if (isChromePackagedApp) {
            return null
          }

          var ref = random.string(8)
          onUnload[ref] = listener
          if (afterUnload) {
            setTimeout(this.triggerUnloadCallbacks, 0)
          }
          return ref
        },

        unloadDel: function (ref) {
          if (ref in onUnload) {
            delete onUnload[ref]
          }
        },

        triggerUnloadCallbacks: function () {
          for (var ref in onUnload) {
            onUnload[ref]()
            delete onUnload[ref]
          }
        }
      }

      var unloadTriggered = function () {
        if (afterUnload) {
          return
        }
        afterUnload = true
        module.exports.triggerUnloadCallbacks()
      }

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
      if (!isChromePackagedApp) {
        module.exports.attachEvent('unload', unloadTriggered)
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 42 */
  /** */ function (module, exports) {
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

    module.exports = function (obj, key, value) {
      var flags = obj.__flags || (obj.__flags = Object.create(null))
      if (arguments.length === 3) {
        flags[key] = value
      } else {
        return flags[key]
      }
    }
  /** */ },
/* 43 */
  /** */ function (module, exports) {
    module.exports = function (it, Constructor, name, forbiddenField) {
      if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
        throw TypeError(name + ': incorrect invocation!')
      } return it
    }
  /** */ },
/* 44 */
  /** */ function (module, exports, __webpack_require__) {
// getting tag from 19.1.3.6 Object.prototype.toString()
    var cof = __webpack_require__(27)
    var TAG = __webpack_require__(9)('toStringTag')
// ES3 wrong here
    var ARG = cof(function () { return arguments }()) == 'Arguments'

// fallback for IE11 Script Access Denied error
    var tryGet = function (it, key) {
      try {
        return it[key]
      } catch (e) { /* empty */ }
    }

    module.exports = function (it) {
      var O, T, B
      return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) === 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee === 'function' ? 'Arguments' : B
    }
  /** */ },
/* 45 */
  /** */ function (module, exports) {
    module.exports = {}
  /** */ },
/* 46 */
  /** */ function (module, exports) {
    module.exports = true
  /** */ },
/* 47 */
  /** */ function (module, exports, __webpack_require__) {
    var hide = __webpack_require__(22)
    module.exports = function (target, src, safe) {
      for (var key in src) {
        if (safe && target[key]) target[key] = src[key]
        else hide(target, key, src[key])
      } return target
    }
  /** */ },
/* 48 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var global = __webpack_require__(2)
    var core = __webpack_require__(15)
    var dP = __webpack_require__(11)
    var DESCRIPTORS = __webpack_require__(12)
    var SPECIES = __webpack_require__(9)('species')

    module.exports = function (KEY) {
      var C = typeof core[KEY] === 'function' ? core[KEY] : global[KEY]
      if (DESCRIPTORS && C && !C[SPECIES]) {
        dP.f(C, SPECIES, {
          configurable: true,
          get: function () { return this }
        })
      }
    }
  /** */ },
/* 49 */
  /** */ function (module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(29)
    var max = Math.max
    var min = Math.min
    module.exports = function (index, length) {
      index = toInteger(index)
      return index < 0 ? max(index + length, 0) : min(index, length)
    }
  /** */ },
/* 50 */
  /** */ function (module, exports) {
    module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

      includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

      showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

      truncateThreshold: 40

    }
  /** */ },
/* 51 */
  /** */ function (module, exports, __webpack_require__) {
    var def = __webpack_require__(11).f
    var has = __webpack_require__(21)
    var TAG = __webpack_require__(9)('toStringTag')

    module.exports = function (it, tag, stat) {
      if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag })
    }
  /** */ },
/* 52 */
  /** */ function (module, exports) {
    var id = 0
    var px = Math.random()
    module.exports = function (key) {
      return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36))
    }
  /** */ },
/* 53 */
  /** */ function (module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4)
    module.exports = function (it, TYPE) {
      if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!')
      return it
    }
  /** */ },
/* 54 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var inherits = __webpack_require__(3),
        urlUtils = __webpack_require__(24),
        SenderReceiver = __webpack_require__(166)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:ajax-based')
      }

      function createAjaxSender (AjaxObject) {
        return function (url, payload, callback) {
          debug('create ajax sender', url, payload)
          var opt = {}
          if (typeof payload === 'string') {
            opt.headers = { 'Content-type': 'text/plain' }
          }
          var ajaxUrl = urlUtils.addPath(url, '/xhr_send')
          var xo = new AjaxObject('POST', ajaxUrl, payload, opt)
          xo.once('finish', function (status) {
            debug('finish', status)
            xo = null

            if (status !== 200 && status !== 204) {
              return callback(new Error('http status ' + status))
            }
            callback()
          })
          return function () {
            debug('abort')
            xo.close()
            xo = null

            var err = new Error('Aborted')
            err.code = 1000
            callback(err)
          }
        }
      }

      function AjaxBasedTransport (transUrl, urlSuffix, Receiver, AjaxObject) {
        SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject)
      }

      inherits(AjaxBasedTransport, SenderReceiver)

      module.exports = AjaxBasedTransport
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 55 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

/* global crypto:true */
    var crypto = __webpack_require__(455)

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
    var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345'
    module.exports = {
      string: function (length) {
        var max = _randomStringChars.length
        var bytes = crypto.randomBytes(length)
        var ret = []
        for (var i = 0; i < length; i++) {
          ret.push(_randomStringChars.substr(bytes[i] % max, 1))
        }
        return ret.join('')
      },

      number: function (max) {
        return Math.floor(Math.random() * max)
      },

      numberString: function (max) {
        var t = ('' + (max - 1)).length
        var p = new Array(t + 1).join('0')
        return (p + this.number(max)).slice(-t)
      }
    }
  /** */ },
/* 56 */
  /** */ function (module, exports, __webpack_require__) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
    var cof = __webpack_require__(27)
// eslint-disable-next-line no-prototype-builtins
    module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
      return cof(it) == 'String' ? it.split('') : Object(it)
    }
  /** */ },
/* 57 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
    var $keys = __webpack_require__(140)
    var hiddenKeys = __webpack_require__(83).concat('length', 'prototype')

    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames (O) {
      return $keys(O, hiddenKeys)
    }
  /** */ },
/* 58 */
  /** */ function (module, exports) {
    exports.f = {}.propertyIsEnumerable
  /** */ },
/* 59 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var defined = __webpack_require__(30)
    var fails = __webpack_require__(5)
    var spaces = __webpack_require__(102)
    var space = '[' + spaces + ']'
    var non = '\u200b\u0085'
    var ltrim = RegExp('^' + space + space + '*')
    var rtrim = RegExp(space + space + '*$')

    var exporter = function (KEY, exec, ALIAS) {
      var exp = {}
      var FORCE = fails(function () {
        return !!spaces[KEY]() || non[KEY]() != non
      })
      var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]
      if (ALIAS) exp[ALIAS] = fn
      $export($export.P + $export.F * FORCE, 'String', exp)
    }

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
    var trim = exporter.trim = function (string, TYPE) {
      string = String(defined(string))
      if (TYPE & 1) string = string.replace(ltrim, '')
      if (TYPE & 2) string = string.replace(rtrim, '')
      return string
    }

    module.exports = exporter
  /** */ },
/* 60 */
  /** */ function (module, exports, __webpack_require__) {
    var classof = __webpack_require__(44)
    var ITERATOR = __webpack_require__(9)('iterator')
    var Iterators = __webpack_require__(45)
    module.exports = __webpack_require__(15).getIteratorMethod = function (it) {
      if (it != undefined) {
        return it[ITERATOR] ||
    it['@@iterator'] ||
    Iterators[classof(it)]
      }
    }
  /** */ },
/* 61 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      XhrDriver = __webpack_require__(161)

    function XHRLocalObject (method, url, payload /*, opts */) {
      XhrDriver.call(this, method, url, payload, {
        noCredentials: true
      })
    }

    inherits(XHRLocalObject, XhrDriver)

    XHRLocalObject.enabled = XhrDriver.enabled

    module.exports = XHRLocalObject
  /** */ },
/* 62 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) {
      module.exports = {
        isOpera: function () {
          return global.navigator &&
      /opera/i.test(global.navigator.userAgent)
        },

        isKonqueror: function () {
          return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent)
        },

  // #187 wrap document.domain in try/catch because of WP8 from file:///
        hasDomain: function () {
    // non-browser client always has a domain
          if (!global.document) {
            return true
          }

          try {
            return !!global.document.domain
          } catch (e) {
            return false
          }
        }
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 63 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process, global) {
      var eventUtils = __webpack_require__(41),
        JSON3 = __webpack_require__(33),
        browser = __webpack_require__(62)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:utils:iframe')
      }

      module.exports = {
        WPrefix: '_jp',
        currentWindowId: null,

        polluteGlobalNamespace: function () {
          if (!(module.exports.WPrefix in global)) {
            global[module.exports.WPrefix] = {}
          }
        },

        postMessage: function (type, data) {
          if (global.parent !== global) {
            global.parent.postMessage(JSON3.stringify({
              windowId: module.exports.currentWindowId,
              type: type,
              data: data || ''
            }), '*')
          } else {
            debug('Cannot postMessage, no parent window.', type, data)
          }
        },

        createIframe: function (iframeUrl, errorCallback) {
          var iframe = global.document.createElement('iframe')
          var tref, unloadRef
          var unattach = function () {
            debug('unattach')
            clearTimeout(tref)
      // Explorer had problems with that.
            try {
              iframe.onload = null
            } catch (x) {
        // intentionally empty
            }
            iframe.onerror = null
          }
          var cleanup = function () {
            debug('cleanup')
            if (iframe) {
              unattach()
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
              setTimeout(function () {
                if (iframe) {
                  iframe.parentNode.removeChild(iframe)
                }
                iframe = null
              }, 0)
              eventUtils.unloadDel(unloadRef)
            }
          }
          var onerror = function (err) {
            debug('onerror', err)
            if (iframe) {
              cleanup()
              errorCallback(err)
            }
          }
          var post = function (msg, origin) {
            debug('post', msg, origin)
            setTimeout(function () {
              try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
                if (iframe && iframe.contentWindow) {
                  iframe.contentWindow.postMessage(msg, origin)
                }
              } catch (x) {
          // intentionally empty
              }
            }, 0)
          }

          iframe.src = iframeUrl
          iframe.style.display = 'none'
          iframe.style.position = 'absolute'
          iframe.onerror = function () {
            onerror('onerror')
          }
          iframe.onload = function () {
            debug('onload')
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
            clearTimeout(tref)
            tref = setTimeout(function () {
              onerror('onload timeout')
            }, 2000)
          }
          global.document.body.appendChild(iframe)
          tref = setTimeout(function () {
            onerror('timeout')
          }, 15000)
          unloadRef = eventUtils.unloadAdd(cleanup)
          return {
            post: post,
            cleanup: cleanup,
            loaded: unattach
          }
        },

/* eslint no-undef: "off", new-cap: "off" */
        createHtmlfile: function (iframeUrl, errorCallback) {
          var axo = ['Active'].concat('Object').join('X')
          var doc = new global[axo]('htmlfile')
          var tref, unloadRef
          var iframe
          var unattach = function () {
            clearTimeout(tref)
            iframe.onerror = null
          }
          var cleanup = function () {
            if (doc) {
              unattach()
              eventUtils.unloadDel(unloadRef)
              iframe.parentNode.removeChild(iframe)
              iframe = doc = null
              CollectGarbage()
            }
          }
          var onerror = function (r) {
            debug('onerror', r)
            if (doc) {
              cleanup()
              errorCallback(r)
            }
          }
          var post = function (msg, origin) {
            try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
              setTimeout(function () {
                if (iframe && iframe.contentWindow) {
                  iframe.contentWindow.postMessage(msg, origin)
                }
              }, 0)
            } catch (x) {
        // intentionally empty
            }
          }

          doc.open()
          doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>')
          doc.close()
          doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix]
          var c = doc.createElement('div')
          doc.body.appendChild(c)
          iframe = doc.createElement('iframe')
          c.appendChild(iframe)
          iframe.src = iframeUrl
          iframe.onerror = function () {
            onerror('onerror')
          }
          tref = setTimeout(function () {
            onerror('timeout')
          }, 15000)
          unloadRef = eventUtils.unloadAdd(cleanup)
          return {
            post: post,
            cleanup: cleanup,
            loaded: unattach
          }
        }
      }

      module.exports.iframeEnabled = false
      if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
        module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror())
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7), __webpack_require__(6)))
  /** */ },
/* 64 */
  /** */ function (module, exports, __webpack_require__) {
// false -> Array#indexOf
// true  -> Array#includes
    var toIObject = __webpack_require__(16)
    var toLength = __webpack_require__(8)
    var toAbsoluteIndex = __webpack_require__(49)
    module.exports = function (IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIObject($this)
        var length = toLength(O.length)
        var index = toAbsoluteIndex(fromIndex, length)
        var value
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
        if (IS_INCLUDES && el != el) {
          while (length > index) {
            value = O[index++]
      // eslint-disable-next-line no-self-compare
            if (value != value) return true
    // Array#indexOf ignores holes, Array#includes - not
          }
        } else {
          for (;length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0
            }
          }
        } return !IS_INCLUDES && -1
      }
    }
  /** */ },
/* 65 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var global = __webpack_require__(2)
    var $export = __webpack_require__(0)
    var meta = __webpack_require__(36)
    var fails = __webpack_require__(5)
    var hide = __webpack_require__(22)
    var redefineAll = __webpack_require__(47)
    var forOf = __webpack_require__(35)
    var anInstance = __webpack_require__(43)
    var isObject = __webpack_require__(4)
    var setToStringTag = __webpack_require__(51)
    var dP = __webpack_require__(11).f
    var each = __webpack_require__(25)(0)
    var DESCRIPTORS = __webpack_require__(12)

    module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
      var Base = global[NAME]
      var C = Base
      var ADDER = IS_MAP ? 'set' : 'add'
      var proto = C && C.prototype
      var O = {}
      if (!DESCRIPTORS || typeof C !== 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
        new C().entries().next()
      }))) {
    // create collection constructor
        C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER)
        redefineAll(C.prototype, methods)
        meta.NEED = true
      } else {
        C = wrapper(function (target, iterable) {
          anInstance(target, C, NAME, '_c')
          target._c = new Base()
          if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target)
        })
        each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
          var IS_ADDER = KEY == 'add' || KEY == 'set'
          if (KEY in proto && !(IS_WEAK && KEY == 'clear')) {
            hide(C.prototype, KEY, function (a, b) {
              anInstance(this, C, KEY)
              if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false
              var result = this._c[KEY](a === 0 ? 0 : a, b)
              return IS_ADDER ? this : result
            })
          }
        })
        IS_WEAK || dP(C.prototype, 'size', {
          get: function () {
            return this._c.size
          }
        })
      }

      setToStringTag(C, NAME)

      O[NAME] = C
      $export($export.G + $export.W + $export.F, O)

      if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP)

      return C
    }
  /** */ },
/* 66 */
  /** */ function (module, exports, __webpack_require__) {
// 7.2.2 IsArray(argument)
    var cof = __webpack_require__(27)
    module.exports = Array.isArray || function isArray (arg) {
      return cof(arg) == 'Array'
    }
  /** */ },
/* 67 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var create = __webpack_require__(37)
    var descriptor = __webpack_require__(39)
    var setToStringTag = __webpack_require__(51)
    var IteratorPrototype = {}

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
    __webpack_require__(22)(IteratorPrototype, __webpack_require__(9)('iterator'), function () { return this })

    module.exports = function (Constructor, NAME, next) {
      Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) })
      setToStringTag(Constructor, NAME + ' Iterator')
    }
  /** */ },
/* 68 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var LIBRARY = __webpack_require__(46)
    var $export = __webpack_require__(0)
    var redefine = __webpack_require__(96)
    var hide = __webpack_require__(22)
    var has = __webpack_require__(21)
    var Iterators = __webpack_require__(45)
    var $iterCreate = __webpack_require__(67)
    var setToStringTag = __webpack_require__(51)
    var getPrototypeOf = __webpack_require__(18)
    var ITERATOR = __webpack_require__(9)('iterator')
    var BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
    var FF_ITERATOR = '@@iterator'
    var KEYS = 'keys'
    var VALUES = 'values'

    var returnThis = function () { return this }

    module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME, next)
      var getMethod = function (kind) {
        if (!BUGGY && kind in proto) return proto[kind]
        switch (kind) {
          case KEYS: return function keys () { return new Constructor(this, kind) }
          case VALUES: return function values () { return new Constructor(this, kind) }
        } return function entries () { return new Constructor(this, kind) }
      }
      var TAG = NAME + ' Iterator'
      var DEF_VALUES = DEFAULT == VALUES
      var VALUES_BUG = false
      var proto = Base.prototype
      var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
      var $default = $native || getMethod(DEFAULT)
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
      var $anyNative = NAME == 'Array' ? proto.entries || $native : $native
      var methods, key, IteratorPrototype
  // Fix native
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()))
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
          setToStringTag(IteratorPrototype, TAG, true)
      // fix for some old engines
          if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis)
        }
      }
  // fix Array#{values, @@iterator}.name in V8 / FF
      if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true
        $default = function values () { return $native.call(this) }
      }
  // Define iterator
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
        hide(proto, ITERATOR, $default)
      }
  // Plug for library
      Iterators[NAME] = $default
      Iterators[TAG] = returnThis
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        }
        if (FORCED) {
          for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key])
          }
        } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods)
      }
      return methods
    }
  /** */ },
/* 69 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// Forced replacement prototype accessors methods
    module.exports = __webpack_require__(46) || !__webpack_require__(5)(function () {
      var K = Math.random()
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
      __defineSetter__.call(null, K, function () { /* empty */ })
      delete __webpack_require__(2)[K]
    })
  /** */ },
/* 70 */
  /** */ function (module, exports) {
    exports.f = Object.getOwnPropertySymbols
  /** */ },
/* 71 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://tc39.github.io/proposal-setmap-offrom/
    var $export = __webpack_require__(0)
    var aFunction = __webpack_require__(14)
    var ctx = __webpack_require__(20)
    var forOf = __webpack_require__(35)

    module.exports = function (COLLECTION) {
      $export($export.S, COLLECTION, { from: function from (source /* , mapFn, thisArg */) {
        var mapFn = arguments[1]
        var mapping, A, n, cb
        aFunction(this)
        mapping = mapFn !== undefined
        if (mapping) aFunction(mapFn)
        if (source == undefined) return new this()
        A = []
        if (mapping) {
          n = 0
          cb = ctx(mapFn, arguments[2], 2)
          forOf(source, false, function (nextItem) {
            A.push(cb(nextItem, n++))
          })
        } else {
          forOf(source, false, A.push, A)
        }
        return new this(A)
      } })
    }
  /** */ },
/* 72 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://tc39.github.io/proposal-setmap-offrom/
    var $export = __webpack_require__(0)

    module.exports = function (COLLECTION) {
      $export($export.S, COLLECTION, { of: function of () {
        var length = arguments.length
        var A = Array(length)
        while (length--) A[length] = arguments[length]
        return new this(A)
      } })
    }
  /** */ },
/* 73 */
  /** */ function (module, exports, __webpack_require__) {
    var global = __webpack_require__(2)
    var SHARED = '__core-js_shared__'
    var store = global[SHARED] || (global[SHARED] = {})
    module.exports = function (key) {
      return store[key] || (store[key] = {})
    }
  /** */ },
/* 74 */
  /** */ function (module, exports, __webpack_require__) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
    var anObject = __webpack_require__(1)
    var aFunction = __webpack_require__(14)
    var SPECIES = __webpack_require__(9)('species')
    module.exports = function (O, D) {
      var C = anObject(O).constructor
      var S
      return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S)
    }
  /** */ },
/* 75 */
  /** */ function (module, exports, __webpack_require__) {
    var global = __webpack_require__(2)
    var hide = __webpack_require__(22)
    var uid = __webpack_require__(52)
    var TYPED = uid('typed_array')
    var VIEW = uid('view')
    var ABV = !!(global.ArrayBuffer && global.DataView)
    var CONSTR = ABV
    var i = 0
    var l = 9
    var Typed

    var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',')

    while (i < l) {
      if (Typed = global[TypedArrayConstructors[i++]]) {
        hide(Typed.prototype, TYPED, true)
        hide(Typed.prototype, VIEW, true)
      } else CONSTR = false
    }

    module.exports = {
      ABV: ABV,
      CONSTR: CONSTR,
      TYPED: TYPED,
      VIEW: VIEW
    }
  /** */ },
/* 76 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var inherits = __webpack_require__(3),
        EventEmitter = __webpack_require__(17).EventEmitter

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:receiver:xhr')
      }

      function XhrReceiver (url, AjaxObject) {
        debug(url)
        EventEmitter.call(this)
        var self = this

        this.bufferPosition = 0

        this.xo = new AjaxObject('POST', url, null)
        this.xo.on('chunk', this._chunkHandler.bind(this))
        this.xo.once('finish', function (status, text) {
          debug('finish', status, text)
          self._chunkHandler(status, text)
          self.xo = null
          var reason = status === 200 ? 'network' : 'permanent'
          debug('close', reason)
          self.emit('close', null, reason)
          self._cleanup()
        })
      }

      inherits(XhrReceiver, EventEmitter)

      XhrReceiver.prototype._chunkHandler = function (status, text) {
        debug('_chunkHandler', status)
        if (status !== 200 || !text) {
          return
        }

        for (var idx = -1; ; this.bufferPosition += idx + 1) {
          var buf = text.slice(this.bufferPosition)
          idx = buf.indexOf('\n')
          if (idx === -1) {
            break
          }
          var msg = buf.slice(0, idx)
          if (msg) {
            debug('message', msg)
            this.emit('message', msg)
          }
        }
      }

      XhrReceiver.prototype._cleanup = function () {
        debug('_cleanup')
        this.removeAllListeners()
      }

      XhrReceiver.prototype.abort = function () {
        debug('abort')
        if (this.xo) {
          this.xo.close()
          debug('close')
          this.emit('close', null, 'user')
          this.xo = null
        }
        this._cleanup()
      }

      module.exports = XhrReceiver
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 77 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      XhrDriver = __webpack_require__(161)

    function XHRCorsObject (method, url, payload, opts) {
      XhrDriver.call(this, method, url, payload, opts)
    }

    inherits(XHRCorsObject, XhrDriver)

    XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS

    module.exports = XHRCorsObject
  /** */ },
/* 78 */
  /** */ function (module, exports, __webpack_require__) {
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

    var getName = __webpack_require__(115)
    var getProperties = __webpack_require__(200)
    var getEnumerableProperties = __webpack_require__(197)

    module.exports = inspect

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
    function inspect (obj, showHidden, depth, colors) {
      var ctx = {
        showHidden: showHidden,
        seen: [],
        stylize: function (str) { return str }
      }
      return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth))
    }

// Returns true if object is a DOM element.
    var isDOMElement = function (object) {
      if (typeof HTMLElement === 'object') {
        return object instanceof HTMLElement
      } else {
        return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string'
      }
    }

    function formatValue (ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes)
        if (typeof ret !== 'string') {
          ret = formatValue(ctx, ret, recurseTimes)
        }
        return ret
      }

  // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value)
      if (primitive) {
        return primitive
      }

  // If this is a DOM element, try to get the outer HTML.
      if (isDOMElement(value)) {
        if ('outerHTML' in value) {
          return value.outerHTML
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
        } else {
      // Attempt to serialize it
          try {
            if (document.xmlVersion) {
              var xmlSerializer = new XMLSerializer()
              return xmlSerializer.serializeToString(value)
            } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
              var ns = 'http://www.w3.org/1999/xhtml'
              var container = document.createElementNS(ns, '_')

              container.appendChild(value.cloneNode(false))
              html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<')
              container.innerHTML = ''
              return html
            }
          } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
          }
        }
      }

  // Look up the keys of the object.
      var visibleKeys = getEnumerableProperties(value)
      var keys = ctx.showHidden ? getProperties(value) : visibleKeys

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
      if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
        if (typeof value === 'function') {
          var name = getName(value)
          var nameSuffix = name ? ': ' + name : ''
          return ctx.stylize('[Function' + nameSuffix + ']', 'special')
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp')
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toUTCString.call(value), 'date')
        }
        if (isError(value)) {
          return formatError(value)
        }
      }

      var base = '', array = false, braces = ['{', '}']

  // Make Array say that they are Array
      if (isArray(value)) {
        array = true
        braces = ['[', ']']
      }

  // Make functions say that they are functions
      if (typeof value === 'function') {
        var name = getName(value)
        var nameSuffix = name ? ': ' + name : ''
        base = ' [Function' + nameSuffix + ']'
      }

  // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value)
      }

  // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value)
      }

  // Make error with message first say the error
      if (isError(value)) {
        return formatError(value)
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1]
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp')
        } else {
          return ctx.stylize('[Object]', 'special')
        }
      }

      ctx.seen.push(value)

      var output
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
        })
      }

      ctx.seen.pop()

      return reduceToSingleString(output, base, braces)
    }

    function formatPrimitive (ctx, value) {
      switch (typeof value) {
        case 'undefined':
          return ctx.stylize('undefined', 'undefined')

        case 'string':
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\''
          return ctx.stylize(simple, 'string')

        case 'number':
          if (value === 0 && (1 / value) === -Infinity) {
            return ctx.stylize('-0', 'number')
          }
          return ctx.stylize('' + value, 'number')

        case 'boolean':
          return ctx.stylize('' + value, 'boolean')
      }
  // For some reason typeof null is "object", so special case here.
      if (value === null) {
        return ctx.stylize('null', 'null')
      }
    }

    function formatError (value) {
      return '[' + Error.prototype.toString.call(value) + ']'
    }

    function formatArray (ctx, value, recurseTimes, visibleKeys, keys) {
      var output = []
      for (var i = 0, l = value.length; i < l; ++i) {
        if (Object.prototype.hasOwnProperty.call(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true))
        } else {
          output.push('')
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true))
        }
      })
      return output
    }

    function formatProperty (ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = ctx.stylize('[Getter/Setter]', 'special')
          } else {
            str = ctx.stylize('[Getter]', 'special')
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = ctx.stylize('[Setter]', 'special')
          }
        }
      }
      if (visibleKeys.indexOf(key) < 0) {
        name = '[' + key + ']'
      }
      if (!str) {
        if (ctx.seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, value[key], null)
          } else {
            str = formatValue(ctx, value[key], recurseTimes - 1)
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line
              }).join('\n').substr(2)
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line
              }).join('\n')
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special')
        }
      }
      if (typeof name === 'undefined') {
        if (array && key.match(/^\d+$/)) {
          return str
        }
        name = JSON.stringify('' + key)
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2)
          name = ctx.stylize(name, 'name')
        } else {
          name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'")
          name = ctx.stylize(name, 'string')
        }
      }

      return name + ': ' + str
    }

    function reduceToSingleString (output, base, braces) {
      var numLinesEst = 0
      var length = output.reduce(function (prev, cur) {
        numLinesEst++
        if (cur.indexOf('\n') >= 0) numLinesEst++
        return prev + cur.length + 1
      }, 0)

      if (length > 60) {
        return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1]
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
    }

    function isArray (ar) {
      return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]')
    }

    function isRegExp (re) {
      return typeof re === 'object' && objectToString(re) === '[object RegExp]'
    }

    function isDate (d) {
      return typeof d === 'object' && objectToString(d) === '[object Date]'
    }

    function isError (e) {
      return typeof e === 'object' && objectToString(e) === '[object Error]'
    }

    function objectToString (o) {
      return Object.prototype.toString.call(o)
    }
  /** */ },
/* 79 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

    var toObject = __webpack_require__(13)
    var toAbsoluteIndex = __webpack_require__(49)
    var toLength = __webpack_require__(8)
    module.exports = function fill (value /* , start = 0, end = @length */) {
      var O = toObject(this)
      var length = toLength(O.length)
      var aLen = arguments.length
      var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length)
      var end = aLen > 2 ? arguments[2] : undefined
      var endPos = end === undefined ? length : toAbsoluteIndex(end, length)
      while (endPos > index) O[index++] = value
      return O
    }
  /** */ },
/* 80 */
  /** */ function (module, exports, __webpack_require__) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
    var speciesConstructor = __webpack_require__(206)

    module.exports = function (original, length) {
      return new (speciesConstructor(original))(length)
    }
  /** */ },
/* 81 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $defineProperty = __webpack_require__(11)
    var createDesc = __webpack_require__(39)

    module.exports = function (object, index, value) {
      if (index in object) $defineProperty.f(object, index, createDesc(0, value))
      else object[index] = value
    }
  /** */ },
/* 82 */
  /** */ function (module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4)
    var document = __webpack_require__(2).document
// typeof document.createElement is 'object' in old IE
    var is = isObject(document) && isObject(document.createElement)
    module.exports = function (it) {
      return is ? document.createElement(it) : {}
    }
  /** */ },
/* 83 */
  /** */ function (module, exports) {
// IE 8- don't enum bug keys
    module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',')
  /** */ },
/* 84 */
  /** */ function (module, exports, __webpack_require__) {
    var MATCH = __webpack_require__(9)('match')
    module.exports = function (KEY) {
      var re = /./
      try {
        '/./'[KEY](re)
      } catch (e) {
        try {
          re[MATCH] = false
          return !'/./'[KEY](re)
        } catch (f) { /* empty */ }
      } return true
    }
  /** */ },
/* 85 */
  /** */ function (module, exports, __webpack_require__) {
    var document = __webpack_require__(2).document
    module.exports = document && document.documentElement
  /** */ },
/* 86 */
  /** */ function (module, exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
    module.exports = function (fn, args, that) {
      var un = that === undefined
      switch (args.length) {
        case 0: return un ? fn()
                      : fn.call(that)
        case 1: return un ? fn(args[0])
                      : fn.call(that, args[0])
        case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1])
        case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2])
        case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3])
      } return fn.apply(that, args)
    }
  /** */ },
/* 87 */
  /** */ function (module, exports, __webpack_require__) {
// check on default Array iterator
    var Iterators = __webpack_require__(45)
    var ITERATOR = __webpack_require__(9)('iterator')
    var ArrayProto = Array.prototype

    module.exports = function (it) {
      return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it)
    }
  /** */ },
/* 88 */
  /** */ function (module, exports, __webpack_require__) {
    var ITERATOR = __webpack_require__(9)('iterator')
    var SAFE_CLOSING = false

    try {
      var riter = [7][ITERATOR]()
      riter['return'] = function () { SAFE_CLOSING = true }
  // eslint-disable-next-line no-throw-literal
      Array.from(riter, function () { throw 2 })
    } catch (e) { /* empty */ }

    module.exports = function (exec, skipClosing) {
      if (!skipClosing && !SAFE_CLOSING) return false
      var safe = false
      try {
        var arr = [7]
        var iter = arr[ITERATOR]()
        iter.next = function () { return { done: safe = true } }
        arr[ITERATOR] = function () { return iter }
        exec(arr)
      } catch (e) { /* empty */ }
      return safe
    }
  /** */ },
/* 89 */
  /** */ function (module, exports) {
    module.exports = function (done, value) {
      return { value: value, done: !!done }
    }
  /** */ },
/* 90 */
  /** */ function (module, exports) {
// 20.2.2.14 Math.expm1(x)
    var $expm1 = Math.expm1
    module.exports = (!$expm1 ||
  // Old FF bug
  $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 ||
  // Tor Browser bug
  $expm1(-2e-17) != -2e-17
) ? function expm1 (x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1
} : $expm1
  /** */ },
/* 91 */
  /** */ function (module, exports) {
// 20.2.2.28 Math.sign(x)
    module.exports = Math.sign || function sign (x) {
  // eslint-disable-next-line no-self-compare
      return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1
    }
  /** */ },
/* 92 */
  /** */ function (module, exports, __webpack_require__) {
    var global = __webpack_require__(2)
    var macrotask = __webpack_require__(103).set
    var Observer = global.MutationObserver || global.WebKitMutationObserver
    var process = global.process
    var Promise = global.Promise
    var isNode = __webpack_require__(27)(process) == 'process'

    module.exports = function () {
      var head, last, notify

      var flush = function () {
        var parent, fn
        if (isNode && (parent = process.domain)) parent.exit()
        while (head) {
          fn = head.fn
          head = head.next
          try {
            fn()
          } catch (e) {
            if (head) notify()
            else last = undefined
            throw e
          }
        } last = undefined
        if (parent) parent.enter()
      }

  // Node.js
      if (isNode) {
        notify = function () {
          process.nextTick(flush)
        }
  // browsers with MutationObserver
      } else if (Observer) {
        var toggle = true
        var node = document.createTextNode('')
        new Observer(flush).observe(node, { characterData: true }) // eslint-disable-line no-new
        notify = function () {
          node.data = toggle = !toggle
        }
  // environments with maybe non-completely correct, but existent Promise
      } else if (Promise && Promise.resolve) {
        var promise = Promise.resolve()
        notify = function () {
          promise.then(flush)
        }
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
      } else {
        notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
          macrotask.call(global, flush)
        }
      }

      return function (fn) {
        var task = { fn: fn, next: undefined }
        if (last) last.next = task
        if (!head) {
          head = task
          notify()
        } last = task
      }
    }
  /** */ },
/* 93 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 25.4.1.5 NewPromiseCapability(C)
    var aFunction = __webpack_require__(14)

    function PromiseCapability (C) {
      var resolve, reject
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor')
        resolve = $$resolve
        reject = $$reject
      })
      this.resolve = aFunction(resolve)
      this.reject = aFunction(reject)
    }

    module.exports.f = function (C) {
      return new PromiseCapability(C)
    }
  /** */ },
/* 94 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 19.1.2.1 Object.assign(target, source, ...)
    var getKeys = __webpack_require__(38)
    var gOPS = __webpack_require__(70)
    var pIE = __webpack_require__(58)
    var toObject = __webpack_require__(13)
    var IObject = __webpack_require__(56)
    var $assign = Object.assign

// should work with symbols and should have deterministic property order (V8 bug)
    module.exports = !$assign || __webpack_require__(5)(function () {
      var A = {}
      var B = {}
  // eslint-disable-next-line no-undef
      var S = Symbol()
      var K = 'abcdefghijklmnopqrst'
      A[S] = 7
      K.split('').forEach(function (k) { B[k] = k })
      return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K
    }) ? function assign (target, source) { // eslint-disable-line no-unused-vars
      var T = toObject(target)
      var aLen = arguments.length
      var index = 1
      var getSymbols = gOPS.f
      var isEnum = pIE.f
      while (aLen > index) {
        var S = IObject(arguments[index++])
        var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
        var length = keys.length
        var j = 0
        var key
        while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]
      } return T
    } : $assign
  /** */ },
/* 95 */
  /** */ function (module, exports, __webpack_require__) {
// all object keys, includes non-enumerable and symbols
    var gOPN = __webpack_require__(57)
    var gOPS = __webpack_require__(70)
    var anObject = __webpack_require__(1)
    var Reflect = __webpack_require__(2).Reflect
    module.exports = Reflect && Reflect.ownKeys || function ownKeys (it) {
      var keys = gOPN.f(anObject(it))
      var getSymbols = gOPS.f
      return getSymbols ? keys.concat(getSymbols(it)) : keys
    }
  /** */ },
/* 96 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(22)
  /** */ },
/* 97 */
  /** */ function (module, exports) {
    module.exports = function (regExp, replace) {
      var replacer = replace === Object(replace) ? function (part) {
        return replace[part]
      } : replace
      return function (it) {
        return String(it).replace(regExp, replacer)
      }
    }
  /** */ },
/* 98 */
  /** */ function (module, exports, __webpack_require__) {
    var shared = __webpack_require__(73)('keys')
    var uid = __webpack_require__(52)
    module.exports = function (key) {
      return shared[key] || (shared[key] = uid(key))
    }
  /** */ },
/* 99 */
  /** */ function (module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(29)
    var defined = __webpack_require__(30)
// true  -> String#at
// false -> String#codePointAt
    module.exports = function (TO_STRING) {
      return function (that, pos) {
        var s = String(defined(that))
        var i = toInteger(pos)
        var l = s.length
        var a, b
        if (i < 0 || i >= l) return TO_STRING ? '' : undefined
        a = s.charCodeAt(i)
        return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000
      }
    }
  /** */ },
/* 100 */
  /** */ function (module, exports, __webpack_require__) {
// helper for String#{startsWith, endsWith, includes}
    var isRegExp = __webpack_require__(132)
    var defined = __webpack_require__(30)

    module.exports = function (that, searchString, NAME) {
      if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!")
      return String(defined(that))
    }
  /** */ },
/* 101 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var toInteger = __webpack_require__(29)
    var defined = __webpack_require__(30)

    module.exports = function repeat (count) {
      var str = String(defined(this))
      var res = ''
      var n = toInteger(count)
      if (n < 0 || n == Infinity) throw RangeError("Count can't be negative")
      for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str
      return res
    }
  /** */ },
/* 102 */
  /** */ function (module, exports) {
    module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'
  /** */ },
/* 103 */
  /** */ function (module, exports, __webpack_require__) {
    var ctx = __webpack_require__(20)
    var invoke = __webpack_require__(86)
    var html = __webpack_require__(85)
    var cel = __webpack_require__(82)
    var global = __webpack_require__(2)
    var process = global.process
    var setTask = global.setImmediate
    var clearTask = global.clearImmediate
    var MessageChannel = global.MessageChannel
    var Dispatch = global.Dispatch
    var counter = 0
    var queue = {}
    var ONREADYSTATECHANGE = 'onreadystatechange'
    var defer, channel, port
    var run = function () {
      var id = +this
  // eslint-disable-next-line no-prototype-builtins
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id]
        delete queue[id]
        fn()
      }
    }
    var listener = function (event) {
      run.call(event.data)
    }
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
    if (!setTask || !clearTask) {
      setTask = function setImmediate (fn) {
        var args = []
        var i = 1
        while (arguments.length > i) args.push(arguments[i++])
        queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
          invoke(typeof fn === 'function' ? fn : Function(fn), args)
        }
        defer(counter)
        return counter
      }
      clearTask = function clearImmediate (id) {
        delete queue[id]
      }
  // Node.js 0.8-
      if (__webpack_require__(27)(process) == 'process') {
        defer = function (id) {
          process.nextTick(ctx(run, id, 1))
        }
  // Sphere (JS game engine) Dispatch API
      } else if (Dispatch && Dispatch.now) {
        defer = function (id) {
          Dispatch.now(ctx(run, id, 1))
        }
  // Browsers with MessageChannel, includes WebWorkers
      } else if (MessageChannel) {
        channel = new MessageChannel()
        port = channel.port2
        channel.port1.onmessage = listener
        defer = ctx(port.postMessage, port, 1)
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
      } else if (global.addEventListener && typeof postMessage === 'function' && !global.importScripts) {
        defer = function (id) {
          global.postMessage(id + '', '*')
        }
        global.addEventListener('message', listener, false)
  // IE8-
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function (id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this)
            run.call(id)
          }
        }
  // Rest old browsers
      } else {
        defer = function (id) {
          setTimeout(ctx(run, id, 1), 0)
        }
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    }
  /** */ },
/* 104 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var global = __webpack_require__(2)
    var DESCRIPTORS = __webpack_require__(12)
    var LIBRARY = __webpack_require__(46)
    var $typed = __webpack_require__(75)
    var hide = __webpack_require__(22)
    var redefineAll = __webpack_require__(47)
    var fails = __webpack_require__(5)
    var anInstance = __webpack_require__(43)
    var toInteger = __webpack_require__(29)
    var toLength = __webpack_require__(8)
    var toIndex = __webpack_require__(150)
    var gOPN = __webpack_require__(57).f
    var dP = __webpack_require__(11).f
    var arrayFill = __webpack_require__(79)
    var setToStringTag = __webpack_require__(51)
    var ARRAY_BUFFER = 'ArrayBuffer'
    var DATA_VIEW = 'DataView'
    var PROTOTYPE = 'prototype'
    var WRONG_LENGTH = 'Wrong length!'
    var WRONG_INDEX = 'Wrong index!'
    var $ArrayBuffer = global[ARRAY_BUFFER]
    var $DataView = global[DATA_VIEW]
    var Math = global.Math
    var RangeError = global.RangeError
// eslint-disable-next-line no-shadow-restricted-names
    var Infinity = global.Infinity
    var BaseBuffer = $ArrayBuffer
    var abs = Math.abs
    var pow = Math.pow
    var floor = Math.floor
    var log = Math.log
    var LN2 = Math.LN2
    var BUFFER = 'buffer'
    var BYTE_LENGTH = 'byteLength'
    var BYTE_OFFSET = 'byteOffset'
    var $BUFFER = DESCRIPTORS ? '_b' : BUFFER
    var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH
    var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET

// IEEE754 conversions based on https://github.com/feross/ieee754
    function packIEEE754 (value, mLen, nBytes) {
      var buffer = Array(nBytes)
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
      var i = 0
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
      var e, m, c
      value = abs(value)
  // eslint-disable-next-line no-self-compare
      if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
        m = value != value ? 1 : 0
        e = eMax
      } else {
        e = floor(log(value) / LN2)
        if (value * (c = pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen)
          e = e + eBias
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen)
          e = 0
        }
      }
      for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
      e = e << mLen | m
      eLen += mLen
      for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
      buffer[--i] |= s * 128
      return buffer
    }
    function unpackIEEE754 (buffer, mLen, nBytes) {
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = eLen - 7
      var i = nBytes - 1
      var s = buffer[i--]
      var e = s & 127
      var m
      s >>= 7
      for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
      m = e & (1 << -nBits) - 1
      e >>= -nBits
      nBits += mLen
      for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : s ? -Infinity : Infinity
      } else {
        m = m + pow(2, mLen)
        e = e - eBias
      } return (s ? -1 : 1) * m * pow(2, e - mLen)
    }

    function unpackI32 (bytes) {
      return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0]
    }
    function packI8 (it) {
      return [it & 0xff]
    }
    function packI16 (it) {
      return [it & 0xff, it >> 8 & 0xff]
    }
    function packI32 (it) {
      return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff]
    }
    function packF64 (it) {
      return packIEEE754(it, 52, 8)
    }
    function packF32 (it) {
      return packIEEE754(it, 23, 4)
    }

    function addGetter (C, key, internal) {
      dP(C[PROTOTYPE], key, { get: function () { return this[internal] } })
    }

    function get (view, bytes, index, isLittleEndian) {
      var numIndex = +index
      var intIndex = toIndex(numIndex)
      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX)
      var store = view[$BUFFER]._b
      var start = intIndex + view[$OFFSET]
      var pack = store.slice(start, start + bytes)
      return isLittleEndian ? pack : pack.reverse()
    }
    function set (view, bytes, index, conversion, value, isLittleEndian) {
      var numIndex = +index
      var intIndex = toIndex(numIndex)
      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX)
      var store = view[$BUFFER]._b
      var start = intIndex + view[$OFFSET]
      var pack = conversion(+value)
      for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]
    }

    if (!$typed.ABV) {
      $ArrayBuffer = function ArrayBuffer (length) {
        anInstance(this, $ArrayBuffer, ARRAY_BUFFER)
        var byteLength = toIndex(length)
        this._b = arrayFill.call(Array(byteLength), 0)
        this[$LENGTH] = byteLength
      }

      $DataView = function DataView (buffer, byteOffset, byteLength) {
        anInstance(this, $DataView, DATA_VIEW)
        anInstance(buffer, $ArrayBuffer, DATA_VIEW)
        var bufferLength = buffer[$LENGTH]
        var offset = toInteger(byteOffset)
        if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!')
        byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength)
        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH)
        this[$BUFFER] = buffer
        this[$OFFSET] = offset
        this[$LENGTH] = byteLength
      }

      if (DESCRIPTORS) {
        addGetter($ArrayBuffer, BYTE_LENGTH, '_l')
        addGetter($DataView, BUFFER, '_b')
        addGetter($DataView, BYTE_LENGTH, '_l')
        addGetter($DataView, BYTE_OFFSET, '_o')
      }

      redefineAll($DataView[PROTOTYPE], {
        getInt8: function getInt8 (byteOffset) {
          return get(this, 1, byteOffset)[0] << 24 >> 24
        },
        getUint8: function getUint8 (byteOffset) {
          return get(this, 1, byteOffset)[0]
        },
        getInt16: function getInt16 (byteOffset /* , littleEndian */) {
          var bytes = get(this, 2, byteOffset, arguments[1])
          return (bytes[1] << 8 | bytes[0]) << 16 >> 16
        },
        getUint16: function getUint16 (byteOffset /* , littleEndian */) {
          var bytes = get(this, 2, byteOffset, arguments[1])
          return bytes[1] << 8 | bytes[0]
        },
        getInt32: function getInt32 (byteOffset /* , littleEndian */) {
          return unpackI32(get(this, 4, byteOffset, arguments[1]))
        },
        getUint32: function getUint32 (byteOffset /* , littleEndian */) {
          return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0
        },
        getFloat32: function getFloat32 (byteOffset /* , littleEndian */) {
          return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4)
        },
        getFloat64: function getFloat64 (byteOffset /* , littleEndian */) {
          return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8)
        },
        setInt8: function setInt8 (byteOffset, value) {
          set(this, 1, byteOffset, packI8, value)
        },
        setUint8: function setUint8 (byteOffset, value) {
          set(this, 1, byteOffset, packI8, value)
        },
        setInt16: function setInt16 (byteOffset, value /* , littleEndian */) {
          set(this, 2, byteOffset, packI16, value, arguments[2])
        },
        setUint16: function setUint16 (byteOffset, value /* , littleEndian */) {
          set(this, 2, byteOffset, packI16, value, arguments[2])
        },
        setInt32: function setInt32 (byteOffset, value /* , littleEndian */) {
          set(this, 4, byteOffset, packI32, value, arguments[2])
        },
        setUint32: function setUint32 (byteOffset, value /* , littleEndian */) {
          set(this, 4, byteOffset, packI32, value, arguments[2])
        },
        setFloat32: function setFloat32 (byteOffset, value /* , littleEndian */) {
          set(this, 4, byteOffset, packF32, value, arguments[2])
        },
        setFloat64: function setFloat64 (byteOffset, value /* , littleEndian */) {
          set(this, 8, byteOffset, packF64, value, arguments[2])
        }
      })
    } else {
      if (!fails(function () {
        $ArrayBuffer(1)
      }) || !fails(function () {
        new $ArrayBuffer(-1) // eslint-disable-line no-new
      }) || fails(function () {
        new $ArrayBuffer() // eslint-disable-line no-new
        new $ArrayBuffer(1.5) // eslint-disable-line no-new
        new $ArrayBuffer(NaN) // eslint-disable-line no-new
        return $ArrayBuffer.name != ARRAY_BUFFER
      })) {
        $ArrayBuffer = function ArrayBuffer (length) {
          anInstance(this, $ArrayBuffer)
          return new BaseBuffer(toIndex(length))
        }
        var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]
        for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
          if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key])
        }
        if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer
      }
  // iOS Safari 7.x bug
      var view = new $DataView(new $ArrayBuffer(2))
      var $setInt8 = $DataView[PROTOTYPE].setInt8
      view.setInt8(0, 2147483648)
      view.setInt8(1, 2147483649)
      if (view.getInt8(0) || !view.getInt8(1)) {
        redefineAll($DataView[PROTOTYPE], {
          setInt8: function setInt8 (byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24)
          },
          setUint8: function setUint8 (byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24)
          }
        }, true)
      }
    }
    setToStringTag($ArrayBuffer, ARRAY_BUFFER)
    setToStringTag($DataView, DATA_VIEW)
    hide($DataView[PROTOTYPE], $typed.VIEW, true)
    exports[ARRAY_BUFFER] = $ArrayBuffer
    exports[DATA_VIEW] = $DataView
  /** */ },
/* 105 */
  /** */ function (module, exports, __webpack_require__) {
    var global = __webpack_require__(2)
    var core = __webpack_require__(15)
    var LIBRARY = __webpack_require__(46)
    var wksExt = __webpack_require__(151)
    var defineProperty = __webpack_require__(11).f
    module.exports = function (name) {
      var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {})
      if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) })
    }
  /** */ },
/* 106 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var addToUnscopables = __webpack_require__(34)
    var step = __webpack_require__(89)
    var Iterators = __webpack_require__(45)
    var toIObject = __webpack_require__(16)

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
    module.exports = __webpack_require__(68)(Array, 'Array', function (iterated, kind) {
      this._t = toIObject(iterated) // target
      this._i = 0                   // next index
      this._k = kind                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
    }, function () {
      var O = this._t
      var kind = this._k
      var index = this._i++
      if (!O || index >= O.length) {
        this._t = undefined
        return step(1)
      }
      if (kind == 'keys') return step(0, index)
      if (kind == 'values') return step(0, O[index])
      return step(0, [index, O[index]])
    }, 'values')

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
    Iterators.Arguments = Iterators.Array

    addToUnscopables('keys')
    addToUnscopables('values')
    addToUnscopables('entries')
  /** */ },
/* 107 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    function Event (eventType) {
      this.type = eventType
    }

    Event.prototype.initEvent = function (eventType, canBubble, cancelable) {
      this.type = eventType
      this.bubbles = canBubble
      this.cancelable = cancelable
      this.timeStamp = +new Date()
      return this
    }

    Event.prototype.stopPropagation = function () {}
    Event.prototype.preventDefault = function () {}

    Event.CAPTURING_PHASE = 1
    Event.AT_TARGET = 2
    Event.BUBBLING_PHASE = 3

    module.exports = Event
  /** */ },
/* 108 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) {
      var inherits = __webpack_require__(3),
        IframeTransport = __webpack_require__(165),
        objectUtils = __webpack_require__(110)

      module.exports = function (transport) {
        function IframeWrapTransport (transUrl, baseUrl) {
          IframeTransport.call(this, transport.transportName, transUrl, baseUrl)
        }

        inherits(IframeWrapTransport, IframeTransport)

        IframeWrapTransport.enabled = function (url, info) {
          if (!global.document) {
            return false
          }

          var iframeInfo = objectUtils.extend({}, info)
          iframeInfo.sameOrigin = true
          return transport.enabled(iframeInfo) && IframeTransport.enabled()
        }

        IframeWrapTransport.transportName = 'iframe-' + transport.transportName
        IframeWrapTransport.needBody = true
        IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1 // html, javascript (2) + transport - no CORS (1)

        IframeWrapTransport.facadeTransport = transport

        return IframeWrapTransport
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 109 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process, global) {
      var EventEmitter = __webpack_require__(17).EventEmitter,
        inherits = __webpack_require__(3),
        eventUtils = __webpack_require__(41),
        browser = __webpack_require__(62),
        urlUtils = __webpack_require__(24)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:sender:xdr')
      }

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

      function XDRObject (method, url, payload) {
        debug(method, url)
        var self = this
        EventEmitter.call(this)

        setTimeout(function () {
          self._start(method, url, payload)
        }, 0)
      }

      inherits(XDRObject, EventEmitter)

      XDRObject.prototype._start = function (method, url, payload) {
        debug('_start')
        var self = this
        var xdr = new global.XDomainRequest()
  // IE caches even POSTs
        url = urlUtils.addQuery(url, 't=' + (+new Date()))

        xdr.onerror = function () {
          debug('onerror')
          self._error()
        }
        xdr.ontimeout = function () {
          debug('ontimeout')
          self._error()
        }
        xdr.onprogress = function () {
          debug('progress', xdr.responseText)
          self.emit('chunk', 200, xdr.responseText)
        }
        xdr.onload = function () {
          debug('load')
          self.emit('finish', 200, xdr.responseText)
          self._cleanup(false)
        }
        this.xdr = xdr
        this.unloadRef = eventUtils.unloadAdd(function () {
          self._cleanup(true)
        })
        try {
    // Fails with AccessDenied if port number is bogus
          this.xdr.open(method, url)
          if (this.timeout) {
            this.xdr.timeout = this.timeout
          }
          this.xdr.send(payload)
        } catch (x) {
          this._error()
        }
      }

      XDRObject.prototype._error = function () {
        this.emit('finish', 0, '')
        this._cleanup(false)
      }

      XDRObject.prototype._cleanup = function (abort) {
        debug('cleanup', abort)
        if (!this.xdr) {
          return
        }
        this.removeAllListeners()
        eventUtils.unloadDel(this.unloadRef)

        this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null
        if (abort) {
          try {
            this.xdr.abort()
          } catch (x) {
      // intentionally empty
          }
        }
        this.unloadRef = this.xdr = null
      }

      XDRObject.prototype.close = function () {
        debug('close')
        this._cleanup(true)
      }

// IE 8/9 if the request target uses the same scheme - #79
      XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain())

      module.exports = XDRObject
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7), __webpack_require__(6)))
  /** */ },
/* 110 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    module.exports = {
      isObject: function (obj) {
        var type = typeof obj
        return type === 'function' || type === 'object' && !!obj
      },

      extend: function (obj) {
        if (!this.isObject(obj)) {
          return obj
        }
        var source, prop
        for (var i = 1, length = arguments.length; i < length; i++) {
          source = arguments[i]
          for (prop in source) {
            if (Object.prototype.hasOwnProperty.call(source, prop)) {
              obj[prop] = source[prop]
            }
          }
        }
        return obj
      }
    }
  /** */ },
/* 111 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(460)
  /** */ },
/* 112 */
  /** */ function (module, exports, __webpack_require__) {
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
    var stylesInDom = {},
      memoize = function (fn) {
        var memo
        return function () {
          if (typeof memo === 'undefined') memo = fn.apply(this, arguments)
          return memo
        }
      },
      isOldIE = memoize(function () {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
        return window && document && document.all && !window.atob
      }),
      getElement = (function (fn) {
        var memo = {}
        return function (selector) {
          if (typeof memo[selector] === 'undefined') {
            memo[selector] = fn.call(this, selector)
          }
          return memo[selector]
        }
      })(function (styleTarget) {
        return document.querySelector(styleTarget)
      }),
      singletonElement = null,
      singletonCounter = 0,
      styleElementsInsertedAtTop = [],
      fixUrls = __webpack_require__(459)

    module.exports = function (list, options) {
      if (typeof DEBUG !== 'undefined' && DEBUG) {
        if (typeof document !== 'object') throw new Error('The style-loader cannot be used in a non-browser environment')
      }

      options = options || {}
      options.attrs = typeof options.attrs === 'object' ? options.attrs : {}

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
      if (typeof options.singleton === 'undefined') options.singleton = isOldIE()

	// By default, add <style> tags to the <head> element
      if (typeof options.insertInto === 'undefined') options.insertInto = 'head'

	// By default, add <style> tags to the bottom of the target
      if (typeof options.insertAt === 'undefined') options.insertAt = 'bottom'

      var styles = listToStyles(list, options)
      addStylesToDom(styles, options)

      return function update (newList) {
        var mayRemove = []
        for (var i = 0; i < styles.length; i++) {
          var item = styles[i]
          var domStyle = stylesInDom[item.id]
          domStyle.refs--
          mayRemove.push(domStyle)
        }
        if (newList) {
          var newStyles = listToStyles(newList, options)
          addStylesToDom(newStyles, options)
        }
        for (var i = 0; i < mayRemove.length; i++) {
          var domStyle = mayRemove[i]
          if (domStyle.refs === 0) {
            for (var j = 0; j < domStyle.parts.length; j++) { domStyle.parts[j]() }
            delete stylesInDom[domStyle.id]
          }
        }
      }
    }

    function addStylesToDom (styles, options) {
      for (var i = 0; i < styles.length; i++) {
        var item = styles[i]
        var domStyle = stylesInDom[item.id]
        if (domStyle) {
          domStyle.refs++
          for (var j = 0; j < domStyle.parts.length; j++) {
            domStyle.parts[j](item.parts[j])
          }
          for (; j < item.parts.length; j++) {
            domStyle.parts.push(addStyle(item.parts[j], options))
          }
        } else {
          var parts = []
          for (var j = 0; j < item.parts.length; j++) {
            parts.push(addStyle(item.parts[j], options))
          }
          stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
        }
      }
    }

    function listToStyles (list, options) {
      var styles = []
      var newStyles = {}
      for (var i = 0; i < list.length; i++) {
        var item = list[i]
        var id = options.base ? item[0] + options.base : item[0]
        var css = item[1]
        var media = item[2]
        var sourceMap = item[3]
        var part = { css: css, media: media, sourceMap: sourceMap }
        if (!newStyles[id]) { styles.push(newStyles[id] = { id: id, parts: [part] }) } else			{ newStyles[id].parts.push(part) }
      }
      return styles
    }

    function insertStyleElement (options, styleElement) {
      var styleTarget = getElement(options.insertInto)
      if (!styleTarget) {
        throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.")
      }
      var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1]
      if (options.insertAt === 'top') {
        if (!lastStyleElementInsertedAtTop) {
          styleTarget.insertBefore(styleElement, styleTarget.firstChild)
        } else if (lastStyleElementInsertedAtTop.nextSibling) {
          styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling)
        } else {
          styleTarget.appendChild(styleElement)
        }
        styleElementsInsertedAtTop.push(styleElement)
      } else if (options.insertAt === 'bottom') {
        styleTarget.appendChild(styleElement)
      } else {
        throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.")
      }
    }

    function removeStyleElement (styleElement) {
      styleElement.parentNode.removeChild(styleElement)
      var idx = styleElementsInsertedAtTop.indexOf(styleElement)
      if (idx >= 0) {
        styleElementsInsertedAtTop.splice(idx, 1)
      }
    }

    function createStyleElement (options) {
      var styleElement = document.createElement('style')
      options.attrs.type = 'text/css'

      attachTagAttrs(styleElement, options.attrs)
      insertStyleElement(options, styleElement)
      return styleElement
    }

    function createLinkElement (options) {
      var linkElement = document.createElement('link')
      options.attrs.type = 'text/css'
      options.attrs.rel = 'stylesheet'

      attachTagAttrs(linkElement, options.attrs)
      insertStyleElement(options, linkElement)
      return linkElement
    }

    function attachTagAttrs (element, attrs) {
      Object.keys(attrs).forEach(function (key) {
        element.setAttribute(key, attrs[key])
      })
    }

    function addStyle (obj, options) {
      var styleElement, update, remove, transformResult

	// If a transform function was defined, run it on the css
      if (options.transform && obj.css) {
	    transformResult = options.transform(obj.css)

	    if (transformResult) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = transformResult
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function () {
	    		// noop
	    	}
	    }
      }

      if (options.singleton) {
        var styleIndex = singletonCounter++
        styleElement = singletonElement || (singletonElement = createStyleElement(options))
        update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
        remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
      } else if (obj.sourceMap &&
		typeof URL === 'function' &&
		typeof URL.createObjectURL === 'function' &&
		typeof URL.revokeObjectURL === 'function' &&
		typeof Blob === 'function' &&
		typeof btoa === 'function') {
        styleElement = createLinkElement(options)
        update = updateLink.bind(null, styleElement, options)
        remove = function () {
          removeStyleElement(styleElement)
          if (styleElement.href) { URL.revokeObjectURL(styleElement.href) }
        }
      } else {
        styleElement = createStyleElement(options)
        update = applyToTag.bind(null, styleElement)
        remove = function () {
          removeStyleElement(styleElement)
        }
      }

      update(obj)

      return function updateStyle (newObj) {
        if (newObj) {
          if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) { return }
          update(obj = newObj)
        } else {
          remove()
        }
      }
    }

    var replaceText = (function () {
      var textStore = []

      return function (index, replacement) {
        textStore[index] = replacement
        return textStore.filter(Boolean).join('\n')
      }
    })()

    function applyToSingletonTag (styleElement, index, remove, obj) {
      var css = remove ? '' : obj.css

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = replaceText(index, css)
      } else {
        var cssNode = document.createTextNode(css)
        var childNodes = styleElement.childNodes
        if (childNodes[index]) styleElement.removeChild(childNodes[index])
        if (childNodes.length) {
          styleElement.insertBefore(cssNode, childNodes[index])
        } else {
          styleElement.appendChild(cssNode)
        }
      }
    }

    function applyToTag (styleElement, obj) {
      var css = obj.css
      var media = obj.media

      if (media) {
        styleElement.setAttribute('media', media)
      }

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = css
      } else {
        while (styleElement.firstChild) {
          styleElement.removeChild(styleElement.firstChild)
        }
        styleElement.appendChild(document.createTextNode(css))
      }
    }

    function updateLink (linkElement, options, obj) {
      var css = obj.css
      var sourceMap = obj.sourceMap

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
      var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap

      if (options.convertToAbsoluteUrls || autoFixUrls) {
        css = fixUrls(css)
      }

      if (sourceMap) {
		// http://stackoverflow.com/a/26603875
        css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
      }

      var blob = new Blob([css], { type: 'text/css' })

      var oldSrc = linkElement.href

      linkElement.href = URL.createObjectURL(blob)

      if (oldSrc) { URL.revokeObjectURL(oldSrc) }
    }
  /** */ },
/* 113 */
  /** */ function (module, exports) {
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

    function exclude () {
      var excludes = [].slice.call(arguments)

      function excludeProps (res, obj) {
        Object.keys(obj).forEach(function (key) {
          if (!~excludes.indexOf(key)) res[key] = obj[key]
        })
      }

      return function extendExclude () {
        var args = [].slice.call(arguments),
          i = 0,
          res = {}

        for (; i < args.length; i++) {
          excludeProps(res, args[i])
        }

        return res
      }
    };

/*!
 * Primary Exports
 */

    module.exports = AssertionError

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

    function AssertionError (message, _props, ssf) {
      var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),
        props = extend(_props || {})

  // default values
      this.message = message || 'Unspecified AssertionError'
      this.showDiff = false

  // copy from properties
      for (var key in props) {
        this[key] = props[key]
      }

  // capture stack trace
      ssf = ssf || arguments.callee
      if (ssf && Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf)
      } else {
        try {
          throw new Error()
        } catch (e) {
          this.stack = e.stack
        }
      }
    }

/*!
 * Inherit from Error.prototype
 */

    AssertionError.prototype = Object.create(Error.prototype)

/*!
 * Statically set name
 */

    AssertionError.prototype.name = 'AssertionError'

/*!
 * Ensure correct constructor
 */

    AssertionError.prototype.constructor = AssertionError

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

    AssertionError.prototype.toJSON = function (stack) {
      var extend = exclude('constructor', 'toJSON', 'stack'),
        props = extend({ name: this.name }, this)

  // include stack if exists and not turned off
      if (stack !== false && this.stack) {
        props.stack = this.stack
      }

      return props
    }
  /** */ },
/* 114 */
  /** */ function (module, exports) {
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

    module.exports = function (obj, args) {
      return args.length > 4 ? args[4] : obj._obj
    }
  /** */ },
/* 115 */
  /** */ function (module, exports) {
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 * @namespace Utils
 * @name getName
 */

    module.exports = function (func) {
      if (func.name) return func.name

      var match = /^\s?function ([^(]*)\(/.exec(func)
      return match && match[1] ? match[1] : ''
    }
  /** */ },
/* 116 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var hasProperty = __webpack_require__(117)

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

    module.exports = function getPathInfo (path, obj) {
      var parsed = parsePath(path),
        last = parsed[parsed.length - 1]

      var info = {
        parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
        name: last.p || last.i,
        value: _getPathValue(parsed, obj)
      }
      info.exists = hasProperty(info.name, info.parent)

      return info
    }

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

    function parsePath (path) {
      var str = path.replace(/([^\\])\[/g, '$1.['),
        parts = str.match(/(\\\.|[^.]+?)+/g)
      return parts.map(function (value) {
        var re = /^\[(\d+)\]$/,
          mArr = re.exec(value)
        if (mArr) return { i: parseFloat(mArr[1]) }
        else return { p: value.replace(/\\([.\[\]])/g, '$1') }
      })
    }

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

    function _getPathValue (parsed, obj, index) {
      var tmp = obj,
        res

      index = (index === undefined ? parsed.length : index)

      for (var i = 0, l = index; i < l; i++) {
        var part = parsed[i]
        if (tmp) {
          if (typeof part.p !== 'undefined') { tmp = tmp[part.p] } else if (typeof part.i !== 'undefined') { tmp = tmp[part.i] }
          if (i == (l - 1)) res = tmp
        } else {
          res = undefined
        }
      }
      return res
    }
  /** */ },
/* 117 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var type = __webpack_require__(111)

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

    var literals = {
      'number': Number,
      'string': String
    }

    module.exports = function hasProperty (name, obj) {
      var ot = type(obj)

  // Bad Object, obviously no props at all
      if (ot === 'null' || ot === 'undefined') { return false }

  // The `in` operator does not work with certain literals
  // box these before the check
      if (literals[ot] && typeof obj !== 'object') { obj = new literals[ot](obj) }

      return name in obj
    }
  /** */ },
/* 118 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

    var inspect = __webpack_require__(78)
    var config = __webpack_require__(50)

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

    module.exports = function (obj) {
      var str = inspect(obj),
        type = Object.prototype.toString.call(obj)

      if (config.truncateThreshold && str.length >= config.truncateThreshold) {
        if (type === '[object Function]') {
          return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']'
        } else if (type === '[object Array]') {
          return '[ Array(' + obj.length + ') ]'
        } else if (type === '[object Object]') {
          var keys = Object.keys(obj),
            kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ')
          return '{ Object (' + kstr + ') }'
        } else {
          return str
        }
      } else {
        return str
      }
    }
  /** */ },
/* 119 */
  /** */ function (module, exports) {
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

    module.exports = function (assertion, object, includeAll) {
      var flags = assertion.__flags || (assertion.__flags = Object.create(null))

      if (!object.__flags) {
        object.__flags = Object.create(null)
      }

      includeAll = arguments.length === 3 ? includeAll : true

      for (var flag in flags) {
        if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
          object.__flags[flag] = flags[flag]
        }
      }
    }
  /** */ },
/* 120 */
  /** */ function (module, exports, __webpack_require__) {
    var cof = __webpack_require__(27)
    module.exports = function (it, msg) {
      if (typeof it !== 'number' && cof(it) != 'Number') throw TypeError(msg)
      return +it
    }
  /** */ },
/* 121 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

    var toObject = __webpack_require__(13)
    var toAbsoluteIndex = __webpack_require__(49)
    var toLength = __webpack_require__(8)

    module.exports = [].copyWithin || function copyWithin (target /* = 0 */, start /* = 0, end = @length */) {
      var O = toObject(this)
      var len = toLength(O.length)
      var to = toAbsoluteIndex(target, len)
      var from = toAbsoluteIndex(start, len)
      var end = arguments.length > 2 ? arguments[2] : undefined
      var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to)
      var inc = 1
      if (from < to && to < from + count) {
        inc = -1
        from += count - 1
        to += count - 1
      }
      while (count-- > 0) {
        if (from in O) O[to] = O[from]
        else delete O[to]
        to += inc
        from += inc
      } return O
    }
  /** */ },
/* 122 */
  /** */ function (module, exports, __webpack_require__) {
    var forOf = __webpack_require__(35)

    module.exports = function (iter, ITERATOR) {
      var result = []
      forOf(iter, false, result.push, result, ITERATOR)
      return result
    }
  /** */ },
/* 123 */
  /** */ function (module, exports, __webpack_require__) {
    var aFunction = __webpack_require__(14)
    var toObject = __webpack_require__(13)
    var IObject = __webpack_require__(56)
    var toLength = __webpack_require__(8)

    module.exports = function (that, callbackfn, aLen, memo, isRight) {
      aFunction(callbackfn)
      var O = toObject(that)
      var self = IObject(O)
      var length = toLength(O.length)
      var index = isRight ? length - 1 : 0
      var i = isRight ? -1 : 1
      if (aLen < 2) {
        for (;;) {
          if (index in self) {
            memo = self[index]
            index += i
            break
          }
          index += i
          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value')
          }
        }
      }
      for (;isRight ? index >= 0 : length > index; index += i) {
        if (index in self) {
          memo = callbackfn(memo, self[index], index, O)
        }
      }
      return memo
    }
  /** */ },
/* 124 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var aFunction = __webpack_require__(14)
    var isObject = __webpack_require__(4)
    var invoke = __webpack_require__(86)
    var arraySlice = [].slice
    var factories = {}

    var construct = function (F, len, args) {
      if (!(len in factories)) {
        for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'
    // eslint-disable-next-line no-new-func
        factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')')
      } return factories[len](F, args)
    }

    module.exports = Function.bind || function bind (that /* , ...args */) {
      var fn = aFunction(this)
      var partArgs = arraySlice.call(arguments, 1)
      var bound = function (/* args... */) {
        var args = partArgs.concat(arraySlice.call(arguments))
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that)
      }
      if (isObject(fn.prototype)) bound.prototype = fn.prototype
      return bound
    }
  /** */ },
/* 125 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var dP = __webpack_require__(11).f
    var create = __webpack_require__(37)
    var redefineAll = __webpack_require__(47)
    var ctx = __webpack_require__(20)
    var anInstance = __webpack_require__(43)
    var forOf = __webpack_require__(35)
    var $iterDefine = __webpack_require__(68)
    var step = __webpack_require__(89)
    var setSpecies = __webpack_require__(48)
    var DESCRIPTORS = __webpack_require__(12)
    var fastKey = __webpack_require__(36).fastKey
    var validate = __webpack_require__(53)
    var SIZE = DESCRIPTORS ? '_s' : 'size'

    var getEntry = function (that, key) {
  // fast case
      var index = fastKey(key)
      var entry
      if (index !== 'F') return that._i[index]
  // frozen object case
      for (entry = that._f; entry; entry = entry.n) {
        if (entry.k == key) return entry
      }
    }

    module.exports = {
      getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function (that, iterable) {
          anInstance(that, C, NAME, '_i')
          that._t = NAME         // collection type
          that._i = create(null) // index
          that._f = undefined    // first entry
          that._l = undefined    // last entry
          that[SIZE] = 0         // size
          if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that)
        })
        redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
          clear: function clear () {
            for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
              entry.r = true
              if (entry.p) entry.p = entry.p.n = undefined
              delete data[entry.i]
            }
            that._f = that._l = undefined
            that[SIZE] = 0
          },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
          'delete': function (key) {
            var that = validate(this, NAME)
            var entry = getEntry(that, key)
            if (entry) {
              var next = entry.n
              var prev = entry.p
              delete that._i[entry.i]
              entry.r = true
              if (prev) prev.n = next
              if (next) next.p = prev
              if (that._f == entry) that._f = next
              if (that._l == entry) that._l = prev
              that[SIZE]--
            } return !!entry
          },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
          forEach: function forEach (callbackfn /* , that = undefined */) {
            validate(this, NAME)
            var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
            var entry
            while (entry = entry ? entry.n : this._f) {
              f(entry.v, entry.k, this)
          // revert to the last existing entry
              while (entry && entry.r) entry = entry.p
            }
          },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
          has: function has (key) {
            return !!getEntry(validate(this, NAME), key)
          }
        })
        if (DESCRIPTORS) {
          dP(C.prototype, 'size', {
            get: function () {
              return validate(this, NAME)[SIZE]
            }
          })
        }
        return C
      },
      def: function (that, key, value) {
        var entry = getEntry(that, key)
        var prev, index
    // change existing entry
        if (entry) {
          entry.v = value
    // create new entry
        } else {
          that._l = entry = {
            i: index = fastKey(key, true), // <- index
            k: key,                        // <- key
            v: value,                      // <- value
            p: prev = that._l,             // <- previous entry
            n: undefined,                  // <- next entry
            r: false                       // <- removed
          }
          if (!that._f) that._f = entry
          if (prev) prev.n = entry
          that[SIZE]++
      // add to index
          if (index !== 'F') that._i[index] = entry
        } return that
      },
      getEntry: getEntry,
      setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
        $iterDefine(C, NAME, function (iterated, kind) {
          this._t = validate(iterated, NAME) // target
          this._k = kind                     // kind
          this._l = undefined                // previous
        }, function () {
          var that = this
          var kind = that._k
          var entry = that._l
      // revert to the last existing entry
          while (entry && entry.r) entry = entry.p
      // get next entry
          if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
            that._t = undefined
            return step(1)
          }
      // return step by kind
          if (kind == 'keys') return step(0, entry.k)
          if (kind == 'values') return step(0, entry.v)
          return step(0, [entry.k, entry.v])
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true)

    // add [@@species], 23.1.2.2, 23.2.2.2
        setSpecies(NAME)
      }
    }
  /** */ },
/* 126 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
    var classof = __webpack_require__(44)
    var from = __webpack_require__(122)
    module.exports = function (NAME) {
      return function toJSON () {
        if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic")
        return from(this)
      }
    }
  /** */ },
/* 127 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var redefineAll = __webpack_require__(47)
    var getWeak = __webpack_require__(36).getWeak
    var anObject = __webpack_require__(1)
    var isObject = __webpack_require__(4)
    var anInstance = __webpack_require__(43)
    var forOf = __webpack_require__(35)
    var createArrayMethod = __webpack_require__(25)
    var $has = __webpack_require__(21)
    var validate = __webpack_require__(53)
    var arrayFind = createArrayMethod(5)
    var arrayFindIndex = createArrayMethod(6)
    var id = 0

// fallback for uncaught frozen keys
    var uncaughtFrozenStore = function (that) {
      return that._l || (that._l = new UncaughtFrozenStore())
    }
    var UncaughtFrozenStore = function () {
      this.a = []
    }
    var findUncaughtFrozen = function (store, key) {
      return arrayFind(store.a, function (it) {
        return it[0] === key
      })
    }
    UncaughtFrozenStore.prototype = {
      get: function (key) {
        var entry = findUncaughtFrozen(this, key)
        if (entry) return entry[1]
      },
      has: function (key) {
        return !!findUncaughtFrozen(this, key)
      },
      set: function (key, value) {
        var entry = findUncaughtFrozen(this, key)
        if (entry) entry[1] = value
        else this.a.push([key, value])
      },
      'delete': function (key) {
        var index = arrayFindIndex(this.a, function (it) {
          return it[0] === key
        })
        if (~index) this.a.splice(index, 1)
        return !!~index
      }
    }

    module.exports = {
      getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function (that, iterable) {
          anInstance(that, C, NAME, '_i')
          that._t = NAME      // collection type
          that._i = id++      // collection id
          that._l = undefined // leak store for uncaught frozen objects
          if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that)
        })
        redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
          'delete': function (key) {
            if (!isObject(key)) return false
            var data = getWeak(key)
            if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key)
            return data && $has(data, this._i) && delete data[this._i]
          },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
          has: function has (key) {
            if (!isObject(key)) return false
            var data = getWeak(key)
            if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key)
            return data && $has(data, this._i)
          }
        })
        return C
      },
      def: function (that, key, value) {
        var data = getWeak(anObject(key), true)
        if (data === true) uncaughtFrozenStore(that).set(key, value)
        else data[that._i] = value
        return that
      },
      ufstore: uncaughtFrozenStore
    }
  /** */ },
/* 128 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
    var fails = __webpack_require__(5)
    var getTime = Date.prototype.getTime
    var $toISOString = Date.prototype.toISOString

    var lz = function (num) {
      return num > 9 ? num : '0' + num
    }

// PhantomJS / old WebKit has a broken implementations
    module.exports = (fails(function () {
      return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z'
    }) || !fails(function () {
      $toISOString.call(new Date(NaN))
    })) ? function toISOString () {
      if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value')
      var d = this
      var y = d.getUTCFullYear()
      var m = d.getUTCMilliseconds()
      var s = y < 0 ? '-' : y > 9999 ? '+' : ''
      return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z'
    } : $toISOString
  /** */ },
/* 129 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
    var isArray = __webpack_require__(66)
    var isObject = __webpack_require__(4)
    var toLength = __webpack_require__(8)
    var ctx = __webpack_require__(20)
    var IS_CONCAT_SPREADABLE = __webpack_require__(9)('isConcatSpreadable')

    function flattenIntoArray (target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start
      var sourceIndex = 0
      var mapFn = mapper ? ctx(mapper, thisArg, 3) : false
      var element, spreadable

      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]

          spreadable = false
          if (isObject(element)) {
            spreadable = element[IS_CONCAT_SPREADABLE]
            spreadable = spreadable !== undefined ? !!spreadable : isArray(element)
          }

          if (spreadable && depth > 0) {
            targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1
          } else {
            if (targetIndex >= 0x1fffffffffffff) throw TypeError()
            target[targetIndex] = element
          }

          targetIndex++
        }
        sourceIndex++
      }
      return targetIndex
    }

    module.exports = flattenIntoArray
  /** */ },
/* 130 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = !__webpack_require__(12) && !__webpack_require__(5)(function () {
      return Object.defineProperty(__webpack_require__(82)('div'), 'a', { get: function () { return 7 } }).a != 7
    })
  /** */ },
/* 131 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.3 Number.isInteger(number)
    var isObject = __webpack_require__(4)
    var floor = Math.floor
    module.exports = function isInteger (it) {
      return !isObject(it) && isFinite(it) && floor(it) === it
    }
  /** */ },
/* 132 */
  /** */ function (module, exports, __webpack_require__) {
// 7.2.8 IsRegExp(argument)
    var isObject = __webpack_require__(4)
    var cof = __webpack_require__(27)
    var MATCH = __webpack_require__(9)('match')
    module.exports = function (it) {
      var isRegExp
      return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp')
    }
  /** */ },
/* 133 */
  /** */ function (module, exports, __webpack_require__) {
// call something on iterator step with safe closing on error
    var anObject = __webpack_require__(1)
    module.exports = function (iterator, fn, value, entries) {
      try {
        return entries ? fn(anObject(value)[0], value[1]) : fn(value)
  // 7.4.6 IteratorClose(iterator, completion)
      } catch (e) {
        var ret = iterator['return']
        if (ret !== undefined) anObject(ret.call(iterator))
        throw e
      }
    }
  /** */ },
/* 134 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.16 Math.fround(x)
    var sign = __webpack_require__(91)
    var pow = Math.pow
    var EPSILON = pow(2, -52)
    var EPSILON32 = pow(2, -23)
    var MAX32 = pow(2, 127) * (2 - EPSILON32)
    var MIN32 = pow(2, -126)

    var roundTiesToEven = function (n) {
      return n + 1 / EPSILON - 1 / EPSILON
    }

    module.exports = Math.fround || function fround (x) {
      var $abs = Math.abs(x)
      var $sign = sign(x)
      var a, result
      if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32
      a = (1 + EPSILON32 / EPSILON) * $abs
      result = a - (a - $abs)
  // eslint-disable-next-line no-self-compare
      if (result > MAX32 || result != result) return $sign * Infinity
      return $sign * result
    }
  /** */ },
/* 135 */
  /** */ function (module, exports) {
// 20.2.2.20 Math.log1p(x)
    module.exports = Math.log1p || function log1p (x) {
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x)
    }
  /** */ },
/* 136 */
  /** */ function (module, exports) {
// https://rwaldron.github.io/proposal-math-extensions/
    module.exports = Math.scale || function scale (x, inLow, inHigh, outLow, outHigh) {
      if (
    arguments.length === 0 ||
      // eslint-disable-next-line no-self-compare
      x != x ||
      // eslint-disable-next-line no-self-compare
      inLow != inLow ||
      // eslint-disable-next-line no-self-compare
      inHigh != inHigh ||
      // eslint-disable-next-line no-self-compare
      outLow != outLow ||
      // eslint-disable-next-line no-self-compare
      outHigh != outHigh
  ) return NaN
      if (x === Infinity || x === -Infinity) return x
      return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow
    }
  /** */ },
/* 137 */
  /** */ function (module, exports, __webpack_require__) {
    var dP = __webpack_require__(11)
    var gOPD = __webpack_require__(23)
    var ownKeys = __webpack_require__(95)
    var toIObject = __webpack_require__(16)

    module.exports = function define (target, mixin) {
      var keys = ownKeys(toIObject(mixin))
      var length = keys.length
      var i = 0
      var key
      while (length > i) dP.f(target, key = keys[i++], gOPD.f(mixin, key))
      return target
    }
  /** */ },
/* 138 */
  /** */ function (module, exports, __webpack_require__) {
    var dP = __webpack_require__(11)
    var anObject = __webpack_require__(1)
    var getKeys = __webpack_require__(38)

    module.exports = __webpack_require__(12) ? Object.defineProperties : function defineProperties (O, Properties) {
      anObject(O)
      var keys = getKeys(Properties)
      var length = keys.length
      var i = 0
      var P
      while (length > i) dP.f(O, P = keys[i++], Properties[P])
      return O
    }
  /** */ },
/* 139 */
  /** */ function (module, exports, __webpack_require__) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
    var toIObject = __webpack_require__(16)
    var gOPN = __webpack_require__(57).f
    var toString = {}.toString

    var windowNames = typeof window === 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : []

    var getWindowNames = function (it) {
      try {
        return gOPN(it)
      } catch (e) {
        return windowNames.slice()
      }
    }

    module.exports.f = function getOwnPropertyNames (it) {
      return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it))
    }
  /** */ },
/* 140 */
  /** */ function (module, exports, __webpack_require__) {
    var has = __webpack_require__(21)
    var toIObject = __webpack_require__(16)
    var arrayIndexOf = __webpack_require__(64)(false)
    var IE_PROTO = __webpack_require__(98)('IE_PROTO')

    module.exports = function (object, names) {
      var O = toIObject(object)
      var i = 0
      var result = []
      var key
      for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key)
  // Don't enum bug & hidden keys
      while (names.length > i) {
        if (has(O, key = names[i++])) {
          ~arrayIndexOf(result, key) || result.push(key)
        }
      }
      return result
    }
  /** */ },
/* 141 */
  /** */ function (module, exports, __webpack_require__) {
    var getKeys = __webpack_require__(38)
    var toIObject = __webpack_require__(16)
    var isEnum = __webpack_require__(58).f
    module.exports = function (isEntries) {
      return function (it) {
        var O = toIObject(it)
        var keys = getKeys(O)
        var length = keys.length
        var i = 0
        var result = []
        var key
        while (length > i) {
          if (isEnum.call(O, key = keys[i++])) {
            result.push(isEntries ? [key, O[key]] : O[key])
          }
        } return result
      }
    }
  /** */ },
/* 142 */
  /** */ function (module, exports, __webpack_require__) {
    var $parseFloat = __webpack_require__(2).parseFloat
    var $trim = __webpack_require__(59).trim

    module.exports = 1 / $parseFloat(__webpack_require__(102) + '-0') !== -Infinity ? function parseFloat (str) {
      var string = $trim(String(str), 3)
      var result = $parseFloat(string)
      return result === 0 && string.charAt(0) == '-' ? -0 : result
    } : $parseFloat
  /** */ },
/* 143 */
  /** */ function (module, exports, __webpack_require__) {
    var $parseInt = __webpack_require__(2).parseInt
    var $trim = __webpack_require__(59).trim
    var ws = __webpack_require__(102)
    var hex = /^[-+]?0[xX]/

    module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt (str, radix) {
      var string = $trim(String(str), 3)
      return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10))
    } : $parseInt
  /** */ },
/* 144 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var path = __webpack_require__(145)
    var invoke = __webpack_require__(86)
    var aFunction = __webpack_require__(14)
    module.exports = function (/* ...pargs */) {
      var fn = aFunction(this)
      var length = arguments.length
      var pargs = Array(length)
      var i = 0
      var _ = path._
      var holder = false
      while (length > i) if ((pargs[i] = arguments[i++]) === _) holder = true
      return function (/* ...args */) {
        var that = this
        var aLen = arguments.length
        var j = 0
        var k = 0
        var args
        if (!holder && !aLen) return invoke(fn, pargs, that)
        args = pargs.slice()
        if (holder) for (;length > j; j++) if (args[j] === _) args[j] = arguments[k++]
        while (aLen > k) args.push(arguments[k++])
        return invoke(fn, args, that)
      }
    }
  /** */ },
/* 145 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(15)
  /** */ },
/* 146 */
  /** */ function (module, exports) {
    module.exports = function (exec) {
      try {
        return { e: false, v: exec() }
      } catch (e) {
        return { e: true, v: e }
      }
    }
  /** */ },
/* 147 */
  /** */ function (module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1)
    var isObject = __webpack_require__(4)
    var newPromiseCapability = __webpack_require__(93)

    module.exports = function (C, x) {
      anObject(C)
      if (isObject(x) && x.constructor === C) return x
      var promiseCapability = newPromiseCapability.f(C)
      var resolve = promiseCapability.resolve
      resolve(x)
      return promiseCapability.promise
    }
  /** */ },
/* 148 */
  /** */ function (module, exports, __webpack_require__) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
    var isObject = __webpack_require__(4)
    var anObject = __webpack_require__(1)
    var check = function (O, proto) {
      anObject(O)
      if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!")
    }
    module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    (function (test, buggy, set) {
      try {
        set = __webpack_require__(20)(Function.call, __webpack_require__(23).f(Object.prototype, '__proto__').set, 2)
        set(test, [])
        buggy = !(test instanceof Array)
      } catch (e) { buggy = true }
      return function setPrototypeOf (O, proto) {
        check(O, proto)
        if (buggy) O.__proto__ = proto
        else set(O, proto)
        return O
      }
    }({}, false)) : undefined),
      check: check
    }
  /** */ },
/* 149 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/tc39/proposal-string-pad-start-end
    var toLength = __webpack_require__(8)
    var repeat = __webpack_require__(101)
    var defined = __webpack_require__(30)

    module.exports = function (that, maxLength, fillString, left) {
      var S = String(defined(that))
      var stringLength = S.length
      var fillStr = fillString === undefined ? ' ' : String(fillString)
      var intMaxLength = toLength(maxLength)
      if (intMaxLength <= stringLength || fillStr == '') return S
      var fillLen = intMaxLength - stringLength
      var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length))
      if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen)
      return left ? stringFiller + S : S + stringFiller
    }
  /** */ },
/* 150 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/ecma262/#sec-toindex
    var toInteger = __webpack_require__(29)
    var toLength = __webpack_require__(8)
    module.exports = function (it) {
      if (it === undefined) return 0
      var number = toInteger(it)
      var length = toLength(number)
      if (number !== length) throw RangeError('Wrong length!')
      return length
    }
  /** */ },
/* 151 */
  /** */ function (module, exports, __webpack_require__) {
    exports.f = __webpack_require__(9)
  /** */ },
/* 152 */
  /** */ function (module, exports, __webpack_require__) {
    var classof = __webpack_require__(44)
    var ITERATOR = __webpack_require__(9)('iterator')
    var Iterators = __webpack_require__(45)
    module.exports = __webpack_require__(15).isIterable = function (it) {
      var O = Object(it)
      return O[ITERATOR] !== undefined ||
    '@@iterator' in O ||
    // eslint-disable-next-line no-prototype-builtins
    Iterators.hasOwnProperty(classof(O))
    }
  /** */ },
/* 153 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var strong = __webpack_require__(125)
    var validate = __webpack_require__(53)
    var MAP = 'Map'

// 23.1 Map Objects
    module.exports = __webpack_require__(65)(MAP, function (get) {
      return function Map () { return get(this, arguments.length > 0 ? arguments[0] : undefined) }
    }, {
  // 23.1.3.6 Map.prototype.get(key)
      get: function get (key) {
        var entry = strong.getEntry(validate(this, MAP), key)
        return entry && entry.v
      },
  // 23.1.3.9 Map.prototype.set(key, value)
      set: function set (key, value) {
        return strong.def(validate(this, MAP), key === 0 ? 0 : key, value)
      }
    }, strong, true)
  /** */ },
/* 154 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var strong = __webpack_require__(125)
    var validate = __webpack_require__(53)
    var SET = 'Set'

// 23.2 Set Objects
    module.exports = __webpack_require__(65)(SET, function (get) {
      return function Set () { return get(this, arguments.length > 0 ? arguments[0] : undefined) }
    }, {
  // 23.2.3.1 Set.prototype.add(value)
      add: function add (value) {
        return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value)
      }
    }, strong)
  /** */ },
/* 155 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var each = __webpack_require__(25)(0)
    var redefine = __webpack_require__(96)
    var meta = __webpack_require__(36)
    var assign = __webpack_require__(94)
    var weak = __webpack_require__(127)
    var isObject = __webpack_require__(4)
    var fails = __webpack_require__(5)
    var validate = __webpack_require__(53)
    var WEAK_MAP = 'WeakMap'
    var getWeak = meta.getWeak
    var isExtensible = Object.isExtensible
    var uncaughtFrozenStore = weak.ufstore
    var tmp = {}
    var InternalMap

    var wrapper = function (get) {
      return function WeakMap () {
        return get(this, arguments.length > 0 ? arguments[0] : undefined)
      }
    }

    var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get (key) {
        if (isObject(key)) {
          var data = getWeak(key)
          if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key)
          return data ? data[this._i] : undefined
        }
      },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set (key, value) {
        return weak.def(validate(this, WEAK_MAP), key, value)
      }
    }

// 23.3 WeakMap Objects
    var $WeakMap = module.exports = __webpack_require__(65)(WEAK_MAP, wrapper, methods, weak, true, true)

// IE11 WeakMap frozen keys fix
    if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7 })) {
      InternalMap = weak.getConstructor(wrapper, WEAK_MAP)
      assign(InternalMap.prototype, methods)
      meta.NEED = true
      each(['delete', 'has', 'get', 'set'], function (key) {
        var proto = $WeakMap.prototype
        var method = proto[key]
        redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
          if (isObject(a) && !isExtensible(a)) {
            if (!this._f) this._f = new InternalMap()
            var result = this._f[key](a, b)
            return key == 'set' ? this : result
      // store all the rest on native weakmap
          } return method.call(this, a, b)
        })
      })
    }
  /** */ },
/* 156 */
  /** */ function (module, exports) {
    var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]]

    var alphaIndex = {}
    var charIndex = {}

    createIndexes(alphaIndex, charIndex)

/**
 * @constructor
 */
    function Html5Entities () {}

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.prototype.decode = function (str) {
      if (!str || !str.length) {
        return ''
      }
      return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
        var chr
        if (entity.charAt(0) === '#') {
          var code = entity.charAt(1) === 'x'
                ? parseInt(entity.substr(2).toLowerCase(), 16)
                : parseInt(entity.substr(1))

          if (!(isNaN(code) || code < -32768 || code > 65535)) {
            chr = String.fromCharCode(code)
          }
        } else {
          chr = alphaIndex[entity]
        }
        return chr || s
      })
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.decode = function (str) {
      return new Html5Entities().decode(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.prototype.encode = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)]
        if (charInfo) {
          var alpha = charInfo[str.charCodeAt(i + 1)]
          if (alpha) {
            i++
          } else {
            alpha = charInfo['']
          }
          if (alpha) {
            result += '&' + alpha + ';'
            i++
            continue
          }
        }
        result += str.charAt(i)
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.encode = function (str) {
      return new Html5Entities().encode(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.prototype.encodeNonUTF = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var c = str.charCodeAt(i)
        var charInfo = charIndex[c]
        if (charInfo) {
          var alpha = charInfo[str.charCodeAt(i + 1)]
          if (alpha) {
            i++
          } else {
            alpha = charInfo['']
          }
          if (alpha) {
            result += '&' + alpha + ';'
            i++
            continue
          }
        }
        if (c < 32 || c > 126) {
          result += '&#' + c + ';'
        } else {
          result += str.charAt(i)
        }
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.encodeNonUTF = function (str) {
      return new Html5Entities().encodeNonUTF(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.prototype.encodeNonASCII = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var c = str.charCodeAt(i)
        if (c <= 255) {
          result += str[i++]
          continue
        }
        result += '&#' + c + ';'
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html5Entities.encodeNonASCII = function (str) {
      return new Html5Entities().encodeNonASCII(str)
    }

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
    function createIndexes (alphaIndex, charIndex) {
      var i = ENTITIES.length
      var _results = []
      while (i--) {
        var e = ENTITIES[i]
        var alpha = e[0]
        var chars = e[1]
        var chr = chars[0]
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39
        var charInfo
        if (addChar) {
          charInfo = charIndex[chr] = charIndex[chr] || {}
        }
        if (chars[1]) {
          var chr2 = chars[1]
          alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2)
          _results.push(addChar && (charInfo[chr2] = alpha))
        } else {
          alphaIndex[alpha] = String.fromCharCode(chr)
          _results.push(addChar && (charInfo[''] = alpha))
        }
      }
    }

    module.exports = Html5Entities
  /** */ },
/* 157 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

    function EventTarget () {
      this._listeners = {}
    }

    EventTarget.prototype.addEventListener = function (eventType, listener) {
      if (!(eventType in this._listeners)) {
        this._listeners[eventType] = []
      }
      var arr = this._listeners[eventType]
  // #4
      if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
        arr = arr.concat([listener])
      }
      this._listeners[eventType] = arr
    }

    EventTarget.prototype.removeEventListener = function (eventType, listener) {
      var arr = this._listeners[eventType]
      if (!arr) {
        return
      }
      var idx = arr.indexOf(listener)
      if (idx !== -1) {
        if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
          this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1))
        } else {
          delete this._listeners[eventType]
        }
        return
      }
    }

    EventTarget.prototype.dispatchEvent = function () {
      var event = arguments[0]
      var t = event.type
  // equivalent of Array.prototype.slice.call(arguments, 0);
      var args = arguments.length === 1 ? [event] : Array.apply(null, arguments)
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
      if (this['on' + t]) {
        this['on' + t].apply(this, args)
      }
      if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
        var listeners = this._listeners[t]
        for (var i = 0; i < listeners.length; i++) {
          listeners[i].apply(this, args)
        }
      }
    }

    module.exports = EventTarget
  /** */ },
/* 158 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var EventEmitter = __webpack_require__(17).EventEmitter,
        inherits = __webpack_require__(3),
        JSON3 = __webpack_require__(33),
        objectUtils = __webpack_require__(110)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:info-ajax')
      }

      function InfoAjax (url, AjaxObject) {
        EventEmitter.call(this)

        var self = this
        var t0 = +new Date()
        this.xo = new AjaxObject('GET', url)

        this.xo.once('finish', function (status, text) {
          var info, rtt
          if (status === 200) {
            rtt = (+new Date()) - t0
            if (text) {
              try {
                info = JSON3.parse(text)
              } catch (e) {
                debug('bad json', text)
              }
            }

            if (!objectUtils.isObject(info)) {
              info = {}
            }
          }
          self.emit('finish', info, rtt)
          self.removeAllListeners()
        })
      }

      inherits(InfoAjax, EventEmitter)

      InfoAjax.prototype.close = function () {
        this.removeAllListeners()
        this.xo.close()
      }

      module.exports = InfoAjax
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 159 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      EventEmitter = __webpack_require__(17).EventEmitter,
      JSON3 = __webpack_require__(33),
      XHRLocalObject = __webpack_require__(61),
      InfoAjax = __webpack_require__(158)

    function InfoReceiverIframe (transUrl) {
      var self = this
      EventEmitter.call(this)

      this.ir = new InfoAjax(transUrl, XHRLocalObject)
      this.ir.once('finish', function (info, rtt) {
        self.ir = null
        self.emit('message', JSON3.stringify([info, rtt]))
      })
    }

    inherits(InfoReceiverIframe, EventEmitter)

    InfoReceiverIframe.transportName = 'iframe-info-receiver'

    InfoReceiverIframe.prototype.close = function () {
      if (this.ir) {
        this.ir.close()
        this.ir = null
      }
      this.removeAllListeners()
    }

    module.exports = InfoReceiverIframe
  /** */ },
/* 160 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) {
      module.exports = global.location || {
        origin: 'http://localhost:80',
        protocol: 'http:',
        host: 'localhost',
        port: 80,
        href: 'http://localhost/',
        hash: ''
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 161 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global, process) {
      var EventEmitter = __webpack_require__(17).EventEmitter,
        inherits = __webpack_require__(3),
        utils = __webpack_require__(41),
        urlUtils = __webpack_require__(24),
        XHR = global.XMLHttpRequest

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:browser:xhr')
      }

      function AbstractXHRObject (method, url, payload, opts) {
        debug(method, url)
        var self = this
        EventEmitter.call(this)

        setTimeout(function () {
          self._start(method, url, payload, opts)
        }, 0)
      }

      inherits(AbstractXHRObject, EventEmitter)

      AbstractXHRObject.prototype._start = function (method, url, payload, opts) {
        var self = this

        try {
          this.xhr = new XHR()
        } catch (x) {
    // intentionally empty
        }

        if (!this.xhr) {
          debug('no xhr')
          this.emit('finish', 0, 'no xhr support')
          this._cleanup()
          return
        }

  // several browsers cache POSTs
        url = urlUtils.addQuery(url, 't=' + (+new Date()))

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
        this.unloadRef = utils.unloadAdd(function () {
          debug('unload cleanup')
          self._cleanup(true)
        })
        try {
          this.xhr.open(method, url, true)
          if (this.timeout && 'timeout' in this.xhr) {
            this.xhr.timeout = this.timeout
            this.xhr.ontimeout = function () {
              debug('xhr timeout')
              self.emit('finish', 0, '')
              self._cleanup(false)
            }
          }
        } catch (e) {
          debug('exception', e)
    // IE raises an exception on wrong port.
          this.emit('finish', 0, '')
          this._cleanup(false)
          return
        }

        if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
          debug('withCredentials')
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

          this.xhr.withCredentials = true
        }
        if (opts && opts.headers) {
          for (var key in opts.headers) {
            this.xhr.setRequestHeader(key, opts.headers[key])
          }
        }

        this.xhr.onreadystatechange = function () {
          if (self.xhr) {
            var x = self.xhr
            var text, status
            debug('readyState', x.readyState)
            switch (x.readyState) {
              case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
                try {
                  status = x.status
                  text = x.responseText
                } catch (e) {
          // intentionally empty
                }
                debug('status', status)
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                if (status === 1223) {
                  status = 204
                }

        // IE does return readystate == 3 for 404 answers.
                if (status === 200 && text && text.length > 0) {
                  debug('chunk')
                  self.emit('chunk', status, text)
                }
                break
              case 4:
                status = x.status
                debug('status', status)
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                if (status === 1223) {
                  status = 204
                }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
                if (status === 12005 || status === 12029) {
                  status = 0
                }

                debug('finish', status, x.responseText)
                self.emit('finish', status, x.responseText)
                self._cleanup(false)
                break
            }
          }
        }

        try {
          self.xhr.send(payload)
        } catch (e) {
          self.emit('finish', 0, '')
          self._cleanup(false)
        }
      }

      AbstractXHRObject.prototype._cleanup = function (abort) {
        debug('cleanup')
        if (!this.xhr) {
          return
        }
        this.removeAllListeners()
        utils.unloadDel(this.unloadRef)

  // IE needs this field to be a function
        this.xhr.onreadystatechange = function () {}
        if (this.xhr.ontimeout) {
          this.xhr.ontimeout = null
        }

        if (abort) {
          try {
            this.xhr.abort()
          } catch (x) {
      // intentionally empty
          }
        }
        this.unloadRef = this.xhr = null
      }

      AbstractXHRObject.prototype.close = function () {
        debug('close')
        this._cleanup(true)
      }

      AbstractXHRObject.enabled = !!XHR
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
      var axo = ['Active'].concat('Object').join('X')
      if (!AbstractXHRObject.enabled && (axo in global)) {
        debug('overriding xmlhttprequest')
        XHR = function () {
          try {
            return new global[axo]('Microsoft.XMLHTTP')
          } catch (e) {
            return null
          }
        }
        AbstractXHRObject.enabled = !!new XHR()
      }

      var cors = false
      try {
        cors = 'withCredentials' in new XHR()
      } catch (ignored) {
  // intentionally empty
      }

      AbstractXHRObject.supportsCORS = cors

      module.exports = AbstractXHRObject
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6), __webpack_require__(7)))
  /** */ },
/* 162 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (global) {
      module.exports = global.EventSource
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 163 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      AjaxBasedTransport = __webpack_require__(54),
      EventSourceReceiver = __webpack_require__(447),
      XHRCorsObject = __webpack_require__(77),
      EventSourceDriver = __webpack_require__(162)

    function EventSourceTransport (transUrl) {
      if (!EventSourceTransport.enabled()) {
        throw new Error('Transport created when disabled')
      }

      AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject)
    }

    inherits(EventSourceTransport, AjaxBasedTransport)

    EventSourceTransport.enabled = function () {
      return !!EventSourceDriver
    }

    EventSourceTransport.transportName = 'eventsource'
    EventSourceTransport.roundTrips = 2

    module.exports = EventSourceTransport
  /** */ },
/* 164 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      HtmlfileReceiver = __webpack_require__(448),
      XHRLocalObject = __webpack_require__(61),
      AjaxBasedTransport = __webpack_require__(54)

    function HtmlFileTransport (transUrl) {
      if (!HtmlfileReceiver.enabled) {
        throw new Error('Transport created when disabled')
      }
      AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject)
    }

    inherits(HtmlFileTransport, AjaxBasedTransport)

    HtmlFileTransport.enabled = function (info) {
      return HtmlfileReceiver.enabled && info.sameOrigin
    }

    HtmlFileTransport.transportName = 'htmlfile'
    HtmlFileTransport.roundTrips = 2

    module.exports = HtmlFileTransport
  /** */ },
/* 165 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

      var inherits = __webpack_require__(3),
        JSON3 = __webpack_require__(33),
        EventEmitter = __webpack_require__(17).EventEmitter,
        version = __webpack_require__(169),
        urlUtils = __webpack_require__(24),
        iframeUtils = __webpack_require__(63),
        eventUtils = __webpack_require__(41),
        random = __webpack_require__(55)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:transport:iframe')
      }

      function IframeTransport (transport, transUrl, baseUrl) {
        if (!IframeTransport.enabled()) {
          throw new Error('Transport created when disabled')
        }
        EventEmitter.call(this)

        var self = this
        this.origin = urlUtils.getOrigin(baseUrl)
        this.baseUrl = baseUrl
        this.transUrl = transUrl
        this.transport = transport
        this.windowId = random.string(8)

        var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId
        debug(transport, transUrl, iframeUrl)

        this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {
          debug('err callback')
          self.emit('close', 1006, 'Unable to load an iframe (' + r + ')')
          self.close()
        })

        this.onmessageCallback = this._message.bind(this)
        eventUtils.attachEvent('message', this.onmessageCallback)
      }

      inherits(IframeTransport, EventEmitter)

      IframeTransport.prototype.close = function () {
        debug('close')
        this.removeAllListeners()
        if (this.iframeObj) {
          eventUtils.detachEvent('message', this.onmessageCallback)
          try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
            this.postMessage('c')
          } catch (x) {
      // intentionally empty
          }
          this.iframeObj.cleanup()
          this.iframeObj = null
          this.onmessageCallback = this.iframeObj = null
        }
      }

      IframeTransport.prototype._message = function (e) {
        debug('message', e.data)
        if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
          debug('not same origin', e.origin, this.origin)
          return
        }

        var iframeMessage
        try {
          iframeMessage = JSON3.parse(e.data)
        } catch (ignored) {
          debug('bad json', e.data)
          return
        }

        if (iframeMessage.windowId !== this.windowId) {
          debug('mismatched window id', iframeMessage.windowId, this.windowId)
          return
        }

        switch (iframeMessage.type) {
          case 's':
            this.iframeObj.loaded()
    // window global dependency
            this.postMessage('s', JSON3.stringify([
              version,
              this.transport,
              this.transUrl,
              this.baseUrl
            ]))
            break
          case 't':
            this.emit('message', iframeMessage.data)
            break
          case 'c':
            var cdata
            try {
              cdata = JSON3.parse(iframeMessage.data)
            } catch (ignored) {
              debug('bad json', iframeMessage.data)
              return
            }
            this.emit('close', cdata[0], cdata[1])
            this.close()
            break
        }
      }

      IframeTransport.prototype.postMessage = function (type, data) {
        debug('postMessage', type, data)
        this.iframeObj.post(JSON3.stringify({
          windowId: this.windowId,
          type: type,
          data: data || ''
        }), this.origin)
      }

      IframeTransport.prototype.send = function (message) {
        debug('send', message)
        this.postMessage('m', message)
      }

      IframeTransport.enabled = function () {
        return iframeUtils.iframeEnabled
      }

      IframeTransport.transportName = 'iframe'
      IframeTransport.roundTrips = 2

      module.exports = IframeTransport
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 166 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var inherits = __webpack_require__(3),
        urlUtils = __webpack_require__(24),
        BufferedSender = __webpack_require__(445),
        Polling = __webpack_require__(446)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:sender-receiver')
      }

      function SenderReceiver (transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
        var pollUrl = urlUtils.addPath(transUrl, urlSuffix)
        debug(pollUrl)
        var self = this
        BufferedSender.call(this, transUrl, senderFunc)

        this.poll = new Polling(Receiver, pollUrl, AjaxObject)
        this.poll.on('message', function (msg) {
          debug('poll message', msg)
          self.emit('message', msg)
        })
        this.poll.once('close', function (code, reason) {
          debug('poll close', code, reason)
          self.poll = null
          self.emit('close', code, reason)
          self.close()
        })
      }

      inherits(SenderReceiver, BufferedSender)

      SenderReceiver.prototype.close = function () {
        BufferedSender.prototype.close.call(this)
        debug('close')
        this.removeAllListeners()
        if (this.poll) {
          this.poll.abort()
          this.poll = null
        }
      }

      module.exports = SenderReceiver
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 167 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      AjaxBasedTransport = __webpack_require__(54),
      XhrReceiver = __webpack_require__(76),
      XDRObject = __webpack_require__(109)

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

    function XdrStreamingTransport (transUrl) {
      if (!XDRObject.enabled) {
        throw new Error('Transport created when disabled')
      }
      AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject)
    }

    inherits(XdrStreamingTransport, AjaxBasedTransport)

    XdrStreamingTransport.enabled = function (info) {
      if (info.cookie_needed || info.nullOrigin) {
        return false
      }
      return XDRObject.enabled && info.sameScheme
    }

    XdrStreamingTransport.transportName = 'xdr-streaming'
    XdrStreamingTransport.roundTrips = 2 // preflight, ajax

    module.exports = XdrStreamingTransport
  /** */ },
/* 168 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      AjaxBasedTransport = __webpack_require__(54),
      XhrReceiver = __webpack_require__(76),
      XHRCorsObject = __webpack_require__(77),
      XHRLocalObject = __webpack_require__(61)

    function XhrPollingTransport (transUrl) {
      if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
        throw new Error('Transport created when disabled')
      }
      AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject)
    }

    inherits(XhrPollingTransport, AjaxBasedTransport)

    XhrPollingTransport.enabled = function (info) {
      if (info.nullOrigin) {
        return false
      }

      if (XHRLocalObject.enabled && info.sameOrigin) {
        return true
      }
      return XHRCorsObject.enabled
    }

    XhrPollingTransport.transportName = 'xhr-polling'
    XhrPollingTransport.roundTrips = 2 // preflight, ajax

    module.exports = XhrPollingTransport
  /** */ },
/* 169 */
  /** */ function (module, exports) {
    module.exports = '1.1.5'
  /** */ },
/* 170 */
  /** */ function (module, exports, __webpack_require__) {
    var apply = Function.prototype.apply

// DOM APIs, for completeness

    exports.setTimeout = function () {
      return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout)
    }
    exports.setInterval = function () {
      return new Timeout(apply.call(setInterval, window, arguments), clearInterval)
    }
    exports.clearTimeout =
exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close()
  }
}

    function Timeout (id, clearFn) {
      this._id = id
      this._clearFn = clearFn
    }
    Timeout.prototype.unref = Timeout.prototype.ref = function () {}
    Timeout.prototype.close = function () {
      this._clearFn.call(window, this._id)
    }

// Does not start the time, just sets up the members needed.
    exports.enroll = function (item, msecs) {
      clearTimeout(item._idleTimeoutId)
      item._idleTimeout = msecs
    }

    exports.unenroll = function (item) {
      clearTimeout(item._idleTimeoutId)
      item._idleTimeout = -1
    }

    exports._unrefActive = exports.active = function (item) {
      clearTimeout(item._idleTimeoutId)

      var msecs = item._idleTimeout
      if (msecs >= 0) {
        item._idleTimeoutId = setTimeout(function onTimeout () {
          if (item._onTimeout) { item._onTimeout() }
        }, msecs)
      }
    }

// setimmediate attaches itself to the global object
    __webpack_require__(433)
    exports.setImmediate = setImmediate
    exports.clearImmediate = clearImmediate
  /** */ },
/* 171 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) {
      var required = __webpack_require__(432),
        qs = __webpack_require__(431),
        protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i,
        slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
      var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
        function sanitize (address) {          // Sanitize what is left of the address
          return address.replace('\\', '/')
        },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
      ]

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
      var ignore = { hash: 1, query: 1 }

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
      function lolcation (loc) {
        var globalVar

        if (typeof window !== 'undefined') globalVar = window
        else if (typeof global !== 'undefined') globalVar = global
        else if (typeof self !== 'undefined') globalVar = self
        else globalVar = {}

        var location = globalVar.location || {}
        loc = loc || location

        var finaldestination = {},
          type = typeof loc,
          key

        if (loc.protocol === 'blob:') {
          finaldestination = new Url(unescape(loc.pathname), {})
        } else if (type === 'string') {
          finaldestination = new Url(loc, {})
          for (key in ignore) delete finaldestination[key]
        } else if (type === 'object') {
          for (key in loc) {
            if (key in ignore) continue
            finaldestination[key] = loc[key]
          }

          if (finaldestination.slashes === undefined) {
            finaldestination.slashes = slashes.test(loc.href)
          }
        }

        return finaldestination
      }

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
      function extractProtocol (address) {
        var match = protocolre.exec(address)

        return {
          protocol: match[1] ? match[1].toLowerCase() : '',
          slashes: !!match[2],
          rest: match[3]
        }
      }

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
      function resolve (relative, base) {
        var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
          i = path.length,
          last = path[i - 1],
          unshift = false,
          up = 0

        while (i--) {
          if (path[i] === '.') {
            path.splice(i, 1)
          } else if (path[i] === '..') {
            path.splice(i, 1)
            up++
          } else if (up) {
            if (i === 0) unshift = true
            path.splice(i, 1)
            up--
          }
        }

        if (unshift) path.unshift('')
        if (last === '.' || last === '..') path.push('')

        return path.join('/')
      }

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
      function Url (address, location, parser) {
        if (!(this instanceof Url)) {
          return new Url(address, location, parser)
        }

        var relative, extracted, parse, instruction, index, key,
          instructions = rules.slice(),
          type = typeof location,
          url = this,
          i = 0

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
        if (type !== 'object' && type !== 'string') {
          parser = location
          location = null
        }

        if (parser && typeof parser !== 'function') parser = qs.parse

        location = lolcation(location)

  //
  // Extract protocol information before running the instructions.
  //
        extracted = extractProtocol(address || '')
        relative = !extracted.protocol && !extracted.slashes
        url.slashes = extracted.slashes || relative && location.slashes
        url.protocol = extracted.protocol || location.protocol || ''
        address = extracted.rest

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
        if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname']

        for (; i < instructions.length; i++) {
          instruction = instructions[i]

          if (typeof instruction === 'function') {
            address = instruction(address)
            continue
          }

          parse = instruction[0]
          key = instruction[1]

          if (parse !== parse) {
            url[key] = address
          } else if (typeof parse === 'string') {
            if (~(index = address.indexOf(parse))) {
              if (typeof instruction[2] === 'number') {
                url[key] = address.slice(0, index)
                address = address.slice(index + instruction[2])
              } else {
                url[key] = address.slice(index)
                address = address.slice(0, index)
              }
            }
          } else if ((index = parse.exec(address))) {
            url[key] = index[1]
            address = address.slice(0, index.index)
          }

          url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    )

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
          if (instruction[4]) url[key] = url[key].toLowerCase()
        }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
        if (parser) url.query = parser(url.query)

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
        if (
      relative &&
    location.slashes &&
    url.pathname.charAt(0) !== '/' &&
    (url.pathname !== '' || location.pathname !== '')
  ) {
          url.pathname = resolve(url.pathname, location.pathname)
        }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
        if (!required(url.port, url.protocol)) {
          url.host = url.hostname
          url.port = ''
        }

  //
  // Parse down the `auth` for the username and password.
  //
        url.username = url.password = ''
        if (url.auth) {
          instruction = url.auth.split(':')
          url.username = instruction[0] || ''
          url.password = instruction[1] || ''
        }

        url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol + '//' + url.host
    : 'null'

  //
  // The href is just the compiled result.
  //
        url.href = url.toString()
      }

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
      function set (part, value, fn) {
        var url = this

        switch (part) {
          case 'query':
            if (typeof value === 'string' && value.length) {
              value = (fn || qs.parse)(value)
            }

            url[part] = value
            break

          case 'port':
            url[part] = value

            if (!required(value, url.protocol)) {
              url.host = url.hostname
              url[part] = ''
            } else if (value) {
              url.host = url.hostname + ':' + value
            }

            break

          case 'hostname':
            url[part] = value

            if (url.port) value += ':' + url.port
            url.host = value
            break

          case 'host':
            url[part] = value

            if (/:\d+$/.test(value)) {
              value = value.split(':')
              url.port = value.pop()
              url.hostname = value.join(':')
            } else {
              url.hostname = value
              url.port = ''
            }

            break

          case 'protocol':
            url.protocol = value.toLowerCase()
            url.slashes = !fn
            break

          case 'pathname':
          case 'hash':
            if (value) {
              var char = part === 'pathname' ? '/' : '#'
              url[part] = value.charAt(0) !== char ? char + value : value
            } else {
              url[part] = value
            }
            break

          default:
            url[part] = value
        }

        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i]

          if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase()
        }

        url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol + '//' + url.host
    : 'null'

        url.href = url.toString()

        return url
      }

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
      function toString (stringify) {
        if (!stringify || typeof stringify !== 'function') stringify = qs.stringify

        var query,
          url = this,
          protocol = url.protocol

        if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':'

        var result = protocol + (url.slashes ? '//' : '')

        if (url.username) {
          result += url.username
          if (url.password) result += ':' + url.password
          result += '@'
        }

        result += url.host + url.pathname

        query = typeof url.query === 'object' ? stringify(url.query) : url.query
        if (query) result += query.charAt(0) !== '?' ? '?' + query : query

        if (url.hash) result += url.hash

        return result
      }

      Url.prototype = { set: set, toString: toString }

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
      Url.extractProtocol = extractProtocol
      Url.location = lolcation
      Url.qs = qs

      module.exports = Url
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 172 */
  /** */ function (module, exports) {
    module.exports = function (module) {
      if (!module.webpackPolyfill) {
        module.deprecate = function () {}
        module.paths = []
		// module.parent = undefined by default
        if (!module.children) module.children = []
        Object.defineProperty(module, 'loaded', {
          enumerable: true,
          get: function () {
            return module.l
          }
        })
        Object.defineProperty(module, 'id', {
          enumerable: true,
          get: function () {
            return module.i
          }
        })
        module.webpackPolyfill = 1
      }
      return module
    }
  /** */ },
/* 173 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
    var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

    var _defColors = {
      reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
      black: '000',
      red: 'ff0000',
      green: '209805',
      yellow: 'e8bf03',
      blue: '0000ff',
      magenta: 'ff00ff',
      cyan: '00ffee',
      lightgrey: 'f0f0f0',
      darkgrey: '888'
    }
    var _styles = {
      30: 'black',
      31: 'red',
      32: 'green',
      33: 'yellow',
      34: 'blue',
      35: 'magenta',
      36: 'cyan',
      37: 'lightgrey'
    }
    var _openTags = {
      '1': 'font-weight:bold', // bold
      '2': 'opacity:0.5', // dim
      '3': '<i>', // italic
      '4': '<u>', // underscore
      '8': 'display:none', // hidden
      '9': '<del>' // delete
    }
    var _closeTags = {
      '23': '</i>', // reset italic
      '24': '</u>', // reset underscore
      '29': '</del>' // reset delete
    }

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
    function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
      if (!_regANSI.test(text)) {
        return text
      }

  // Cache opened sequence.
      var ansiCodes = []
  // Replace with markup.
      var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
        var ot = _openTags[seq]
        if (ot) {
      // If current sequence has been opened, close it.
          if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
            ansiCodes.pop()
            return '</span>'
          }
      // Open tag.
          ansiCodes.push(seq)
          return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
        }

        var ct = _closeTags[seq]
        if (ct) {
      // Pop sequence
          ansiCodes.pop()
          return ct
        }
        return ''
      })

  // Make sure tags are closed.
      var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

      return ret
    }

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
    ansiHTML.setColors = function (colors) {
      if (typeof colors !== 'object') {
        throw new Error('`colors` parameter must be an Object.')
      }

      var _finalColors = {}
      for (var key in _defColors) {
        var hex = colors.hasOwnProperty(key) ? colors[key] : null
        if (!hex) {
          _finalColors[key] = _defColors[key]
          continue
        }
        if (key === 'reset') {
          if (typeof hex === 'string') {
            hex = [hex]
          }
          if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
            return typeof h !== 'string'
          })) {
            throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
          }
          var defHexColor = _defColors[key]
          if (!hex[0]) {
            hex[0] = defHexColor[0]
          }
          if (hex.length === 1 || !hex[1]) {
            hex = [hex[0]]
            hex.push(defHexColor[1])
          }

          hex = hex.slice(0, 2)
        } else if (typeof hex !== 'string') {
          throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
        }
        _finalColors[key] = hex
      }
      _setTags(_finalColors)
    }

/**
 * Reset colors.
 */
    ansiHTML.reset = function () {
      _setTags(_defColors)
    }

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
    ansiHTML.tags = {}

    if (Object.defineProperty) {
      Object.defineProperty(ansiHTML.tags, 'open', {
        get: function () { return _openTags }
      })
      Object.defineProperty(ansiHTML.tags, 'close', {
        get: function () { return _closeTags }
      })
    } else {
      ansiHTML.tags.open = _openTags
      ansiHTML.tags.close = _closeTags
    }

    function _setTags (colors) {
  // reset all
      _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
      _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
      _openTags['90'] = 'color:#' + colors.darkgrey

      for (var code in _styles) {
        var color = _styles[code]
        var oriColor = colors[color] || '000'
        _openTags[code] = 'color:#' + oriColor
        code = parseInt(code)
        _openTags[(code + 10).toString()] = 'background:#' + oriColor
      }
    }

    ansiHTML.reset()
  /** */ },
/* 174 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(187)
  /** */ },
/* 175 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(415)
    __webpack_require__(212)
    __webpack_require__(60)
    __webpack_require__(214)
    __webpack_require__(152)
    __webpack_require__(211)
    __webpack_require__(213)
    __webpack_require__(218)
    __webpack_require__(216)
    __webpack_require__(217)
    __webpack_require__(219)
    __webpack_require__(215)
    __webpack_require__(220)
    __webpack_require__(221)
    __webpack_require__(222)
    module.exports = __webpack_require__(15)
  /** */ },
/* 176 */
  /** */ function (module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    function EventEmitter () {
      this._events = this._events || {}
      this._maxListeners = this._maxListeners || undefined
    }
    module.exports = EventEmitter

// Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter

    EventEmitter.prototype._events = undefined
    EventEmitter.prototype._maxListeners = undefined

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function (n) {
      if (!isNumber(n) || n < 0 || isNaN(n)) { throw TypeError('n must be a positive number') }
      this._maxListeners = n
      return this
    }

    EventEmitter.prototype.emit = function (type) {
      var er, handler, len, args, i, listeners

      if (!this._events) { this._events = {} }

  // If there is no 'error' event listener then throw.
      if (type === 'error') {
        if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
          er = arguments[1]
          if (er instanceof Error) {
            throw er // Unhandled 'error' event
          } else {
        // At least give some kind of context to the user
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')')
            err.context = er
            throw err
          }
        }
      }

      handler = this._events[type]

      if (isUndefined(handler)) { return false }

      if (isFunction(handler)) {
        switch (arguments.length) {
      // fast cases
          case 1:
            handler.call(this)
            break
          case 2:
            handler.call(this, arguments[1])
            break
          case 3:
            handler.call(this, arguments[1], arguments[2])
            break
      // slower
          default:
            args = Array.prototype.slice.call(arguments, 1)
            handler.apply(this, args)
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1)
        listeners = handler.slice()
        len = listeners.length
        for (i = 0; i < len; i++) { listeners[i].apply(this, args) }
      }

      return true
    }

    EventEmitter.prototype.addListener = function (type, listener) {
      var m

      if (!isFunction(listener)) { throw TypeError('listener must be a function') }

      if (!this._events) { this._events = {} }

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
      if (this._events.newListener) {
        this.emit('newListener', type,
              isFunction(listener.listener)
              ? listener.listener : listener)
      }

      if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    { this._events[type] = listener } else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    { this._events[type].push(listener) } else
    // Adding the second element, need to change to array.
    { this._events[type] = [this._events[type], listener] }

  // Check for listener leak
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners
        } else {
          m = EventEmitter.defaultMaxListeners
        }

        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true
          console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length)
          if (typeof console.trace === 'function') {
        // not supported in IE 10
            console.trace()
          }
        }
      }

      return this
    }

    EventEmitter.prototype.on = EventEmitter.prototype.addListener

    EventEmitter.prototype.once = function (type, listener) {
      if (!isFunction(listener)) { throw TypeError('listener must be a function') }

      var fired = false

      function g () {
        this.removeListener(type, g)

        if (!fired) {
          fired = true
          listener.apply(this, arguments)
        }
      }

      g.listener = listener
      this.on(type, g)

      return this
    }

// emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function (type, listener) {
      var list, position, length, i

      if (!isFunction(listener)) { throw TypeError('listener must be a function') }

      if (!this._events || !this._events[type]) { return this }

      list = this._events[type]
      length = list.length
      position = -1

      if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
        delete this._events[type]
        if (this._events.removeListener) { this.emit('removeListener', type, listener) }
      } else if (isObject(list)) {
        for (i = length; i-- > 0;) {
          if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
            position = i
            break
          }
        }

        if (position < 0) { return this }

        if (list.length === 1) {
          list.length = 0
          delete this._events[type]
        } else {
          list.splice(position, 1)
        }

        if (this._events.removeListener) { this.emit('removeListener', type, listener) }
      }

      return this
    }

    EventEmitter.prototype.removeAllListeners = function (type) {
      var key, listeners

      if (!this._events) { return this }

  // not listening for removeListener, no need to emit
      if (!this._events.removeListener) {
        if (arguments.length === 0) { this._events = {} } else if (this._events[type]) { delete this._events[type] }
        return this
      }

  // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener') continue
          this.removeAllListeners(key)
        }
        this.removeAllListeners('removeListener')
        this._events = {}
        return this
      }

      listeners = this._events[type]

      if (isFunction(listeners)) {
        this.removeListener(type, listeners)
      } else if (listeners) {
    // LIFO order
        while (listeners.length) { this.removeListener(type, listeners[listeners.length - 1]) }
      }
      delete this._events[type]

      return this
    }

    EventEmitter.prototype.listeners = function (type) {
      var ret
      if (!this._events || !this._events[type]) { ret = [] } else if (isFunction(this._events[type])) { ret = [this._events[type]] } else { ret = this._events[type].slice() }
      return ret
    }

    EventEmitter.prototype.listenerCount = function (type) {
      if (this._events) {
        var evlistener = this._events[type]

        if (isFunction(evlistener)) { return 1 } else if (evlistener) { return evlistener.length }
      }
      return 0
    }

    EventEmitter.listenerCount = function (emitter, type) {
      return emitter.listenerCount(type)
    }

    function isFunction (arg) {
      return typeof arg === 'function'
    }

    function isNumber (arg) {
      return typeof arg === 'number'
    }

    function isObject (arg) {
      return typeof arg === 'object' && arg !== null
    }

    function isUndefined (arg) {
      return arg === void 0
    }
  /** */ },
/* 177 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = {
      XmlEntities: __webpack_require__(424),
      Html4Entities: __webpack_require__(423),
      Html5Entities: __webpack_require__(156),
      AllHtmlEntities: __webpack_require__(156)
    }
  /** */ },
/* 178 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (global, setImmediate) {
      var require; var require; var __WEBPACK_AMD_DEFINE_RESULT__; (function e (t, n, r) { function s (o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require === 'function' && require; if (!u && a) return require(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = 'MODULE_NOT_FOUND', f } var l = n[o] = { exports: {}}; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n || e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require === 'function' && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({ 1: [function (require, module, exports) {
        (function (process, global) {
          'use strict'

/* eslint no-unused-vars: off */
/* eslint-env commonjs */

/**
 * Shim process.stdout.
 */

          process.stdout = require('browser-stdout')()

          var Mocha = require('./lib/mocha')

/**
 * Create a Mocha instance.
 *
 * @return {undefined}
 */

          var mocha = new Mocha({ reporter: 'html' })

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

          var Date = global.Date
          var setTimeout = global.setTimeout
          var setInterval = global.setInterval
          var clearTimeout = global.clearTimeout
          var clearInterval = global.clearInterval

          var uncaughtExceptionHandlers = []

          var originalOnerrorHandler = global.onerror

/**
 * Remove uncaughtException listener.
 * Revert to original onerror handler if previously defined.
 */

          process.removeListener = function (e, fn) {
            if (e === 'uncaughtException') {
              if (originalOnerrorHandler) {
                global.onerror = originalOnerrorHandler
              } else {
                global.onerror = function () {}
              }
              var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn)
              if (i !== -1) {
                uncaughtExceptionHandlers.splice(i, 1)
              }
            }
          }

/**
 * Implements uncaughtException listener.
 */

          process.on = function (e, fn) {
            if (e === 'uncaughtException') {
              global.onerror = function (err, url, line) {
                fn(new Error(err + ' (' + url + ':' + line + ')'))
                return !mocha.allowUncaught
              }
              uncaughtExceptionHandlers.push(fn)
            }
          }

// The BDD UI is registered by default, but no UI will be functional in the
// browser without an explicit call to the overridden `mocha.ui` (see below).
// Ensure that this default UI does not expose its methods to the global scope.
          mocha.suite.removeAllListeners('pre-require')

          var immediateQueue = []
          var immediateTimeout

          function timeslice () {
            var immediateStart = new Date().getTime()
            while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {
              immediateQueue.shift()()
            }
            if (immediateQueue.length) {
              immediateTimeout = setTimeout(timeslice, 0)
            } else {
              immediateTimeout = null
            }
          }

/**
 * High-performance override of Runner.immediately.
 */

          Mocha.Runner.immediately = function (callback) {
            immediateQueue.push(callback)
            if (!immediateTimeout) {
              immediateTimeout = setTimeout(timeslice, 0)
            }
          }

/**
 * Function to allow assertion libraries to throw errors directly into mocha.
 * This is useful when running tests in a browser because window.onerror will
 * only receive the 'message' attribute of the Error.
 */
          mocha.throwError = function (err) {
            Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {
              fn(err)
            })
            throw err
          }

/**
 * Override ui to ensure that the ui functions are initialized.
 * Normally this would happen in Mocha.prototype.loadFiles.
 */

          mocha.ui = function (ui) {
            Mocha.prototype.ui.call(this, ui)
            this.suite.emit('pre-require', global, null, this)
            return this
          }

/**
 * Setup mocha with the given setting options.
 */

          mocha.setup = function (opts) {
            if (typeof opts === 'string') {
              opts = { ui: opts }
            }
            for (var opt in opts) {
              if (opts.hasOwnProperty(opt)) {
                this[opt](opts[opt])
              }
            }
            return this
          }

/**
 * Run mocha, returning the Runner.
 */

          mocha.run = function (fn) {
            var options = mocha.options
            mocha.globals('location')

            var query = Mocha.utils.parseQuery(global.location.search || '')
            if (query.grep) {
              mocha.grep(query.grep)
            }
            if (query.fgrep) {
              mocha.fgrep(query.fgrep)
            }
            if (query.invert) {
              mocha.invert()
            }

            return Mocha.prototype.run.call(mocha, function (err) {
    // The DOM Document is not available in Web Workers.
              var document = global.document
              if (document && document.getElementById('mocha') && options.noHighlighting !== true) {
                Mocha.utils.highlightTags('code')
              }
              if (fn) {
                fn(err)
              }
            })
          }

/**
 * Expose the process shim.
 * https://github.com/mochajs/mocha/pull/916
 */

          Mocha.process = process

/**
 * Expose mocha.
 */

          global.Mocha = Mocha
          global.mocha = mocha

// this allows test/acceptance/required-tokens.js to pass; thus,
// you can now do `const describe = require('mocha').describe` in a
// browser context (assuming browserification).  should fix #880
          module.exports = global
        }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
      }, { './lib/mocha': 14, '_process': 82, 'browser-stdout': 41 }], 2: [function (require, module, exports) {
        'use strict'

        function noop () {}

        module.exports = function () {
          return noop
        }
      }, {}], 3: [function (require, module, exports) {
        'use strict'

/**
 * Module exports.
 */

        exports.EventEmitter = EventEmitter

/**
 * Object#toString reference.
 */
        var objToString = Object.prototype.toString

/**
 * Check if a value is an array.
 *
 * @api private
 * @param {*} val The value to test.
 * @return {boolean} true if the value is an array, otherwise false.
 */
        function isArray (val) {
          return objToString.call(val) === '[object Array]'
        }

/**
 * Event emitter constructor.
 *
 * @api public
 */
        function EventEmitter () {}

/**
 * Add a listener.
 *
 * @api public
 * @param {string} name Event name.
 * @param {Function} fn Event handler.
 * @return {EventEmitter} Emitter instance.
 */
        EventEmitter.prototype.on = function (name, fn) {
          if (!this.$events) {
            this.$events = {}
          }

          if (!this.$events[name]) {
            this.$events[name] = fn
          } else if (isArray(this.$events[name])) {
            this.$events[name].push(fn)
          } else {
            this.$events[name] = [this.$events[name], fn]
          }

          return this
        }

        EventEmitter.prototype.addListener = EventEmitter.prototype.on

/**
 * Adds a volatile listener.
 *
 * @api public
 * @param {string} name Event name.
 * @param {Function} fn Event handler.
 * @return {EventEmitter} Emitter instance.
 */
        EventEmitter.prototype.once = function (name, fn) {
          var self = this

          function on () {
            self.removeListener(name, on)
            fn.apply(this, arguments)
          }

          on.listener = fn
          this.on(name, on)

          return this
        }

/**
 * Remove a listener.
 *
 * @api public
 * @param {string} name Event name.
 * @param {Function} fn Event handler.
 * @return {EventEmitter} Emitter instance.
 */
        EventEmitter.prototype.removeListener = function (name, fn) {
          if (this.$events && this.$events[name]) {
            var list = this.$events[name]

            if (isArray(list)) {
              var pos = -1

              for (var i = 0, l = list.length; i < l; i++) {
                if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
                  pos = i
                  break
                }
              }

              if (pos < 0) {
                return this
              }

              list.splice(pos, 1)

              if (!list.length) {
                delete this.$events[name]
              }
            } else if (list === fn || (list.listener && list.listener === fn)) {
              delete this.$events[name]
            }
          }

          return this
        }

/**
 * Remove all listeners for an event.
 *
 * @api public
 * @param {string} name Event name.
 * @return {EventEmitter} Emitter instance.
 */
        EventEmitter.prototype.removeAllListeners = function (name) {
          if (name === undefined) {
            this.$events = {}
            return this
          }

          if (this.$events && this.$events[name]) {
            this.$events[name] = null
          }

          return this
        }

/**
 * Get all listeners for a given event.
 *
 * @api public
 * @param {string} name Event name.
 * @return {EventEmitter} Emitter instance.
 */
        EventEmitter.prototype.listeners = function (name) {
          if (!this.$events) {
            this.$events = {}
          }

          if (!this.$events[name]) {
            this.$events[name] = []
          }

          if (!isArray(this.$events[name])) {
            this.$events[name] = [this.$events[name]]
          }

          return this.$events[name]
        }

/**
 * Emit an event.
 *
 * @api public
 * @param {string} name Event name.
 * @return {boolean} true if at least one handler was invoked, else false.
 */
        EventEmitter.prototype.emit = function (name) {
          if (!this.$events) {
            return false
          }

          var handler = this.$events[name]

          if (!handler) {
            return false
          }

          var args = Array.prototype.slice.call(arguments, 1)

          if (typeof handler === 'function') {
            handler.apply(this, args)
          } else if (isArray(handler)) {
            var listeners = handler.slice()

            for (var i = 0, l = listeners.length; i < l; i++) {
              listeners[i].apply(this, args)
            }
          } else {
            return false
          }

          return true
        }
      }, {}], 4: [function (require, module, exports) {
        'use strict'

/**
 * Expose `Progress`.
 */

        module.exports = Progress

/**
 * Initialize a new `Progress` indicator.
 */
        function Progress () {
          this.percent = 0
          this.size(0)
          this.fontSize(11)
          this.font('helvetica, arial, sans-serif')
        }

/**
 * Set progress size to `size`.
 *
 * @api public
 * @param {number} size
 * @return {Progress} Progress instance.
 */
        Progress.prototype.size = function (size) {
          this._size = size
          return this
        }

/**
 * Set text to `text`.
 *
 * @api public
 * @param {string} text
 * @return {Progress} Progress instance.
 */
        Progress.prototype.text = function (text) {
          this._text = text
          return this
        }

/**
 * Set font size to `size`.
 *
 * @api public
 * @param {number} size
 * @return {Progress} Progress instance.
 */
        Progress.prototype.fontSize = function (size) {
          this._fontSize = size
          return this
        }

/**
 * Set font to `family`.
 *
 * @param {string} family
 * @return {Progress} Progress instance.
 */
        Progress.prototype.font = function (family) {
          this._font = family
          return this
        }

/**
 * Update percentage to `n`.
 *
 * @param {number} n
 * @return {Progress} Progress instance.
 */
        Progress.prototype.update = function (n) {
          this.percent = n
          return this
        }

/**
 * Draw on `ctx`.
 *
 * @param {CanvasRenderingContext2d} ctx
 * @return {Progress} Progress instance.
 */
        Progress.prototype.draw = function (ctx) {
          try {
            var percent = Math.min(this.percent, 100)
            var size = this._size
            var half = size / 2
            var x = half
            var y = half
            var rad = half - 1
            var fontSize = this._fontSize

            ctx.font = fontSize + 'px ' + this._font

            var angle = Math.PI * 2 * (percent / 100)
            ctx.clearRect(0, 0, size, size)

    // outer circle
            ctx.strokeStyle = '#9f9f9f'
            ctx.beginPath()
            ctx.arc(x, y, rad, 0, angle, false)
            ctx.stroke()

    // inner circle
            ctx.strokeStyle = '#eee'
            ctx.beginPath()
            ctx.arc(x, y, rad - 1, 0, angle, true)
            ctx.stroke()

    // text
            var text = this._text || (percent | 0) + '%'
            var w = ctx.measureText(text).width

            ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1)
          } catch (err) {
    // don't fail if we can't render progress
          }
          return this
        }
      }, {}], 5: [function (require, module, exports) {
        (function (global) {
          'use strict'

          exports.isatty = function isatty () {
            return true
          }

          exports.getWindowSize = function getWindowSize () {
            if ('innerHeight' in global) {
              return [global.innerHeight, global.innerWidth]
            }
  // In a Web Worker, the DOM Window is not available.
            return [640, 480]
          }
        }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
      }, {}], 6: [function (require, module, exports) {
        'use strict'

/**
 * Module dependencies.
 */

        var JSON = require('json3')

/**
 * Expose `Context`.
 */

        module.exports = Context

/**
 * Initialize a new `Context`.
 *
 * @api private
 */
        function Context () {}

/**
 * Set or get the context `Runnable` to `runnable`.
 *
 * @api private
 * @param {Runnable} runnable
 * @return {Context}
 */
        Context.prototype.runnable = function (runnable) {
          if (!arguments.length) {
            return this._runnable
          }
          this.test = this._runnable = runnable
          return this
        }

/**
 * Set test timeout `ms`.
 *
 * @api private
 * @param {number} ms
 * @return {Context} self
 */
        Context.prototype.timeout = function (ms) {
          if (!arguments.length) {
            return this.runnable().timeout()
          }
          this.runnable().timeout(ms)
          return this
        }

/**
 * Set test timeout `enabled`.
 *
 * @api private
 * @param {boolean} enabled
 * @return {Context} self
 */
        Context.prototype.enableTimeouts = function (enabled) {
          this.runnable().enableTimeouts(enabled)
          return this
        }

/**
 * Set test slowness threshold `ms`.
 *
 * @api private
 * @param {number} ms
 * @return {Context} self
 */
        Context.prototype.slow = function (ms) {
          this.runnable().slow(ms)
          return this
        }

/**
 * Mark a test as skipped.
 *
 * @api private
 * @return {Context} self
 */
        Context.prototype.skip = function () {
          this.runnable().skip()
          return this
        }

/**
 * Allow a number of retries on failed tests
 *
 * @api private
 * @param {number} n
 * @return {Context} self
 */
        Context.prototype.retries = function (n) {
          if (!arguments.length) {
            return this.runnable().retries()
          }
          this.runnable().retries(n)
          return this
        }

/**
 * Inspect the context void of `._runnable`.
 *
 * @api private
 * @return {string}
 */
        Context.prototype.inspect = function () {
          return JSON.stringify(this, function (key, val) {
            return key === 'runnable' || key === 'test' ? undefined : val
          }, 2)
        }
      }, { 'json3': 69 }], 7: [function (require, module, exports) {
        'use strict'

/**
 * Module dependencies.
 */

        var Runnable = require('./runnable')
        var inherits = require('./utils').inherits

/**
 * Expose `Hook`.
 */

        module.exports = Hook

/**
 * Initialize a new `Hook` with the given `title` and callback `fn`.
 *
 * @param {String} title
 * @param {Function} fn
 * @api private
 */
        function Hook (title, fn) {
          Runnable.call(this, title, fn)
          this.type = 'hook'
        }

/**
 * Inherit from `Runnable.prototype`.
 */
        inherits(Hook, Runnable)

/**
 * Get or set the test `err`.
 *
 * @param {Error} err
 * @return {Error}
 * @api public
 */
        Hook.prototype.error = function (err) {
          if (!arguments.length) {
            err = this._error
            this._error = null
            return err
          }

          this._error = err
        }
      }, { './runnable': 33, './utils': 38 }], 8: [function (require, module, exports) {
        'use strict'

/**
 * Module dependencies.
 */

        var Test = require('../test')

/**
 * BDD-style interface:
 *
 *      describe('Array', function() {
 *        describe('#indexOf()', function() {
 *          it('should return -1 when not present', function() {
 *            // ...
 *          });
 *
 *          it('should return the index when present', function() {
 *            // ...
 *          });
 *        });
 *      });
 *
 * @param {Suite} suite Root suite.
 */
        module.exports = function (suite) {
          var suites = [suite]

          suite.on('pre-require', function (context, file, mocha) {
            var common = require('./common')(suites, context, mocha)

            context.before = common.before
            context.after = common.after
            context.beforeEach = common.beforeEach
            context.afterEach = common.afterEach
            context.run = mocha.options.delay && common.runWithSuite(suite)
    /**
     * Describe a "suite" with the given `title`
     * and callback `fn` containing nested suites
     * and/or tests.
     */

            context.describe = context.context = function (title, fn) {
              return common.suite.create({
                title: title,
                file: file,
                fn: fn
              })
            }

    /**
     * Pending describe.
     */

            context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {
              return common.suite.skip({
                title: title,
                file: file,
                fn: fn
              })
            }

    /**
     * Exclusive suite.
     */

            context.describe.only = function (title, fn) {
              return common.suite.only({
                title: title,
                file: file,
                fn: fn
              })
            }

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

            context.it = context.specify = function (title, fn) {
              var suite = suites[0]
              if (suite.isPending()) {
                fn = null
              }
              var test = new Test(title, fn)
              test.file = file
              suite.addTest(test)
              return test
            }

    /**
     * Exclusive test-case.
     */

            context.it.only = function (title, fn) {
              return common.test.only(mocha, context.it(title, fn))
            }

    /**
     * Pending test case.
     */

            context.xit = context.xspecify = context.it.skip = function (title) {
              context.it(title)
            }

    /**
     * Number of attempts to retry.
     */
            context.it.retries = function (n) {
              context.retries(n)
            }
          })
        }
      }, { '../test': 36, './common': 9 }], 9: [function (require, module, exports) {
        'use strict'

        var Suite = require('../suite')

/**
 * Functions common to more than one interface.
 *
 * @param {Suite[]} suites
 * @param {Context} context
 * @param {Mocha} mocha
 * @return {Object} An object containing common functions.
 */
        module.exports = function (suites, context, mocha) {
          return {
    /**
     * This is only present if flag --delay is passed into Mocha. It triggers
     * root suite execution.
     *
     * @param {Suite} suite The root suite.
     * @return {Function} A function which runs the root suite
     */
            runWithSuite: function runWithSuite (suite) {
              return function run () {
                suite.run()
              }
            },

    /**
     * Execute before running tests.
     *
     * @param {string} name
     * @param {Function} fn
     */
            before: function (name, fn) {
              suites[0].beforeAll(name, fn)
            },

    /**
     * Execute after running tests.
     *
     * @param {string} name
     * @param {Function} fn
     */
            after: function (name, fn) {
              suites[0].afterAll(name, fn)
            },

    /**
     * Execute before each test case.
     *
     * @param {string} name
     * @param {Function} fn
     */
            beforeEach: function (name, fn) {
              suites[0].beforeEach(name, fn)
            },

    /**
     * Execute after each test case.
     *
     * @param {string} name
     * @param {Function} fn
     */
            afterEach: function (name, fn) {
              suites[0].afterEach(name, fn)
            },

            suite: {
      /**
       * Create an exclusive Suite; convenience function
       * See docstring for create() below.
       *
       * @param {Object} opts
       * @returns {Suite}
       */
              only: function only (opts) {
                mocha.options.hasOnly = true
                opts.isOnly = true
                return this.create(opts)
              },

      /**
       * Create a Suite, but skip it; convenience function
       * See docstring for create() below.
       *
       * @param {Object} opts
       * @returns {Suite}
       */
              skip: function skip (opts) {
                opts.pending = true
                return this.create(opts)
              },

      /**
       * Creates a suite.
       * @param {Object} opts Options
       * @param {string} opts.title Title of Suite
       * @param {Function} [opts.fn] Suite Function (not always applicable)
       * @param {boolean} [opts.pending] Is Suite pending?
       * @param {string} [opts.file] Filepath where this Suite resides
       * @param {boolean} [opts.isOnly] Is Suite exclusive?
       * @returns {Suite}
       */
              create: function create (opts) {
                var suite = Suite.create(suites[0], opts.title)
                suite.pending = Boolean(opts.pending)
                suite.file = opts.file
                suites.unshift(suite)
                if (opts.isOnly) {
                  suite.parent._onlySuites = suite.parent._onlySuites.concat(suite)
                  mocha.options.hasOnly = true
                }
                if (typeof opts.fn === 'function') {
                  opts.fn.call(suite)
                  suites.shift()
                } else if (typeof opts.fn === 'undefined' && !suite.pending) {
                  throw new Error('Suite "' + suite.fullTitle() + '" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.')
                }

                return suite
              }
            },

            test: {

      /**
       * Exclusive test-case.
       *
       * @param {Object} mocha
       * @param {Function} test
       * @returns {*}
       */
              only: function (mocha, test) {
                test.parent._onlyTests = test.parent._onlyTests.concat(test)
                mocha.options.hasOnly = true
                return test
              },

      /**
       * Pending test case.
       *
       * @param {string} title
       */
              skip: function (title) {
                context.test(title)
              },

      /**
       * Number of retry attempts
       *
       * @param {number} n
       */
              retries: function (n) {
                context.retries(n)
              }
            }
          }
        }
      }, { '../suite': 35 }], 10: [function (require, module, exports) {
        'use strict'

/**
 * Module dependencies.
 */

        var Suite = require('../suite')
        var Test = require('../test')

/**
 * Exports-style (as Node.js module) interface:
 *
 *     exports.Array = {
 *       '#indexOf()': {
 *         'should return -1 when the value is not present': function() {
 *
 *         },
 *
 *         'should return the correct index when the value is present': function() {
 *
 *         }
 *       }
 *     };
 *
 * @param {Suite} suite Root suite.
 */
        module.exports = function (suite) {
          var suites = [suite]

          suite.on('require', visit)

          function visit (obj, file) {
            var suite
            for (var key in obj) {
              if (typeof obj[key] === 'function') {
                var fn = obj[key]
                switch (key) {
                  case 'before':
                    suites[0].beforeAll(fn)
                    break
                  case 'after':
                    suites[0].afterAll(fn)
                    break
                  case 'beforeEach':
                    suites[0].beforeEach(fn)
                    break
                  case 'afterEach':
                    suites[0].afterEach(fn)
                    break
                  default:
                    var test = new Test(key, fn)
                    test.file = file
                    suites[0].addTest(test)
                }
              } else {
                suite = Suite.create(suites[0], key)
                suites.unshift(suite)
                visit(obj[key], file)
                suites.shift()
              }
            }
          }
        }
      }, { '../suite': 35, '../test': 36 }], 11: [function (require, module, exports) {
        'use strict'

        exports.bdd = require('./bdd')
        exports.tdd = require('./tdd')
        exports.qunit = require('./qunit')
        exports.exports = require('./exports')
      }, { './bdd': 8, './exports': 10, './qunit': 12, './tdd': 13 }], 12: [function (require, module, exports) {
        'use strict'

/**
 * Module dependencies.
 */

        var Test = require('../test')

/**
 * QUnit-style interface:
 *
 *     suite('Array');
 *
 *     test('#length', function() {
 *       var arr = [1,2,3];
 *       ok(arr.length == 3);
 *     });
 *
 *     test('#indexOf()', function() {
 *       var arr = [1,2,3];
 *       ok(arr.indexOf(1) == 0);
 *       ok(arr.indexOf(2) == 1);
 *       ok(arr.indexOf(3) == 2);
 *     });
 *
 *     suite('String');
 *
 *     test('#length', function() {
 *       ok('foo'.length == 3);
 *     });
 *
 * @param {Suite} suite Root suite.
 */
        module.exports = function (suite) {
          var suites = [suite]

          suite.on('pre-require', function (context, file, mocha) {
            var common = require('./common')(suites, context, mocha)

            context.before = common.before
            context.after = common.after
            context.beforeEach = common.beforeEach
            context.afterEach = common.afterEach
            context.run = mocha.options.delay && common.runWithSuite(suite)
    /**
     * Describe a "suite" with the given `title`.
     */

            context.suite = function (title) {
              if (suites.length > 1) {
                suites.shift()
              }
              return common.suite.create({
                title: title,
                file: file,
                fn: false
              })
            }

    /**
     * Exclusive Suite.
     */

            context.suite.only = function (title) {
              if (suites.length > 1) {
                suites.shift()
              }
              return common.suite.only({
                title: title,
                file: file,
                fn: false
              })
            }

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

            context.test = function (title, fn) {
              var test = new Test(title, fn)
              test.file = file
              suites[0].addTest(test)
              return test
            }

    /**
     * Exclusive test-case.
     */

            context.test.only = function (title, fn) {
              return common.test.only(mocha, context.test(title, fn))
            }

            context.test.skip = common.test.skip
            context.test.retries = common.test.retries
          })
        }
      }, { '../test': 36, './common': 9 }], 13: [function (require, module, exports) {
        'use strict'

/**
 * Module dependencies.
 */

        var Test = require('../test')

/**
 * TDD-style interface:
 *
 *      suite('Array', function() {
 *        suite('#indexOf()', function() {
 *          suiteSetup(function() {
 *
 *          });
 *
 *          test('should return -1 when not present', function() {
 *
 *          });
 *
 *          test('should return the index when present', function() {
 *
 *          });
 *
 *          suiteTeardown(function() {
 *
 *          });
 *        });
 *      });
 *
 * @param {Suite} suite Root suite.
 */
        module.exports = function (suite) {
          var suites = [suite]

          suite.on('pre-require', function (context, file, mocha) {
            var common = require('./common')(suites, context, mocha)

            context.setup = common.beforeEach
            context.teardown = common.afterEach
            context.suiteSetup = common.before
            context.suiteTeardown = common.after
            context.run = mocha.options.delay && common.runWithSuite(suite)

    /**
     * Describe a "suite" with the given `title` and callback `fn` containing
     * nested suites and/or tests.
     */
            context.suite = function (title, fn) {
              return common.suite.create({
           title: title,
           file: file,
           fn: fn
         })
            }

    /**
     * Pending suite.
     */
            context.suite.skip = function (title, fn) {
              return common.suite.skip({
           title: title,
           file: file,
           fn: fn
         })
            }

    /**
     * Exclusive test-case.
     */
            context.suite.only = function (title, fn) {
              return common.suite.only({
           title: title,
           file: file,
           fn: fn
         })
            }

    /**
     * Describe a specification or test-case with the given `title` and
     * callback `fn` acting as a thunk.
     */
            context.test = function (title, fn) {
              var suite = suites[0]
              if (suite.isPending()) {
           fn = null
         }
              var test = new Test(title, fn)
              test.file = file
              suite.addTest(test)
              return test
            }

    /**
     * Exclusive test-case.
     */

            context.test.only = function (title, fn) {
              return common.test.only(mocha, context.test(title, fn))
            }

            context.test.skip = common.test.skip
            context.test.retries = common.test.retries
          })
        }
      }, { '../test': 36, './common': 9 }], 14: [function (require, module, exports) {
        (function (process, global, __dirname) {
          'use strict'

/*!
 * mocha
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

          var escapeRe = require('escape-string-regexp')
          var path = require('path')
          var reporters = require('./reporters')
          var utils = require('./utils')

/**
 * Expose `Mocha`.
 */

          exports = module.exports = Mocha

/**
 * To require local UIs and reporters when running in node.
 */

          if (!process.browser) {
            var cwd = process.cwd()
            module.paths.push(cwd, path.join(cwd, 'node_modules'))
          }

/**
 * Expose internals.
 */

          exports.utils = utils
          exports.interfaces = require('./interfaces')
          exports.reporters = reporters
          exports.Runnable = require('./runnable')
          exports.Context = require('./context')
          exports.Runner = require('./runner')
          exports.Suite = require('./suite')
          exports.Hook = require('./hook')
          exports.Test = require('./test')

/**
 * Return image `name` path.
 *
 * @api private
 * @param {string} name
 * @return {string}
 */
          function image (name) {
            return path.join(__dirname, '../images', name + '.png')
          }

/**
 * Set up mocha with `options`.
 *
 * Options:
 *
 *   - `ui` name "bdd", "tdd", "exports" etc
 *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`
 *   - `globals` array of accepted globals
 *   - `timeout` timeout in milliseconds
 *   - `retries` number of times to retry failed tests
 *   - `bail` bail on the first test failure
 *   - `slow` milliseconds to wait before considering a test slow
 *   - `ignoreLeaks` ignore global leaks
 *   - `fullTrace` display the full stack-trace on failing
 *   - `grep` string or regexp to filter tests with
 *
 * @param {Object} options
 * @api public
 */
          function Mocha (options) {
            options = options || {}
            this.files = []
            this.options = options
            if (options.grep) {
         this.grep(new RegExp(options.grep))
       }
            if (options.fgrep) {
         this.fgrep(options.fgrep)
       }
            this.suite = new exports.Suite('', new exports.Context())
            this.ui(options.ui)
            this.bail(options.bail)
            this.reporter(options.reporter, options.reporterOptions)
            if (typeof options.timeout !== 'undefined' && options.timeout !== null) {
         this.timeout(options.timeout)
       }
            if (typeof options.retries !== 'undefined' && options.retries !== null) {
         this.retries(options.retries)
       }
            this.useColors(options.useColors)
            if (options.enableTimeouts !== null) {
         this.enableTimeouts(options.enableTimeouts)
       }
            if (options.slow) {
         this.slow(options.slow)
       }
          }

/**
 * Enable or disable bailing on the first failure.
 *
 * @api public
 * @param {boolean} [bail]
 */
          Mocha.prototype.bail = function (bail) {
            if (!arguments.length) {
         bail = true
       }
            this.suite.bail(bail)
            return this
          }

/**
 * Add test `file`.
 *
 * @api public
 * @param {string} file
 */
          Mocha.prototype.addFile = function (file) {
            this.files.push(file)
            return this
          }

/**
 * Set reporter to `reporter`, defaults to "spec".
 *
 * @param {String|Function} reporter name or constructor
 * @param {Object} reporterOptions optional options
 * @api public
 * @param {string|Function} reporter name or constructor
 * @param {Object} reporterOptions optional options
 */
          Mocha.prototype.reporter = function (reporter, reporterOptions) {
            if (typeof reporter === 'function') {
         this._reporter = reporter
       } else {
         reporter = reporter || 'spec'
         var _reporter
    // Try to load a built-in reporter.
         if (reporters[reporter]) {
          _reporter = reporters[reporter]
        }
    // Try to load reporters from process.cwd() and node_modules
         if (!_reporter) {
          try {
            _reporter = require(reporter)
          } catch (err) {
            if (err.message.indexOf('Cannot find module') !== -1) {
          // Try to load reporters from a path (absolute or relative)
              try {
                _reporter = require(path.resolve(process.cwd(), reporter))
              } catch (_err) {
                err.message.indexOf('Cannot find module') !== -1 ? console.warn('"' + reporter + '" reporter not found')
              : console.warn('"' + reporter + '" reporter blew up with error:\n' + err.stack)
              }
            } else {
              console.warn('"' + reporter + '" reporter blew up with error:\n' + err.stack)
            }
          }
        }
         if (!_reporter && reporter === 'teamcity') {
          console.warn('The Teamcity reporter was moved to a package named ' +
        'mocha-teamcity-reporter ' +
        '(https://npmjs.org/package/mocha-teamcity-reporter).')
        }
         if (!_reporter) {
          throw new Error('invalid reporter "' + reporter + '"')
        }
         this._reporter = _reporter
       }
            this.options.reporterOptions = reporterOptions
            return this
          }

/**
 * Set test UI `name`, defaults to "bdd".
 *
 * @api public
 * @param {string} bdd
 */
          Mocha.prototype.ui = function (name) {
            name = name || 'bdd'
            this._ui = exports.interfaces[name]
            if (!this._ui) {
         try {
          this._ui = require(name)
        } catch (err) {
          throw new Error('invalid interface "' + name + '"')
        }
       }
            this._ui = this._ui(this.suite)

            this.suite.on('pre-require', function (context) {
         exports.afterEach = context.afterEach || context.teardown
         exports.after = context.after || context.suiteTeardown
         exports.beforeEach = context.beforeEach || context.setup
         exports.before = context.before || context.suiteSetup
         exports.describe = context.describe || context.suite
         exports.it = context.it || context.test
         exports.xit = context.xit || context.test.skip
         exports.setup = context.setup || context.beforeEach
         exports.suiteSetup = context.suiteSetup || context.before
         exports.suiteTeardown = context.suiteTeardown || context.after
         exports.suite = context.suite || context.describe
         exports.teardown = context.teardown || context.afterEach
         exports.test = context.test || context.it
         exports.run = context.run
       })

            return this
          }

/**
 * Load registered files.
 *
 * @api private
 */
          Mocha.prototype.loadFiles = function (fn) {
            var self = this
            var suite = this.suite
            this.files.forEach(function (file) {
         file = path.resolve(file)
         suite.emit('pre-require', global, file, self)
         suite.emit('require', require(file), file, self)
         suite.emit('post-require', global, file, self)
       })
            fn && fn()
          }

/**
 * Enable growl support.
 *
 * @api private
 */
          Mocha.prototype._growl = function (runner, reporter) {
            var notify = require('growl')

            runner.on('end', function () {
         var stats = reporter.stats
         if (stats.failures) {
          var msg = stats.failures + ' of ' + runner.total + ' tests failed'
          notify(msg, { name: 'mocha', title: 'Failed', image: image('error') })
        } else {
          notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {
            name: 'mocha',
            title: 'Passed',
            image: image('ok')
          })
        }
       })
          }

/**
 * Escape string and add it to grep as a regexp.
 *
 * @api public
 * @param str
 * @returns {Mocha}
 */
          Mocha.prototype.fgrep = function (str) {
            return this.grep(new RegExp(escapeRe(str)))
          }

/**
 * Add regexp to grep, if `re` is a string it is escaped.
 *
 * @param {RegExp|String} re
 * @return {Mocha}
 * @api public
 * @param {RegExp|string} re
 * @return {Mocha}
 */
          Mocha.prototype.grep = function (re) {
            if (utils.isString(re)) {
    // extract args if it's regex-like, i.e: [string, pattern, flag]
         var arg = re.match(/^\/(.*)\/(g|i|)$|.*/)
         this.options.grep = new RegExp(arg[1] || arg[0], arg[2])
       } else {
         this.options.grep = re
       }
            return this
          }
/**
 * Invert `.grep()` matches.
 *
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.invert = function () {
            this.options.invert = true
            return this
          }

/**
 * Ignore global leaks.
 *
 * @param {Boolean} ignore
 * @return {Mocha}
 * @api public
 * @param {boolean} ignore
 * @return {Mocha}
 */
          Mocha.prototype.ignoreLeaks = function (ignore) {
            this.options.ignoreLeaks = Boolean(ignore)
            return this
          }

/**
 * Enable global leak checking.
 *
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.checkLeaks = function () {
            this.options.ignoreLeaks = false
            return this
          }

/**
 * Display long stack-trace on failing
 *
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.fullTrace = function () {
            this.options.fullStackTrace = true
            return this
          }

/**
 * Enable growl support.
 *
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.growl = function () {
            this.options.growl = true
            return this
          }

/**
 * Ignore `globals` array or string.
 *
 * @param {Array|String} globals
 * @return {Mocha}
 * @api public
 * @param {Array|string} globals
 * @return {Mocha}
 */
          Mocha.prototype.globals = function (globals) {
            this.options.globals = (this.options.globals || []).concat(globals)
            return this
          }

/**
 * Emit color output.
 *
 * @param {Boolean} colors
 * @return {Mocha}
 * @api public
 * @param {boolean} colors
 * @return {Mocha}
 */
          Mocha.prototype.useColors = function (colors) {
            if (colors !== undefined) {
         this.options.useColors = colors
       }
            return this
          }

/**
 * Use inline diffs rather than +/-.
 *
 * @param {Boolean} inlineDiffs
 * @return {Mocha}
 * @api public
 * @param {boolean} inlineDiffs
 * @return {Mocha}
 */
          Mocha.prototype.useInlineDiffs = function (inlineDiffs) {
            this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs
            return this
          }

/**
 * Set the timeout in milliseconds.
 *
 * @param {Number} timeout
 * @return {Mocha}
 * @api public
 * @param {number} timeout
 * @return {Mocha}
 */
          Mocha.prototype.timeout = function (timeout) {
            this.suite.timeout(timeout)
            return this
          }

/**
 * Set the number of times to retry failed tests.
 *
 * @param {Number} retry times
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.retries = function (n) {
            this.suite.retries(n)
            return this
          }

/**
 * Set slowness threshold in milliseconds.
 *
 * @param {Number} slow
 * @return {Mocha}
 * @api public
 * @param {number} slow
 * @return {Mocha}
 */
          Mocha.prototype.slow = function (slow) {
            this.suite.slow(slow)
            return this
          }

/**
 * Enable timeouts.
 *
 * @param {Boolean} enabled
 * @return {Mocha}
 * @api public
 * @param {boolean} enabled
 * @return {Mocha}
 */
          Mocha.prototype.enableTimeouts = function (enabled) {
            this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true)
            return this
          }

/**
 * Makes all tests async (accepting a callback)
 *
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.asyncOnly = function () {
            this.options.asyncOnly = true
            return this
          }

/**
 * Disable syntax highlighting (in browser).
 *
 * @api public
 */
          Mocha.prototype.noHighlighting = function () {
            this.options.noHighlighting = true
            return this
          }

/**
 * Enable uncaught errors to propagate (in browser).
 *
 * @return {Mocha}
 * @api public
 */
          Mocha.prototype.allowUncaught = function () {
            this.options.allowUncaught = true
            return this
          }

/**
 * Delay root suite execution.
 * @returns {Mocha}
 */
          Mocha.prototype.delay = function delay () {
            this.options.delay = true
            return this
          }

/**
 * Tests marked only fail the suite
 * @returns {Mocha}
 */
          Mocha.prototype.forbidOnly = function () {
            this.options.forbidOnly = true
            return this
          }

/**
 * Pending tests and tests marked skip fail the suite
 * @returns {Mocha}
 */
          Mocha.prototype.forbidPending = function () {
            this.options.forbidPending = true
            return this
          }

/**
 * Run tests and invoke `fn()` when complete.
 *
 * @api public
 * @param {Function} fn
 * @return {Runner}
 */
          Mocha.prototype.run = function (fn) {
            if (this.files.length) {
         this.loadFiles()
       }
            var suite = this.suite
            var options = this.options
            options.files = this.files
            var runner = new exports.Runner(suite, options.delay)
            var reporter = new this._reporter(runner, options)
            runner.ignoreLeaks = options.ignoreLeaks !== false
            runner.fullStackTrace = options.fullStackTrace
            runner.hasOnly = options.hasOnly
            runner.asyncOnly = options.asyncOnly
            runner.allowUncaught = options.allowUncaught
            runner.forbidOnly = options.forbidOnly
            runner.forbidPending = options.forbidPending
            if (options.grep) {
         runner.grep(options.grep, options.invert)
       }
            if (options.globals) {
         runner.globals(options.globals)
       }
            if (options.growl) {
         this._growl(runner, reporter)
       }
            if (options.useColors !== undefined) {
         exports.reporters.Base.useColors = options.useColors
       }
            exports.reporters.Base.inlineDiffs = options.useInlineDiffs

            function done (failures) {
         if (reporter.done) {
          reporter.done(failures, fn)
        } else {
          fn && fn(failures)
        }
       }

            return runner.run(done)
          }
        }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, '/lib')
      }, { './context': 6, './hook': 7, './interfaces': 11, './reporters': 21, './runnable': 33, './runner': 34, './suite': 35, './test': 36, './utils': 38, '_process': 82, 'escape-string-regexp': 61, 'growl': 63, 'path': 42 }], 15: [function (require, module, exports) {
        'use strict'

/**
 * Helpers.
 */

        var s = 1000
        var m = s * 60
        var h = m * 60
        var d = h * 24
        var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @api public
 * @param {string|number} val
 * @param {Object} options
 * @return {string|number}
 */
        module.exports = function (val, options) {
          options = options || {}
          if (typeof val === 'string') {
       return parse(val)
     }
  // https://github.com/mochajs/mocha/pull/1035
          return options['long'] ? longFormat(val) : shortFormat(val)
        }

/**
 * Parse the given `str` and return milliseconds.
 *
 * @api private
 * @param {string} str
 * @return {number}
 */
        function parse (str) {
          var match = (/^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str)
          if (!match) {
       return
     }
          var n = parseFloat(match[1])
          var type = (match[2] || 'ms').toLowerCase()
          switch (type) {
       case 'years':
       case 'year':
       case 'y':
         return n * y
       case 'days':
       case 'day':
       case 'd':
         return n * d
       case 'hours':
       case 'hour':
       case 'h':
         return n * h
       case 'minutes':
       case 'minute':
       case 'm':
         return n * m
       case 'seconds':
       case 'second':
       case 's':
         return n * s
       case 'ms':
         return n
       default:
      // No default case
     }
        }

/**
 * Short format for `ms`.
 *
 * @api private
 * @param {number} ms
 * @return {string}
 */
        function shortFormat (ms) {
          if (ms >= d) {
       return Math.round(ms / d) + 'd'
     }
          if (ms >= h) {
       return Math.round(ms / h) + 'h'
     }
          if (ms >= m) {
       return Math.round(ms / m) + 'm'
     }
          if (ms >= s) {
       return Math.round(ms / s) + 's'
     }
          return ms + 'ms'
        }

/**
 * Long format for `ms`.
 *
 * @api private
 * @param {number} ms
 * @return {string}
 */
        function longFormat (ms) {
          return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
        }

/**
 * Pluralization helper.
 *
 * @api private
 * @param {number} ms
 * @param {number} n
 * @param {string} name
 */
        function plural (ms, n, name) {
          if (ms < n) {
       return
     }
          if (ms < n * 1.5) {
       return Math.floor(ms / n) + ' ' + name
     }
          return Math.ceil(ms / n) + ' ' + name + 's'
        }
      }, {}], 16: [function (require, module, exports) {
        'use strict'

/**
 * Expose `Pending`.
 */

        module.exports = Pending

/**
 * Initialize a new `Pending` error with the given message.
 *
 * @param {string} message
 */
        function Pending (message) {
     this.message = message
   }
      }, {}], 17: [function (require, module, exports) {
   (function (process, global) {
    'use strict'

/**
 * Module dependencies.
 */

    var tty = require('tty')
    var diff = require('diff')
    var ms = require('../ms')
    var utils = require('../utils')
    var supportsColor = process.browser ? null : require('supports-color')

/**
 * Expose `Base`.
 */

    exports = module.exports = Base

/**
 * Save timer references to avoid Sinon interfering.
 * See: https://github.com/mochajs/mocha/issues/237
 */

/* eslint-disable no-unused-vars, no-native-reassign */
    var Date = global.Date
    var setTimeout = global.setTimeout
    var setInterval = global.setInterval
    var clearTimeout = global.clearTimeout
    var clearInterval = global.clearInterval
/* eslint-enable no-unused-vars, no-native-reassign */

/**
 * Check if both stdio streams are associated with a tty.
 */

    var isatty = tty.isatty(1) && tty.isatty(2)

/**
 * Enable coloring by default, except in the browser interface.
 */

    exports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined))

/**
 * Inline diffs instead of +/-
 */

    exports.inlineDiffs = false

/**
 * Default color map.
 */

    exports.colors = {
      pass: 90,
      fail: 31,
      'bright pass': 92,
      'bright fail': 91,
      'bright yellow': 93,
      pending: 36,
      suite: 0,
      'error title': 0,
      'error message': 31,
      'error stack': 90,
      checkmark: 32,
      fast: 90,
      medium: 33,
      slow: 31,
      green: 32,
      light: 90,
      'diff gutter': 90,
      'diff added': 32,
      'diff removed': 31
    }

/**
 * Default symbol map.
 */

    exports.symbols = {
      ok: '',
      err: '',
      dot: '',
      comma: ',',
      bang: '!'
    }

// With node.js on Windows: use symbols available in terminal default fonts
    if (process.platform === 'win32') {
      exports.symbols.ok = '\u221A'
      exports.symbols.err = '\u00D7'
      exports.symbols.dot = '.'
    }

/**
 * Color `str` with the given `type`,
 * allowing colors to be disabled,
 * as well as user-defined color
 * schemes.
 *
 * @param {string} type
 * @param {string} str
 * @return {string}
 * @api private
 */
    var color = exports.color = function (type, str) {
      if (!exports.useColors) {
        return String(str)
      }
      return '\u001b[' + exports.colors[type] + 'm' + str + '\u001b[0m'
    }

/**
 * Expose term window size, with some defaults for when stderr is not a tty.
 */

    exports.window = {
      width: 75
    }

    if (isatty) {
      exports.window.width = process.stdout.getWindowSize
      ? process.stdout.getWindowSize(1)[0]
      : tty.getWindowSize()[1]
    }

/**
 * Expose some basic cursor interactions that are common among reporters.
 */

    exports.cursor = {
      hide: function () {
        isatty && process.stdout.write('\u001b[?25l')
      },

      show: function () {
        isatty && process.stdout.write('\u001b[?25h')
      },

      deleteLine: function () {
        isatty && process.stdout.write('\u001b[2K')
      },

      beginningOfLine: function () {
        isatty && process.stdout.write('\u001b[0G')
      },

      CR: function () {
        if (isatty) {
          exports.cursor.deleteLine()
          exports.cursor.beginningOfLine()
        } else {
          process.stdout.write('\r')
        }
      }
    }

/**
 * Output the given `failures` as a list.
 *
 * @param {Array} failures
 * @api public
 */

    exports.list = function (failures) {
      console.log()
      failures.forEach(function (test, i) {
    // format
        var fmt = color('error title', '  %s) %s:\n') +
      color('error message', '     %s') +
      color('error stack', '\n%s\n')

    // msg
        var msg
        var err = test.err
        var message
        if (err.message && typeof err.message.toString === 'function') {
          message = err.message + ''
        } else if (typeof err.inspect === 'function') {
          message = err.inspect() + ''
        } else {
          message = ''
        }
        var stack = err.stack || message
        var index = message ? stack.indexOf(message) : -1
        var actual = err.actual
        var expected = err.expected
        var escape = true

        if (index === -1) {
          msg = message
        } else {
          index += message.length
          msg = stack.slice(0, index)
      // remove msg from stack
          stack = stack.slice(index + 1)
        }

    // uncaught
        if (err.uncaught) {
          msg = 'Uncaught ' + msg
        }
    // explicitly show diff
        if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {
          escape = false
          if (!(utils.isString(actual) && utils.isString(expected))) {
            err.actual = actual = utils.stringify(actual)
            err.expected = expected = utils.stringify(expected)
          }

          fmt = color('error title', '  %s) %s:\n%s') + color('error stack', '\n%s\n')
          var match = message.match(/^([^:]+): expected/)
          msg = '\n      ' + color('error message', match ? match[1] : msg)

          if (exports.inlineDiffs) {
            msg += inlineDiff(err, escape)
          } else {
            msg += unifiedDiff(err, escape)
          }
        }

    // indent stack trace
        stack = stack.replace(/^/gm, '  ')

        console.log(fmt, (i + 1), test.fullTitle(), msg, stack)
      })
    }

/**
 * Initialize a new `Base` reporter.
 *
 * All other reporters generally
 * inherit from this reporter, providing
 * stats such as test duration, number
 * of tests passed / failed etc.
 *
 * @param {Runner} runner
 * @api public
 */

    function Base (runner) {
      var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }
      var failures = this.failures = []

      if (!runner) {
        return
      }
      this.runner = runner

      runner.stats = stats

      runner.on('start', function () {
        stats.start = new Date()
      })

      runner.on('suite', function (suite) {
        stats.suites = stats.suites || 0
        suite.root || stats.suites++
      })

      runner.on('test end', function () {
        stats.tests = stats.tests || 0
        stats.tests++
      })

      runner.on('pass', function (test) {
        stats.passes = stats.passes || 0

        if (test.duration > test.slow()) {
          test.speed = 'slow'
        } else if (test.duration > test.slow() / 2) {
          test.speed = 'medium'
        } else {
          test.speed = 'fast'
        }

        stats.passes++
      })

      runner.on('fail', function (test, err) {
        stats.failures = stats.failures || 0
        stats.failures++
        test.err = err
        failures.push(test)
      })

      runner.on('end', function () {
        stats.end = new Date()
        stats.duration = new Date() - stats.start
      })

      runner.on('pending', function () {
        stats.pending++
      })
    }

/**
 * Output common epilogue used by many of
 * the bundled reporters.
 *
 * @api public
 */
    Base.prototype.epilogue = function () {
      var stats = this.stats
      var fmt

      console.log()

  // passes
      fmt = color('bright pass', ' ') +
    color('green', ' %d passing') +
    color('light', ' (%s)')

      console.log(fmt,
    stats.passes || 0,
    ms(stats.duration))

  // pending
      if (stats.pending) {
        fmt = color('pending', ' ') +
      color('pending', ' %d pending')

        console.log(fmt, stats.pending)
      }

  // failures
      if (stats.failures) {
        fmt = color('fail', '  %d failing')

        console.log(fmt, stats.failures)

        Base.list(this.failures)
        console.log()
      }

      console.log()
    }

/**
 * Pad the given `str` to `len`.
 *
 * @api private
 * @param {string} str
 * @param {string} len
 * @return {string}
 */
    function pad (str, len) {
      str = String(str)
      return Array(len - str.length + 1).join(' ') + str
    }

/**
 * Returns an inline diff between 2 strings with coloured ANSI output
 *
 * @api private
 * @param {Error} err with actual/expected
 * @param {boolean} escape
 * @return {string} Diff
 */
    function inlineDiff (err, escape) {
      var msg = errorDiff(err, 'WordsWithSpace', escape)

  // linenos
      var lines = msg.split('\n')
      if (lines.length > 4) {
        var width = String(lines.length).length
        msg = lines.map(function (str, i) {
          return pad(++i, width) + ' |' + ' ' + str
        }).join('\n')
      }

  // legend
      msg = '\n' +
    color('diff removed', 'actual') +
    ' ' +
    color('diff added', 'expected') +
    '\n\n' +
    msg +
    '\n'

  // indent
      msg = msg.replace(/^/gm, '      ')
      return msg
    }

/**
 * Returns a unified diff between two strings.
 *
 * @api private
 * @param {Error} err with actual/expected
 * @param {boolean} escape
 * @return {string} The diff.
 */
    function unifiedDiff (err, escape) {
      var indent = '      '
      function cleanUp (line) {
        if (escape) {
          line = escapeInvisibles(line)
        }
        if (line[0] === '+') {
          return indent + colorLines('diff added', line)
        }
        if (line[0] === '-') {
          return indent + colorLines('diff removed', line)
        }
        if (line.match(/@@/)) {
          return null
        }
        if (line.match(/\\ No newline/)) {
          return null
        }
        return indent + line
      }
      function notBlank (line) {
        return typeof line !== 'undefined' && line !== null
      }
      var msg = diff.createPatch('string', err.actual, err.expected)
      var lines = msg.split('\n').splice(4)
      return '\n      ' +
    colorLines('diff added', '+ expected') + ' ' +
    colorLines('diff removed', '- actual') +
    '\n\n' +
    lines.map(cleanUp).filter(notBlank).join('\n')
    }

/**
 * Return a character diff for `err`.
 *
 * @api private
 * @param {Error} err
 * @param {string} type
 * @param {boolean} escape
 * @return {string}
 */
    function errorDiff (err, type, escape) {
      var actual = escape ? escapeInvisibles(err.actual) : err.actual
      var expected = escape ? escapeInvisibles(err.expected) : err.expected
      return diff['diff' + type](actual, expected).map(function (str) {
        if (str.added) {
          return colorLines('diff added', str.value)
        }
        if (str.removed) {
          return colorLines('diff removed', str.value)
        }
        return str.value
      }).join('')
    }

/**
 * Returns a string with all invisible characters in plain text
 *
 * @api private
 * @param {string} line
 * @return {string}
 */
    function escapeInvisibles (line) {
      return line.replace(/\t/g, '<tab>')
    .replace(/\r/g, '<CR>')
    .replace(/\n/g, '<LF>\n')
    }

/**
 * Color lines for `str`, using the color `name`.
 *
 * @api private
 * @param {string} name
 * @param {string} str
 * @return {string}
 */
    function colorLines (name, str) {
      return str.split('\n').map(function (str) {
        return color(name, str)
      }).join('\n')
    }

/**
 * Object#toString reference.
 */
    var objToString = Object.prototype.toString

/**
 * Check that a / b have the same type.
 *
 * @api private
 * @param {Object} a
 * @param {Object} b
 * @return {boolean}
 */
    function sameType (a, b) {
      return objToString.call(a) === objToString.call(b)
    }
  }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
 }, { '../ms': 15, '../utils': 38, '_process': 82, 'diff': 55, 'supports-color': 42, 'tty': 5 }], 18: [function (require, module, exports) {
  'use strict'

/**
 * Module dependencies.
 */

  var Base = require('./base')
  var utils = require('../utils')

/**
 * Expose `Doc`.
 */

  exports = module.exports = Doc

/**
 * Initialize a new `Doc` reporter.
 *
 * @param {Runner} runner
 * @api public
 */
  function Doc (runner) {
    Base.call(this, runner)

    var indents = 2

    function indent () {
      return Array(indents).join('  ')
    }

    runner.on('suite', function (suite) {
      if (suite.root) {
        return
      }
      ++indents
      console.log('%s<section class="suite">', indent())
      ++indents
      console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title))
      console.log('%s<dl>', indent())
    })

    runner.on('suite end', function (suite) {
      if (suite.root) {
        return
      }
      console.log('%s</dl>', indent())
      --indents
      console.log('%s</section>', indent())
      --indents
    })

    runner.on('pass', function (test) {
      console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title))
      var code = utils.escape(utils.clean(test.body))
      console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code)
    })

    runner.on('fail', function (test, err) {
      console.log('%s  <dt class="error">%s</dt>', indent(), utils.escape(test.title))
      var code = utils.escape(utils.clean(test.body))
      console.log('%s  <dd class="error"><pre><code>%s</code></pre></dd>', indent(), code)
      console.log('%s  <dd class="error">%s</dd>', indent(), utils.escape(err))
    })
  }
}, { '../utils': 38, './base': 17 }], 19: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var inherits = require('../utils').inherits
    var color = Base.color

/**
 * Expose `Dot`.
 */

    exports = module.exports = Dot

/**
 * Initialize a new `Dot` matrix test reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function Dot (runner) {
      Base.call(this, runner)

      var self = this
      var width = Base.window.width * 0.75 | 0
      var n = -1

      runner.on('start', function () {
        process.stdout.write('\n')
      })

      runner.on('pending', function () {
        if (++n % width === 0) {
          process.stdout.write('\n  ')
        }
        process.stdout.write(color('pending', Base.symbols.comma))
      })

      runner.on('pass', function (test) {
        if (++n % width === 0) {
          process.stdout.write('\n  ')
        }
        if (test.speed === 'slow') {
          process.stdout.write(color('bright yellow', Base.symbols.dot))
        } else {
          process.stdout.write(color(test.speed, Base.symbols.dot))
        }
      })

      runner.on('fail', function () {
        if (++n % width === 0) {
          process.stdout.write('\n  ')
        }
        process.stdout.write(color('fail', Base.symbols.bang))
      })

      runner.on('end', function () {
        console.log()
        self.epilogue()
      })
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(Dot, Base)
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 20: [function (require, module, exports) {
  (function (global) {
    'use strict'

/* eslint-env browser */

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var utils = require('../utils')
    var Progress = require('../browser/progress')
    var escapeRe = require('escape-string-regexp')
    var escape = utils.escape

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

/* eslint-disable no-unused-vars, no-native-reassign */
    var Date = global.Date
    var setTimeout = global.setTimeout
    var setInterval = global.setInterval
    var clearTimeout = global.clearTimeout
    var clearInterval = global.clearInterval
/* eslint-enable no-unused-vars, no-native-reassign */

/**
 * Expose `HTML`.
 */

    exports = module.exports = HTML

/**
 * Stats template.
 */

    var statsTemplate = '<ul id="mocha-stats">' +
  '<li class="progress"><canvas width="40" height="40"></canvas></li>' +
  '<li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li>' +
  '<li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li>' +
  '<li class="duration">duration: <em>0</em>s</li>' +
  '</ul>'

    var playIcon = '&#x2023;'

/**
 * Initialize a new `HTML` reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function HTML (runner) {
      Base.call(this, runner)

      var self = this
      var stats = this.stats
      var stat = fragment(statsTemplate)
      var items = stat.getElementsByTagName('li')
      var passes = items[1].getElementsByTagName('em')[0]
      var passesLink = items[1].getElementsByTagName('a')[0]
      var failures = items[2].getElementsByTagName('em')[0]
      var failuresLink = items[2].getElementsByTagName('a')[0]
      var duration = items[3].getElementsByTagName('em')[0]
      var canvas = stat.getElementsByTagName('canvas')[0]
      var report = fragment('<ul id="mocha-report"></ul>')
      var stack = [report]
      var progress
      var ctx
      var root = document.getElementById('mocha')

      if (canvas.getContext) {
        var ratio = window.devicePixelRatio || 1
        canvas.style.width = canvas.width
        canvas.style.height = canvas.height
        canvas.width *= ratio
        canvas.height *= ratio
        ctx = canvas.getContext('2d')
        ctx.scale(ratio, ratio)
        progress = new Progress()
      }

      if (!root) {
        return error('#mocha div missing, add it to your document')
      }

  // pass toggle
      on(passesLink, 'click', function (evt) {
        evt.preventDefault()
        unhide()
        var name = (/pass/).test(report.className) ? '' : ' pass'
        report.className = report.className.replace(/fail|pass/g, '') + name
        if (report.className.trim()) {
          hideSuitesWithout('test pass')
        }
      })

  // failure toggle
      on(failuresLink, 'click', function (evt) {
        evt.preventDefault()
        unhide()
        var name = (/fail/).test(report.className) ? '' : ' fail'
        report.className = report.className.replace(/fail|pass/g, '') + name
        if (report.className.trim()) {
          hideSuitesWithout('test fail')
        }
      })

      root.appendChild(stat)
      root.appendChild(report)

      if (progress) {
        progress.size(40)
      }

      runner.on('suite', function (suite) {
        if (suite.root) {
          return
        }

    // suite
        var url = self.suiteURL(suite)
        var el = fragment('<li class="suite"><h1><a href="%s">%s</a></h1></li>', url, escape(suite.title))

    // container
        stack[0].appendChild(el)
        stack.unshift(document.createElement('ul'))
        el.appendChild(stack[0])
      })

      runner.on('suite end', function (suite) {
        if (suite.root) {
          updateStats()
          return
        }
        stack.shift()
      })

      runner.on('pass', function (test) {
        var url = self.testURL(test)
        var markup = '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> ' +
      '<a href="%s" class="replay">' + playIcon + '</a></h2></li>'
        var el = fragment(markup, test.speed, test.title, test.duration, url)
        self.addCodeToggle(el, test.body)
        appendToStack(el)
        updateStats()
      })

      runner.on('fail', function (test) {
        var el = fragment('<li class="test fail"><h2>%e <a href="%e" class="replay">' + playIcon + '</a></h2></li>',
      test.title, self.testURL(test))
        var stackString // Note: Includes leading newline
        var message = test.err.toString()

    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we
    // check for the result of the stringifying.
        if (message === '[object Error]') {
          message = test.err.message
        }

        if (test.err.stack) {
          var indexOfMessage = test.err.stack.indexOf(test.err.message)
          if (indexOfMessage === -1) {
            stackString = test.err.stack
          } else {
            stackString = test.err.stack.substr(test.err.message.length + indexOfMessage)
          }
        } else if (test.err.sourceURL && test.err.line !== undefined) {
      // Safari doesn't give you a stack. Let's at least provide a source line.
          stackString = '\n(' + test.err.sourceURL + ':' + test.err.line + ')'
        }

        stackString = stackString || ''

        if (test.err.htmlMessage && stackString) {
          el.appendChild(fragment('<div class="html-error">%s\n<pre class="error">%e</pre></div>',
        test.err.htmlMessage, stackString))
        } else if (test.err.htmlMessage) {
          el.appendChild(fragment('<div class="html-error">%s</div>', test.err.htmlMessage))
        } else {
          el.appendChild(fragment('<pre class="error">%e%e</pre>', message, stackString))
        }

        self.addCodeToggle(el, test.body)
        appendToStack(el)
        updateStats()
      })

      runner.on('pending', function (test) {
        var el = fragment('<li class="test pass pending"><h2>%e</h2></li>', test.title)
        appendToStack(el)
        updateStats()
      })

      function appendToStack (el) {
    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.
        if (stack[0]) {
          stack[0].appendChild(el)
        }
      }

      function updateStats () {
    // TODO: add to stats
        var percent = stats.tests / runner.total * 100 | 0
        if (progress) {
          progress.update(percent).draw(ctx)
        }

    // update stats
        var ms = new Date() - stats.start
        text(passes, stats.passes)
        text(failures, stats.failures)
        text(duration, (ms / 1000).toFixed(2))
      }
    }

/**
 * Makes a URL, preserving querystring ("search") parameters.
 *
 * @param {string} s
 * @return {string} A new URL.
 */
    function makeUrl (s) {
      var search = window.location.search

  // Remove previous grep query parameter if present
      if (search) {
        search = search.replace(/[?&]grep=[^&\s]*/g, '').replace(/^&/, '?')
      }

      return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s))
    }

/**
 * Provide suite URL.
 *
 * @param {Object} [suite]
 */
    HTML.prototype.suiteURL = function (suite) {
      return makeUrl(suite.fullTitle())
    }

/**
 * Provide test URL.
 *
 * @param {Object} [test]
 */
    HTML.prototype.testURL = function (test) {
      return makeUrl(test.fullTitle())
    }

/**
 * Adds code toggle functionality for the provided test's list element.
 *
 * @param {HTMLLIElement} el
 * @param {string} contents
 */
    HTML.prototype.addCodeToggle = function (el, contents) {
      var h2 = el.getElementsByTagName('h2')[0]

      on(h2, 'click', function () {
        pre.style.display = pre.style.display === 'none' ? 'block' : 'none'
      })

      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents))
      el.appendChild(pre)
      pre.style.display = 'none'
    }

/**
 * Display error `msg`.
 *
 * @param {string} msg
 */
    function error (msg) {
      document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg))
    }

/**
 * Return a DOM fragment from `html`.
 *
 * @param {string} html
 */
    function fragment (html) {
      var args = arguments
      var div = document.createElement('div')
      var i = 1

      div.innerHTML = html.replace(/%([se])/g, function (_, type) {
        switch (type) {
          case 's': return String(args[i++])
          case 'e': return escape(args[i++])
      // no default
        }
      })

      return div.firstChild
    }

/**
 * Check for suites that do not have elements
 * with `classname`, and hide them.
 *
 * @param {text} classname
 */
    function hideSuitesWithout (classname) {
      var suites = document.getElementsByClassName('suite')
      for (var i = 0; i < suites.length; i++) {
        var els = suites[i].getElementsByClassName(classname)
        if (!els.length) {
          suites[i].className += ' hidden'
        }
      }
    }

/**
 * Unhide .hidden suites.
 */
    function unhide () {
      var els = document.getElementsByClassName('suite hidden')
      for (var i = 0; i < els.length; ++i) {
        els[i].className = els[i].className.replace('suite hidden', 'suite')
      }
    }

/**
 * Set an element's text contents.
 *
 * @param {HTMLElement} el
 * @param {string} contents
 */
    function text (el, contents) {
      if (el.textContent) {
        el.textContent = contents
      } else {
        el.innerText = contents
      }
    }

/**
 * Listen on `event` with callback `fn`.
 */
    function on (el, event, fn) {
      if (el.addEventListener) {
        el.addEventListener(event, fn, false)
      } else {
        el.attachEvent('on' + event, fn)
      }
    }
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, { '../browser/progress': 4, '../utils': 38, './base': 17, 'escape-string-regexp': 61 }], 21: [function (require, module, exports) {
  'use strict'

// Alias exports to a their normalized format Mocha#reporter to prevent a need
// for dynamic (try/catch) requires, which Browserify doesn't handle.
  exports.Base = exports.base = require('./base')
  exports.Dot = exports.dot = require('./dot')
  exports.Doc = exports.doc = require('./doc')
  exports.TAP = exports.tap = require('./tap')
  exports.JSON = exports.json = require('./json')
  exports.HTML = exports.html = require('./html')
  exports.List = exports.list = require('./list')
  exports.Min = exports.min = require('./min')
  exports.Spec = exports.spec = require('./spec')
  exports.Nyan = exports.nyan = require('./nyan')
  exports.XUnit = exports.xunit = require('./xunit')
  exports.Markdown = exports.markdown = require('./markdown')
  exports.Progress = exports.progress = require('./progress')
  exports.Landing = exports.landing = require('./landing')
  exports.JSONStream = exports['json-stream'] = require('./json-stream')
}, { './base': 17, './doc': 18, './dot': 19, './html': 20, './json': 23, './json-stream': 22, './landing': 24, './list': 25, './markdown': 26, './min': 27, './nyan': 28, './progress': 29, './spec': 30, './tap': 31, './xunit': 32 }], 22: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var JSON = require('json3')

/**
 * Expose `List`.
 */

    exports = module.exports = List

/**
 * Initialize a new `List` test reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function List (runner) {
      Base.call(this, runner)

      var self = this
      var total = runner.total

      runner.on('start', function () {
        console.log(JSON.stringify(['start', { total: total }]))
      })

      runner.on('pass', function (test) {
        console.log(JSON.stringify(['pass', clean(test)]))
      })

      runner.on('fail', function (test, err) {
        test = clean(test)
        test.err = err.message
        test.stack = err.stack || null
        console.log(JSON.stringify(['fail', test]))
      })

      runner.on('end', function () {
        process.stdout.write(JSON.stringify(['end', self.stats]))
      })
    }

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @api private
 * @param {Object} test
 * @return {Object}
 */
    function clean (test) {
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        duration: test.duration,
        currentRetry: test.currentRetry()
      }
    }
  }).call(this, require('_process'))
}, { './base': 17, '_process': 82, 'json3': 69 }], 23: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')

/**
 * Expose `JSON`.
 */

    exports = module.exports = JSONReporter

/**
 * Initialize a new `JSON` reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function JSONReporter (runner) {
      Base.call(this, runner)

      var self = this
      var tests = []
      var pending = []
      var failures = []
      var passes = []

      runner.on('test end', function (test) {
        tests.push(test)
      })

      runner.on('pass', function (test) {
        passes.push(test)
      })

      runner.on('fail', function (test) {
        failures.push(test)
      })

      runner.on('pending', function (test) {
        pending.push(test)
      })

      runner.on('end', function () {
        var obj = {
          stats: self.stats,
          tests: tests.map(clean),
          pending: pending.map(clean),
          failures: failures.map(clean),
          passes: passes.map(clean)
        }

        runner.testResults = obj

        process.stdout.write(JSON.stringify(obj, null, 2))
      })
    }

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @api private
 * @param {Object} test
 * @return {Object}
 */
    function clean (test) {
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        duration: test.duration,
        currentRetry: test.currentRetry(),
        err: errorJSON(test.err || {})
      }
    }

/**
 * Transform `error` into a JSON object.
 *
 * @api private
 * @param {Error} err
 * @return {Object}
 */
    function errorJSON (err) {
      var res = {}
      Object.getOwnPropertyNames(err).forEach(function (key) {
        res[key] = err[key]
      }, err)
      return res
    }
  }).call(this, require('_process'))
}, { './base': 17, '_process': 82 }], 24: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var inherits = require('../utils').inherits
    var cursor = Base.cursor
    var color = Base.color

/**
 * Expose `Landing`.
 */

    exports = module.exports = Landing

/**
 * Airplane color.
 */

    Base.colors.plane = 0

/**
 * Airplane crash color.
 */

    Base.colors['plane crash'] = 31

/**
 * Runway color.
 */

    Base.colors.runway = 90

/**
 * Initialize a new `Landing` reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function Landing (runner) {
      Base.call(this, runner)

      var self = this
      var width = Base.window.width * 0.75 | 0
      var total = runner.total
      var stream = process.stdout
      var plane = color('plane', '')
      var crashed = -1
      var n = 0

      function runway () {
        var buf = Array(width).join('-')
        return '  ' + color('runway', buf)
      }

      runner.on('start', function () {
        stream.write('\n\n\n  ')
        cursor.hide()
      })

      runner.on('test end', function (test) {
    // check if the plane crashed
        var col = crashed === -1 ? width * ++n / total | 0 : crashed

    // show the crash
        if (test.state === 'failed') {
          plane = color('plane crash', '')
          crashed = col
        }

    // render landing strip
        stream.write('\u001b[' + (width + 1) + 'D\u001b[2A')
        stream.write(runway())
        stream.write('\n  ')
        stream.write(color('runway', Array(col).join('')))
        stream.write(plane)
        stream.write(color('runway', Array(width - col).join('') + '\n'))
        stream.write(runway())
        stream.write('\u001b[0m')
      })

      runner.on('end', function () {
        cursor.show()
        console.log()
        self.epilogue()
      })
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(Landing, Base)
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 25: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var inherits = require('../utils').inherits
    var color = Base.color
    var cursor = Base.cursor

/**
 * Expose `List`.
 */

    exports = module.exports = List

/**
 * Initialize a new `List` test reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function List (runner) {
      Base.call(this, runner)

      var self = this
      var n = 0

      runner.on('start', function () {
        console.log()
      })

      runner.on('test', function (test) {
        process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '))
      })

      runner.on('pending', function (test) {
        var fmt = color('checkmark', '  -') +
      color('pending', ' %s')
        console.log(fmt, test.fullTitle())
      })

      runner.on('pass', function (test) {
        var fmt = color('checkmark', '  ' + Base.symbols.ok) +
      color('pass', ' %s: ') +
      color(test.speed, '%dms')
        cursor.CR()
        console.log(fmt, test.fullTitle(), test.duration)
      })

      runner.on('fail', function (test) {
        cursor.CR()
        console.log(color('fail', '  %d) %s'), ++n, test.fullTitle())
      })

      runner.on('end', self.epilogue.bind(self))
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(List, Base)
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 26: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var utils = require('../utils')

/**
 * Constants
 */

    var SUITE_PREFIX = '$'

/**
 * Expose `Markdown`.
 */

    exports = module.exports = Markdown

/**
 * Initialize a new `Markdown` reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function Markdown (runner) {
      Base.call(this, runner)

      var level = 0
      var buf = ''

      function title (str) {
        return Array(level).join('#') + ' ' + str
      }

      function mapTOC (suite, obj) {
        var ret = obj
        var key = SUITE_PREFIX + suite.title

        obj = obj[key] = obj[key] || { suite: suite }
        suite.suites.forEach(function (suite) {
          mapTOC(suite, obj)
        })

        return ret
      }

      function stringifyTOC (obj, level) {
        ++level
        var buf = ''
        var link
        for (var key in obj) {
          if (key === 'suite') {
            continue
          }
          if (key !== SUITE_PREFIX) {
            link = ' - [' + key.substring(1) + ']'
            link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\n'
            buf += Array(level).join('  ') + link
          }
          buf += stringifyTOC(obj[key], level)
        }
        return buf
      }

      function generateTOC (suite) {
        var obj = mapTOC(suite, {})
        return stringifyTOC(obj, 0)
      }

      generateTOC(runner.suite)

      runner.on('suite', function (suite) {
        ++level
        var slug = utils.slug(suite.fullTitle())
        buf += '<a name="' + slug + '"></a>' + '\n'
        buf += title(suite.title) + '\n'
      })

      runner.on('suite end', function () {
        --level
      })

      runner.on('pass', function (test) {
        var code = utils.clean(test.body)
        buf += test.title + '.\n'
        buf += '\n```js\n'
        buf += code + '\n'
        buf += '```\n\n'
      })

      runner.on('end', function () {
        process.stdout.write('# TOC\n')
        process.stdout.write(generateTOC(runner.suite))
        process.stdout.write(buf)
      })
    }
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 27: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var inherits = require('../utils').inherits

/**
 * Expose `Min`.
 */

    exports = module.exports = Min

/**
 * Initialize a new `Min` minimal test reporter (best used with --watch).
 *
 * @api public
 * @param {Runner} runner
 */
    function Min (runner) {
      Base.call(this, runner)

      runner.on('start', function () {
    // clear screen
        process.stdout.write('\u001b[2J')
    // set cursor position
        process.stdout.write('\u001b[1;3H')
      })

      runner.on('end', this.epilogue.bind(this))
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(Min, Base)
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 28: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var inherits = require('../utils').inherits

/**
 * Expose `Dot`.
 */

    exports = module.exports = NyanCat

/**
 * Initialize a new `Dot` matrix test reporter.
 *
 * @param {Runner} runner
 * @api public
 */

    function NyanCat (runner) {
      Base.call(this, runner)

      var self = this
      var width = Base.window.width * 0.75 | 0
      var nyanCatWidth = this.nyanCatWidth = 11

      this.colorIndex = 0
      this.numberOfLines = 4
      this.rainbowColors = self.generateColors()
      this.scoreboardWidth = 5
      this.tick = 0
      this.trajectories = [[], [], [], []]
      this.trajectoryWidthMax = (width - nyanCatWidth)

      runner.on('start', function () {
        Base.cursor.hide()
        self.draw()
      })

      runner.on('pending', function () {
        self.draw()
      })

      runner.on('pass', function () {
        self.draw()
      })

      runner.on('fail', function () {
        self.draw()
      })

      runner.on('end', function () {
        Base.cursor.show()
        for (var i = 0; i < self.numberOfLines; i++) {
          write('\n')
        }
        self.epilogue()
      })
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(NyanCat, Base)

/**
 * Draw the nyan cat
 *
 * @api private
 */

    NyanCat.prototype.draw = function () {
      this.appendRainbow()
      this.drawScoreboard()
      this.drawRainbow()
      this.drawNyanCat()
      this.tick = !this.tick
    }

/**
 * Draw the "scoreboard" showing the number
 * of passes, failures and pending tests.
 *
 * @api private
 */

    NyanCat.prototype.drawScoreboard = function () {
      var stats = this.stats

      function draw (type, n) {
        write(' ')
        write(Base.color(type, n))
        write('\n')
      }

      draw('green', stats.passes)
      draw('fail', stats.failures)
      draw('pending', stats.pending)
      write('\n')

      this.cursorUp(this.numberOfLines)
    }

/**
 * Append the rainbow.
 *
 * @api private
 */

    NyanCat.prototype.appendRainbow = function () {
      var segment = this.tick ? '_' : '-'
      var rainbowified = this.rainbowify(segment)

      for (var index = 0; index < this.numberOfLines; index++) {
        var trajectory = this.trajectories[index]
        if (trajectory.length >= this.trajectoryWidthMax) {
          trajectory.shift()
        }
        trajectory.push(rainbowified)
      }
    }

/**
 * Draw the rainbow.
 *
 * @api private
 */

    NyanCat.prototype.drawRainbow = function () {
      var self = this

      this.trajectories.forEach(function (line) {
        write('\u001b[' + self.scoreboardWidth + 'C')
        write(line.join(''))
        write('\n')
      })

      this.cursorUp(this.numberOfLines)
    }

/**
 * Draw the nyan cat
 *
 * @api private
 */
    NyanCat.prototype.drawNyanCat = function () {
      var self = this
      var startWidth = this.scoreboardWidth + this.trajectories[0].length
      var dist = '\u001b[' + startWidth + 'C'
      var padding = ''

      write(dist)
      write('_,------,')
      write('\n')

      write(dist)
      padding = self.tick ? '  ' : '   '
      write('_|' + padding + '/\\_/\\ ')
      write('\n')

      write(dist)
      padding = self.tick ? '_' : '__'
      var tail = self.tick ? '~' : '^'
      write(tail + '|' + padding + this.face() + ' ')
      write('\n')

      write(dist)
      padding = self.tick ? ' ' : '  '
      write(padding + '""  "" ')
      write('\n')

      this.cursorUp(this.numberOfLines)
    }

/**
 * Draw nyan cat face.
 *
 * @api private
 * @return {string}
 */

    NyanCat.prototype.face = function () {
      var stats = this.stats
      if (stats.failures) {
        return '( x .x)'
      } else if (stats.pending) {
        return '( o .o)'
      } else if (stats.passes) {
        return '( ^ .^)'
      }
      return '( - .-)'
    }

/**
 * Move cursor up `n`.
 *
 * @api private
 * @param {number} n
 */

    NyanCat.prototype.cursorUp = function (n) {
      write('\u001b[' + n + 'A')
    }

/**
 * Move cursor down `n`.
 *
 * @api private
 * @param {number} n
 */

    NyanCat.prototype.cursorDown = function (n) {
      write('\u001b[' + n + 'B')
    }

/**
 * Generate rainbow colors.
 *
 * @api private
 * @return {Array}
 */
    NyanCat.prototype.generateColors = function () {
      var colors = []

      for (var i = 0; i < (6 * 7); i++) {
        var pi3 = Math.floor(Math.PI / 3)
        var n = (i * (1.0 / 6))
        var r = Math.floor(3 * Math.sin(n) + 3)
        var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3)
        var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3)
        colors.push(36 * r + 6 * g + b + 16)
      }

      return colors
    }

/**
 * Apply rainbow to the given `str`.
 *
 * @api private
 * @param {string} str
 * @return {string}
 */
    NyanCat.prototype.rainbowify = function (str) {
      if (!Base.useColors) {
        return str
      }
      var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length]
      this.colorIndex += 1
      return '\u001b[38;5;' + color + 'm' + str + '\u001b[0m'
    }

/**
 * Stdout helper.
 *
 * @param {string} string A message to write to stdout.
 */
    function write (string) {
      process.stdout.write(string)
    }
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 29: [function (require, module, exports) {
  (function (process) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var inherits = require('../utils').inherits
    var color = Base.color
    var cursor = Base.cursor

/**
 * Expose `Progress`.
 */

    exports = module.exports = Progress

/**
 * General progress bar color.
 */

    Base.colors.progress = 90

/**
 * Initialize a new `Progress` bar test reporter.
 *
 * @api public
 * @param {Runner} runner
 * @param {Object} options
 */
    function Progress (runner, options) {
      Base.call(this, runner)

      var self = this
      var width = Base.window.width * 0.50 | 0
      var total = runner.total
      var complete = 0
      var lastN = -1

  // default chars
      options = options || {}
      options.open = options.open || '['
      options.complete = options.complete || ''
      options.incomplete = options.incomplete || Base.symbols.dot
      options.close = options.close || ']'
      options.verbose = false

  // tests started
      runner.on('start', function () {
        console.log()
        cursor.hide()
      })

  // tests complete
      runner.on('test end', function () {
        complete++

        var percent = complete / total
        var n = width * percent | 0
        var i = width - n

        if (n === lastN && !options.verbose) {
      // Don't re-render the line if it hasn't changed
          return
        }
        lastN = n

        cursor.CR()
        process.stdout.write('\u001b[J')
        process.stdout.write(color('progress', '  ' + options.open))
        process.stdout.write(Array(n).join(options.complete))
        process.stdout.write(Array(i).join(options.incomplete))
        process.stdout.write(color('progress', options.close))
        if (options.verbose) {
          process.stdout.write(color('progress', ' ' + complete + ' of ' + total))
        }
      })

  // tests are complete, output some stats
  // and the failures if any
      runner.on('end', function () {
        cursor.show()
        console.log()
        self.epilogue()
      })
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(Progress, Base)
  }).call(this, require('_process'))
}, { '../utils': 38, './base': 17, '_process': 82 }], 30: [function (require, module, exports) {
  'use strict'

/**
 * Module dependencies.
 */

  var Base = require('./base')
  var inherits = require('../utils').inherits
  var color = Base.color

/**
 * Expose `Spec`.
 */

  exports = module.exports = Spec

/**
 * Initialize a new `Spec` test reporter.
 *
 * @api public
 * @param {Runner} runner
 */
  function Spec (runner) {
    Base.call(this, runner)

    var self = this
    var indents = 0
    var n = 0

    function indent () {
      return Array(indents).join('  ')
    }

    runner.on('start', function () {
      console.log()
    })

    runner.on('suite', function (suite) {
      ++indents
      console.log(color('suite', '%s%s'), indent(), suite.title)
    })

    runner.on('suite end', function () {
      --indents
      if (indents === 1) {
        console.log()
      }
    })

    runner.on('pending', function (test) {
      var fmt = indent() + color('pending', '  - %s')
      console.log(fmt, test.title)
    })

    runner.on('pass', function (test) {
      var fmt
      if (test.speed === 'fast') {
        fmt = indent() +
        color('checkmark', '  ' + Base.symbols.ok) +
        color('pass', ' %s')
        console.log(fmt, test.title)
      } else {
        fmt = indent() +
        color('checkmark', '  ' + Base.symbols.ok) +
        color('pass', ' %s') +
        color(test.speed, ' (%dms)')
        console.log(fmt, test.title, test.duration)
      }
    })

    runner.on('fail', function (test) {
      console.log(indent() + color('fail', '  %d) %s'), ++n, test.title)
    })

    runner.on('end', self.epilogue.bind(self))
  }

/**
 * Inherit from `Base.prototype`.
 */
  inherits(Spec, Base)
}, { '../utils': 38, './base': 17 }], 31: [function (require, module, exports) {
  'use strict'

/**
 * Module dependencies.
 */

  var Base = require('./base')

/**
 * Expose `TAP`.
 */

  exports = module.exports = TAP

/**
 * Initialize a new `TAP` reporter.
 *
 * @api public
 * @param {Runner} runner
 */
  function TAP (runner) {
    Base.call(this, runner)

    var n = 1
    var passes = 0
    var failures = 0

    runner.on('start', function () {
      var total = runner.grepTotal(runner.suite)
      console.log('%d..%d', 1, total)
    })

    runner.on('test end', function () {
      ++n
    })

    runner.on('pending', function (test) {
      console.log('ok %d %s # SKIP -', n, title(test))
    })

    runner.on('pass', function (test) {
      passes++
      console.log('ok %d %s', n, title(test))
    })

    runner.on('fail', function (test, err) {
      failures++
      console.log('not ok %d %s', n, title(test))
      if (err.stack) {
        console.log(err.stack.replace(/^/gm, '  '))
      }
    })

    runner.on('end', function () {
      console.log('# tests ' + (passes + failures))
      console.log('# pass ' + passes)
      console.log('# fail ' + failures)
    })
  }

/**
 * Return a TAP-safe title of `test`
 *
 * @api private
 * @param {Object} test
 * @return {String}
 */
  function title (test) {
    return test.fullTitle().replace(/#/g, '')
  }
}, { './base': 17 }], 32: [function (require, module, exports) {
  (function (process, global) {
    'use strict'

/**
 * Module dependencies.
 */

    var Base = require('./base')
    var utils = require('../utils')
    var inherits = utils.inherits
    var fs = require('fs')
    var escape = utils.escape
    var mkdirp = require('mkdirp')
    var path = require('path')

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

/* eslint-disable no-unused-vars, no-native-reassign */
    var Date = global.Date
    var setTimeout = global.setTimeout
    var setInterval = global.setInterval
    var clearTimeout = global.clearTimeout
    var clearInterval = global.clearInterval
/* eslint-enable no-unused-vars, no-native-reassign */

/**
 * Expose `XUnit`.
 */

    exports = module.exports = XUnit

/**
 * Initialize a new `XUnit` reporter.
 *
 * @api public
 * @param {Runner} runner
 */
    function XUnit (runner, options) {
      Base.call(this, runner)

      var stats = this.stats
      var tests = []
      var self = this

      if (options && options.reporterOptions && options.reporterOptions.output) {
        if (!fs.createWriteStream) {
          throw new Error('file output not supported in browser')
        }
        mkdirp.sync(path.dirname(options.reporterOptions.output))
        self.fileStream = fs.createWriteStream(options.reporterOptions.output)
      }

      runner.on('pending', function (test) {
        tests.push(test)
      })

      runner.on('pass', function (test) {
        tests.push(test)
      })

      runner.on('fail', function (test) {
        tests.push(test)
      })

      runner.on('end', function () {
        self.write(tag('testsuite', {
          name: 'Mocha Tests',
          tests: stats.tests,
          failures: stats.failures,
          errors: stats.failures,
          skipped: stats.tests - stats.failures - stats.passes,
          timestamp: (new Date()).toUTCString(),
          time: (stats.duration / 1000) || 0
        }, false))

        tests.forEach(function (t) {
          self.test(t)
        })

        self.write('</testsuite>')
      })
    }

/**
 * Inherit from `Base.prototype`.
 */
    inherits(XUnit, Base)

/**
 * Override done to close the stream (if it's a file).
 *
 * @param failures
 * @param {Function} fn
 */
    XUnit.prototype.done = function (failures, fn) {
      if (this.fileStream) {
        this.fileStream.end(function () {
          fn(failures)
        })
      } else {
        fn(failures)
      }
    }

/**
 * Write out the given line.
 *
 * @param {string} line
 */
    XUnit.prototype.write = function (line) {
      if (this.fileStream) {
        this.fileStream.write(line + '\n')
      } else if (typeof process === 'object' && process.stdout) {
        process.stdout.write(line + '\n')
      } else {
        console.log(line)
      }
    }

/**
 * Output tag for the given `test.`
 *
 * @param {Test} test
 */
    XUnit.prototype.test = function (test) {
      var attrs = {
        classname: test.parent.fullTitle(),
        name: test.title,
        time: (test.duration / 1000) || 0
      }

      if (test.state === 'failed') {
        var err = test.err
        this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\n' + escape(err.stack))))
      } else if (test.isPending()) {
        this.write(tag('testcase', attrs, false, tag('skipped', {}, true)))
      } else {
        this.write(tag('testcase', attrs, true))
      }
    }

/**
 * HTML tag helper.
 *
 * @param name
 * @param attrs
 * @param close
 * @param content
 * @return {string}
 */
    function tag (name, attrs, close, content) {
      var end = close ? '/>' : '>'
      var pairs = []
      var tag

      for (var key in attrs) {
        if (Object.prototype.hasOwnProperty.call(attrs, key)) {
          pairs.push(key + '="' + escape(attrs[key]) + '"')
        }
      }

      tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end
      if (content) {
        tag += content + '</' + name + end
      }
      return tag
    }
  }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, { '../utils': 38, './base': 17, '_process': 82, 'fs': 42, 'mkdirp': 79, 'path': 42 }], 33: [function (require, module, exports) {
  (function (global) {
    'use strict'

/**
 * Module dependencies.
 */

    var EventEmitter = require('events').EventEmitter
    var JSON = require('json3')
    var Pending = require('./pending')
    var debug = require('debug')('mocha:runnable')
    var milliseconds = require('./ms')
    var utils = require('./utils')
    var create = require('lodash.create')

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

/* eslint-disable no-unused-vars, no-native-reassign */
    var Date = global.Date
    var setTimeout = global.setTimeout
    var setInterval = global.setInterval
    var clearTimeout = global.clearTimeout
    var clearInterval = global.clearInterval
/* eslint-enable no-unused-vars, no-native-reassign */

/**
 * Object#toString().
 */

    var toString = Object.prototype.toString

/**
 * Expose `Runnable`.
 */

    module.exports = Runnable

/**
 * Initialize a new `Runnable` with the given `title` and callback `fn`.
 *
 * @param {String} title
 * @param {Function} fn
 * @api private
 * @param {string} title
 * @param {Function} fn
 */
    function Runnable (title, fn) {
      this.title = title
      this.fn = fn
      this.body = (fn || '').toString()
      this.async = fn && fn.length
      this.sync = !this.async
      this._timeout = 2000
      this._slow = 75
      this._enableTimeouts = true
      this.timedOut = false
      this._trace = new Error('done() called multiple times')
      this._retries = -1
      this._currentRetry = 0
      this.pending = false
    }

/**
 * Inherit from `EventEmitter.prototype`.
 */
    Runnable.prototype = create(EventEmitter.prototype, {
      constructor: Runnable
    })

/**
 * Set & get timeout `ms`.
 *
 * @api private
 * @param {number|string} ms
 * @return {Runnable|number} ms or Runnable instance.
 */
    Runnable.prototype.timeout = function (ms) {
      if (!arguments.length) {
        return this._timeout
      }
  // see #1652 for reasoning
      if (ms === 0 || ms > Math.pow(2, 31)) {
        this._enableTimeouts = false
      }
      if (typeof ms === 'string') {
        ms = milliseconds(ms)
      }
      debug('timeout %d', ms)
      this._timeout = ms
      if (this.timer) {
        this.resetTimeout()
      }
      return this
    }

/**
 * Set & get slow `ms`.
 *
 * @api private
 * @param {number|string} ms
 * @return {Runnable|number} ms or Runnable instance.
 */
    Runnable.prototype.slow = function (ms) {
      if (typeof ms === 'undefined') {
        return this._slow
      }
      if (typeof ms === 'string') {
        ms = milliseconds(ms)
      }
      debug('timeout %d', ms)
      this._slow = ms
      return this
    }

/**
 * Set and get whether timeout is `enabled`.
 *
 * @api private
 * @param {boolean} enabled
 * @return {Runnable|boolean} enabled or Runnable instance.
 */
    Runnable.prototype.enableTimeouts = function (enabled) {
      if (!arguments.length) {
        return this._enableTimeouts
      }
      debug('enableTimeouts %s', enabled)
      this._enableTimeouts = enabled
      return this
    }

/**
 * Halt and mark as pending.
 *
 * @api public
 */
    Runnable.prototype.skip = function () {
      throw new Pending('sync skip')
    }

/**
 * Check if this runnable or its parent suite is marked as pending.
 *
 * @api private
 */
    Runnable.prototype.isPending = function () {
      return this.pending || (this.parent && this.parent.isPending())
    }

/**
 * Set number of retries.
 *
 * @api private
 */
    Runnable.prototype.retries = function (n) {
      if (!arguments.length) {
        return this._retries
      }
      this._retries = n
    }

/**
 * Get current retry
 *
 * @api private
 */
    Runnable.prototype.currentRetry = function (n) {
      if (!arguments.length) {
        return this._currentRetry
      }
      this._currentRetry = n
    }

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @api public
 * @return {string}
 */
    Runnable.prototype.fullTitle = function () {
      return this.parent.fullTitle() + ' ' + this.title
    }

/**
 * Clear the timeout.
 *
 * @api private
 */
    Runnable.prototype.clearTimeout = function () {
      clearTimeout(this.timer)
    }

/**
 * Inspect the runnable void of private properties.
 *
 * @api private
 * @return {string}
 */
    Runnable.prototype.inspect = function () {
      return JSON.stringify(this, function (key, val) {
        if (key[0] === '_') {
          return
        }
        if (key === 'parent') {
          return '#<Suite>'
        }
        if (key === 'ctx') {
          return '#<Context>'
        }
        return val
      }, 2)
    }

/**
 * Reset the timeout.
 *
 * @api private
 */
    Runnable.prototype.resetTimeout = function () {
      var self = this
      var ms = this.timeout() || 1e9

      if (!this._enableTimeouts) {
        return
      }
      this.clearTimeout()
      this.timer = setTimeout(function () {
        if (!self._enableTimeouts) {
          return
        }
        self.callback(new Error('Timeout of ' + ms +
      'ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.'))
        self.timedOut = true
      }, ms)
    }

/**
 * Whitelist a list of globals for this test run.
 *
 * @api private
 * @param {string[]} globals
 */
    Runnable.prototype.globals = function (globals) {
      if (!arguments.length) {
        return this._allowedGlobals
      }
      this._allowedGlobals = globals
    }

/**
 * Run the test and invoke `fn(err)`.
 *
 * @param {Function} fn
 * @api private
 */
    Runnable.prototype.run = function (fn) {
      var self = this
      var start = new Date()
      var ctx = this.ctx
      var finished
      var emitted

  // Sometimes the ctx exists, but it is not runnable
      if (ctx && ctx.runnable) {
        ctx.runnable(this)
      }

  // called multiple times
      function multiple (err) {
        if (emitted) {
          return
        }
        emitted = true
        self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'))
      }

  // finished
      function done (err) {
        var ms = self.timeout()
        if (self.timedOut) {
          return
        }
        if (finished) {
          return multiple(err || self._trace)
        }

        self.clearTimeout()
        self.duration = new Date() - start
        finished = true
        if (!err && self.duration > ms && self._enableTimeouts) {
          err = new Error('Timeout of ' + ms +
      'ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.')
        }
        fn(err)
      }

  // for .resetTimeout()
      this.callback = done

  // explicit async with `done` argument
      if (this.async) {
        this.resetTimeout()

    // allows skip() to be used in an explicit async context
        this.skip = function asyncSkip () {
          done(new Pending('async skip call'))
      // halt execution.  the Runnable will be marked pending
      // by the previous call, and the uncaught handler will ignore
      // the failure.
          throw new Pending('async skip; aborting execution')
        }

        if (this.allowUncaught) {
          return callFnAsync(this.fn)
        }
        try {
          callFnAsync(this.fn)
        } catch (err) {
          emitted = true
          done(utils.getError(err))
        }
        return
      }

      if (this.allowUncaught) {
        if (this.isPending()) {
          done()
        } else {
          callFn(this.fn)
        }
        return
      }

  // sync or promise-returning
      try {
        if (this.isPending()) {
          done()
        } else {
          callFn(this.fn)
        }
      } catch (err) {
        emitted = true
        done(utils.getError(err))
      }

      function callFn (fn) {
        var result = fn.call(ctx)
        if (result && typeof result.then === 'function') {
          self.resetTimeout()
          result
        .then(function () {
          done()
          // Return null so libraries like bluebird do not warn about
          // subsequently constructed Promises.
          return null
        },
        function (reason) {
          done(reason || new Error('Promise rejected with no or falsy reason'))
        })
        } else {
          if (self.asyncOnly) {
            return done(new Error('--async-only option in use without declaring `done()` or returning a promise'))
          }

          done()
        }
      }

      function callFnAsync (fn) {
        var result = fn.call(ctx, function (err) {
          if (err instanceof Error || toString.call(err) === '[object Error]') {
            return done(err)
          }
          if (err) {
            if (Object.prototype.toString.call(err) === '[object Object]') {
              return done(new Error('done() invoked with non-Error: ' +
            JSON.stringify(err)))
            }
            return done(new Error('done() invoked with non-Error: ' + err))
          }
          if (result && utils.isPromise(result)) {
            return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'))
          }

          done()
        })
      }
    }
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, { './ms': 15, './pending': 16, './utils': 38, 'debug': 2, 'events': 3, 'json3': 69, 'lodash.create': 75 }], 34: [function (require, module, exports) {
  (function (process, global) {
    'use strict'

/**
 * Module dependencies.
 */

    var EventEmitter = require('events').EventEmitter
    var Pending = require('./pending')
    var utils = require('./utils')
    var inherits = utils.inherits
    var debug = require('debug')('mocha:runner')
    var Runnable = require('./runnable')
    var filter = utils.filter
    var indexOf = utils.indexOf
    var some = utils.some
    var keys = utils.keys
    var stackFilter = utils.stackTraceFilter()
    var stringify = utils.stringify
    var type = utils.type
    var undefinedError = utils.undefinedError
    var isArray = utils.isArray

/**
 * Non-enumerable globals.
 */

    var globals = [
      'setTimeout',
      'clearTimeout',
      'setInterval',
      'clearInterval',
      'XMLHttpRequest',
      'Date',
      'setImmediate',
      'clearImmediate'
    ]

/**
 * Expose `Runner`.
 */

    module.exports = Runner

/**
 * Initialize a `Runner` for the given `suite`.
 *
 * Events:
 *
 *   - `start`  execution started
 *   - `end`  execution complete
 *   - `suite`  (suite) test suite execution started
 *   - `suite end`  (suite) all tests (and sub-suites) have finished
 *   - `test`  (test) test execution started
 *   - `test end`  (test) test completed
 *   - `hook`  (hook) hook execution started
 *   - `hook end`  (hook) hook complete
 *   - `pass`  (test) test passed
 *   - `fail`  (test, err) test failed
 *   - `pending`  (test) test pending
 *
 * @api public
 * @param {Suite} suite Root suite
 * @param {boolean} [delay] Whether or not to delay execution of root suite
 * until ready.
 */
    function Runner (suite, delay) {
      var self = this
      this._globals = []
      this._abort = false
      this._delay = delay
      this.suite = suite
      this.started = false
      this.total = suite.total()
      this.failures = 0
      this.on('test end', function (test) {
        self.checkGlobals(test)
      })
      this.on('hook end', function (hook) {
        self.checkGlobals(hook)
      })
      this._defaultGrep = /.*/
      this.grep(this._defaultGrep)
      this.globals(this.globalProps().concat(extraGlobals()))
    }

/**
 * Wrapper for setImmediate, process.nextTick, or browser polyfill.
 *
 * @param {Function} fn
 * @api private
 */
    Runner.immediately = global.setImmediate || process.nextTick

/**
 * Inherit from `EventEmitter.prototype`.
 */
    inherits(Runner, EventEmitter)

/**
 * Run tests with full titles matching `re`. Updates runner.total
 * with number of tests matched.
 *
 * @param {RegExp} re
 * @param {Boolean} invert
 * @return {Runner} for chaining
 * @api public
 * @param {RegExp} re
 * @param {boolean} invert
 * @return {Runner} Runner instance.
 */
    Runner.prototype.grep = function (re, invert) {
      debug('grep %s', re)
      this._grep = re
      this._invert = invert
      this.total = this.grepTotal(this.suite)
      return this
    }

/**
 * Returns the number of tests matching the grep search for the
 * given suite.
 *
 * @param {Suite} suite
 * @return {Number}
 * @api public
 * @param {Suite} suite
 * @return {number}
 */
    Runner.prototype.grepTotal = function (suite) {
      var self = this
      var total = 0

      suite.eachTest(function (test) {
        var match = self._grep.test(test.fullTitle())
        if (self._invert) {
          match = !match
        }
        if (match) {
          total++
        }
      })

      return total
    }

/**
 * Return a list of global properties.
 *
 * @return {Array}
 * @api private
 */
    Runner.prototype.globalProps = function () {
      var props = keys(global)

  // non-enumerables
      for (var i = 0; i < globals.length; ++i) {
        if (~indexOf(props, globals[i])) {
          continue
        }
        props.push(globals[i])
      }

      return props
    }

/**
 * Allow the given `arr` of globals.
 *
 * @param {Array} arr
 * @return {Runner} for chaining
 * @api public
 * @param {Array} arr
 * @return {Runner} Runner instance.
 */
    Runner.prototype.globals = function (arr) {
      if (!arguments.length) {
        return this._globals
      }
      debug('globals %j', arr)
      this._globals = this._globals.concat(arr)
      return this
    }

/**
 * Check for global variable leaks.
 *
 * @api private
 */
    Runner.prototype.checkGlobals = function (test) {
      if (this.ignoreLeaks) {
        return
      }
      var ok = this._globals

      var globals = this.globalProps()
      var leaks

      if (test) {
        ok = ok.concat(test._allowedGlobals || [])
      }

      if (this.prevGlobalsLength === globals.length) {
        return
      }
      this.prevGlobalsLength = globals.length

      leaks = filterLeaks(ok, globals)
      this._globals = this._globals.concat(leaks)

      if (leaks.length > 1) {
        this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''))
      } else if (leaks.length) {
        this.fail(test, new Error('global leak detected: ' + leaks[0]))
      }
    }

/**
 * Fail the given `test`.
 *
 * @api private
 * @param {Test} test
 * @param {Error} err
 */
    Runner.prototype.fail = function (test, err) {
      if (test.isPending()) {
        return
      }

      ++this.failures
      test.state = 'failed'

      if (!(err instanceof Error || err && typeof err.message === 'string')) {
        err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)')
      }

      try {
        err.stack = (this.fullStackTrace || !err.stack)
      ? err.stack
      : stackFilter(err.stack)
      } catch (ignored) {
    // some environments do not take kindly to monkeying with the stack
      }

      this.emit('fail', test, err)
    }

/**
 * Fail the given `hook` with `err`.
 *
 * Hook failures work in the following pattern:
 * - If bail, then exit
 * - Failed `before` hook skips all tests in a suite and subsuites,
 *   but jumps to corresponding `after` hook
 * - Failed `before each` hook skips remaining tests in a
 *   suite and jumps to corresponding `after each` hook,
 *   which is run only once
 * - Failed `after` hook does not alter
 *   execution order
 * - Failed `after each` hook skips remaining tests in a
 *   suite and subsuites, but executes other `after each`
 *   hooks
 *
 * @api private
 * @param {Hook} hook
 * @param {Error} err
 */
    Runner.prototype.failHook = function (hook, err) {
      if (hook.ctx && hook.ctx.currentTest) {
        hook.originalTitle = hook.originalTitle || hook.title
        hook.title = hook.originalTitle + ' for "' + hook.ctx.currentTest.title + '"'
      }

      this.fail(hook, err)
      if (this.suite.bail()) {
        this.emit('end')
      }
    }

/**
 * Run hook `name` callbacks and then invoke `fn()`.
 *
 * @api private
 * @param {string} name
 * @param {Function} fn
 */

    Runner.prototype.hook = function (name, fn) {
      var suite = this.suite
      var hooks = suite['_' + name]
      var self = this

      function next (i) {
        var hook = hooks[i]
        if (!hook) {
          return fn()
        }
        self.currentRunnable = hook

        hook.ctx.currentTest = self.test

        self.emit('hook', hook)

        if (!hook.listeners('error').length) {
          hook.on('error', function (err) {
            self.failHook(hook, err)
          })
        }

        hook.run(function (err) {
          var testError = hook.error()
          if (testError) {
            self.fail(self.test, testError)
          }
          if (err) {
            if (err instanceof Pending) {
              if (name === 'beforeEach' || name === 'afterEach') {
                self.test.pending = true
              } else {
                utils.forEach(suite.tests, function (test) {
                  test.pending = true
                })
            // a pending hook won't be executed twice.
                hook.pending = true
              }
            } else {
              self.failHook(hook, err)

          // stop executing hooks, notify callee of hook err
              return fn(err)
            }
          }
          self.emit('hook end', hook)
          delete hook.ctx.currentTest
          next(++i)
        })
      }

      Runner.immediately(function () {
        next(0)
      })
    }

/**
 * Run hook `name` for the given array of `suites`
 * in order, and callback `fn(err, errSuite)`.
 *
 * @api private
 * @param {string} name
 * @param {Array} suites
 * @param {Function} fn
 */
    Runner.prototype.hooks = function (name, suites, fn) {
      var self = this
      var orig = this.suite

      function next (suite) {
        self.suite = suite

        if (!suite) {
          self.suite = orig
          return fn()
        }

        self.hook(name, function (err) {
          if (err) {
            var errSuite = self.suite
            self.suite = orig
            return fn(err, errSuite)
          }

          next(suites.pop())
        })
      }

      next(suites.pop())
    }

/**
 * Run hooks from the top level down.
 *
 * @param {String} name
 * @param {Function} fn
 * @api private
 */
    Runner.prototype.hookUp = function (name, fn) {
      var suites = [this.suite].concat(this.parents()).reverse()
      this.hooks(name, suites, fn)
    }

/**
 * Run hooks from the bottom up.
 *
 * @param {String} name
 * @param {Function} fn
 * @api private
 */
    Runner.prototype.hookDown = function (name, fn) {
      var suites = [this.suite].concat(this.parents())
      this.hooks(name, suites, fn)
    }

/**
 * Return an array of parent Suites from
 * closest to furthest.
 *
 * @return {Array}
 * @api private
 */
    Runner.prototype.parents = function () {
      var suite = this.suite
      var suites = []
      while (suite.parent) {
        suite = suite.parent
        suites.push(suite)
      }
      return suites
    }

/**
 * Run the current test and callback `fn(err)`.
 *
 * @param {Function} fn
 * @api private
 */
    Runner.prototype.runTest = function (fn) {
      var self = this
      var test = this.test

      if (!test) {
        return
      }
      if (this.asyncOnly) {
        test.asyncOnly = true
      }
      test.on('error', function (err) {
        self.fail(test, err)
      })
      if (this.allowUncaught) {
        test.allowUncaught = true
        return test.run(fn)
      }
      try {
        test.run(fn)
      } catch (err) {
        fn(err)
      }
    }

/**
 * Run tests in the given `suite` and invoke the callback `fn()` when complete.
 *
 * @api private
 * @param {Suite} suite
 * @param {Function} fn
 */
    Runner.prototype.runTests = function (suite, fn) {
      var self = this
      var tests = suite.tests.slice()
      var test

      function hookErr (_, errSuite, after) {
    // before/after Each hook for errSuite failed:
        var orig = self.suite

    // for failed 'after each' hook start from errSuite parent,
    // otherwise start from errSuite itself
        self.suite = after ? errSuite.parent : errSuite

        if (self.suite) {
      // call hookUp afterEach
          self.hookUp('afterEach', function (err2, errSuite2) {
            self.suite = orig
        // some hooks may fail even now
            if (err2) {
              return hookErr(err2, errSuite2, true)
            }
        // report error suite
            fn(errSuite)
          })
        } else {
      // there is no need calling other 'after each' hooks
          self.suite = orig
          fn(errSuite)
        }
      }

      function next (err, errSuite) {
    // if we bail after first err
        if (self.failures && suite._bail) {
          return fn()
        }

        if (self._abort) {
          return fn()
        }

        if (err) {
          return hookErr(err, errSuite, true)
        }

    // next test
        test = tests.shift()

    // all done
        if (!test) {
          return fn()
        }

    // grep
        var match = self._grep.test(test.fullTitle())
        if (self._invert) {
          match = !match
        }
        if (!match) {
      // Run immediately only if we have defined a grep. When we
      // define a grep  It can cause maximum callstack error if
      // the grep is doing a large recursive loop by neglecting
      // all tests. The run immediately function also comes with
      // a performance cost. So we don't want to run immediately
      // if we run the whole test suite, because running the whole
      // test suite don't do any immediate recursive loops. Thus,
      // allowing a JS runtime to breathe.
          if (self._grep !== self._defaultGrep) {
            Runner.immediately(next)
          } else {
            next()
          }
          return
        }

        if (test.isPending()) {
          self.emit('pending', test)
          self.emit('test end', test)
          return next()
        }

    // execute test and hook(s)
        self.emit('test', self.test = test)
        self.hookDown('beforeEach', function (err, errSuite) {
          if (test.isPending()) {
            self.emit('pending', test)
            self.emit('test end', test)
            return next()
          }
          if (err) {
            return hookErr(err, errSuite, false)
          }
          self.currentRunnable = self.test
          self.runTest(function (err) {
            test = self.test
            if (err) {
              var retry = test.currentRetry()
              if (err instanceof Pending) {
                test.pending = true
                self.emit('pending', test)
              } else if (retry < test.retries()) {
                var clonedTest = test.clone()
                clonedTest.currentRetry(retry + 1)
                tests.unshift(clonedTest)

            // Early return + hook trigger so that it doesn't
            // increment the count wrong
                return self.hookUp('afterEach', next)
              } else {
                self.fail(test, err)
              }
              self.emit('test end', test)

              if (err instanceof Pending) {
                return next()
              }

              return self.hookUp('afterEach', next)
            }

            test.state = 'passed'
            self.emit('pass', test)
            self.emit('test end', test)
            self.hookUp('afterEach', next)
          })
        })
      }

      this.next = next
      this.hookErr = hookErr
      next()
    }

/**
 * Run the given `suite` and invoke the callback `fn()` when complete.
 *
 * @api private
 * @param {Suite} suite
 * @param {Function} fn
 */
    Runner.prototype.runSuite = function (suite, fn) {
      var i = 0
      var self = this
      var total = this.grepTotal(suite)
      var afterAllHookCalled = false

      debug('run suite %s', suite.fullTitle())

      if (!total || (self.failures && suite._bail)) {
        return fn()
      }

      this.emit('suite', this.suite = suite)

      function next (errSuite) {
        if (errSuite) {
      // current suite failed on a hook from errSuite
          if (errSuite === suite) {
        // if errSuite is current suite
        // continue to the next sibling suite
            return done()
          }
      // errSuite is among the parents of current suite
      // stop execution of errSuite and all sub-suites
          return done(errSuite)
        }

        if (self._abort) {
          return done()
        }

        var curr = suite.suites[i++]
        if (!curr) {
          return done()
        }

    // Avoid grep neglecting large number of tests causing a
    // huge recursive loop and thus a maximum call stack error.
    // See comment in `this.runTests()` for more information.
        if (self._grep !== self._defaultGrep) {
          Runner.immediately(function () {
            self.runSuite(curr, next)
          })
        } else {
          self.runSuite(curr, next)
        }
      }

      function done (errSuite) {
        self.suite = suite
        self.nextSuite = next

        if (afterAllHookCalled) {
          fn(errSuite)
        } else {
      // mark that the afterAll block has been called once
      // and so can be skipped if there is an error in it.
          afterAllHookCalled = true

      // remove reference to test
          delete self.test

          self.hook('afterAll', function () {
            self.emit('suite end', suite)
            fn(errSuite)
          })
        }
      }

      this.nextSuite = next

      this.hook('beforeAll', function (err) {
        if (err) {
          return done()
        }
        self.runTests(suite, next)
      })
    }

/**
 * Handle uncaught exceptions.
 *
 * @param {Error} err
 * @api private
 */
    Runner.prototype.uncaught = function (err) {
      if (err) {
        debug('uncaught exception %s', err === (function () {
          return this
        }.call(err)) ? (err.message || err) : err)
      } else {
        debug('uncaught undefined exception')
        err = undefinedError()
      }
      err.uncaught = true

      var runnable = this.currentRunnable

      if (!runnable) {
        runnable = new Runnable('Uncaught error outside test suite')
        runnable.parent = this.suite

        if (this.started) {
          this.fail(runnable, err)
        } else {
      // Can't recover from this failure
          this.emit('start')
          this.fail(runnable, err)
          this.emit('end')
        }

        return
      }

      runnable.clearTimeout()

  // Ignore errors if complete or pending
      if (runnable.state || runnable.isPending()) {
        return
      }
      this.fail(runnable, err)

  // recover from test
      if (runnable.type === 'test') {
        this.emit('test end', runnable)
        this.hookUp('afterEach', this.next)
        return
      }

 // recover from hooks
      if (runnable.type === 'hook') {
        var errSuite = this.suite
    // if hook failure is in afterEach block
        if (runnable.fullTitle().indexOf('after each') > -1) {
          return this.hookErr(err, errSuite, true)
        }
    // if hook failure is in beforeEach block
        if (runnable.fullTitle().indexOf('before each') > -1) {
          return this.hookErr(err, errSuite, false)
        }
    // if hook failure is in after or before blocks
        return this.nextSuite(errSuite)
      }

  // bail
      this.emit('end')
    }

/**
 * Cleans up the references to all the deferred functions
 * (before/after/beforeEach/afterEach) and tests of a Suite.
 * These must be deleted otherwise a memory leak can happen,
 * as those functions may reference variables from closures,
 * thus those variables can never be garbage collected as long
 * as the deferred functions exist.
 *
 * @param {Suite} suite
 */
    function cleanSuiteReferences (suite) {
      function cleanArrReferences (arr) {
        for (var i = 0; i < arr.length; i++) {
          delete arr[i].fn
        }
      }

      if (isArray(suite._beforeAll)) {
        cleanArrReferences(suite._beforeAll)
      }

      if (isArray(suite._beforeEach)) {
        cleanArrReferences(suite._beforeEach)
      }

      if (isArray(suite._afterAll)) {
        cleanArrReferences(suite._afterAll)
      }

      if (isArray(suite._afterEach)) {
        cleanArrReferences(suite._afterEach)
      }

      for (var i = 0; i < suite.tests.length; i++) {
        delete suite.tests[i].fn
      }
    }

/**
 * Run the root suite and invoke `fn(failures)`
 * on completion.
 *
 * @param {Function} fn
 * @return {Runner} for chaining
 * @api public
 * @param {Function} fn
 * @return {Runner} Runner instance.
 */
    Runner.prototype.run = function (fn) {
      var self = this
      var rootSuite = this.suite

  // If there is an `only` filter
      if (this.hasOnly) {
        filterOnly(rootSuite)
      }

      fn = fn || function () {}

      function uncaught (err) {
        self.uncaught(err)
      }

      function start () {
        self.started = true
        self.emit('start')
        self.runSuite(rootSuite, function () {
          debug('finished running')
          self.emit('end')
        })
      }

      debug('start')

  // references cleanup to avoid memory leaks
      this.on('suite end', cleanSuiteReferences)

  // callback
      this.on('end', function () {
        if (self.forbidOnly && self.hasOnly) {
          self.failures += self.stats.tests
        }
        if (self.forbidPending) {
          self.failures += self.stats.pending
        }
        debug('end')
        process.removeListener('uncaughtException', uncaught)
        fn(self.failures)
      })

  // uncaught exception
      process.on('uncaughtException', uncaught)

      if (this._delay) {
    // for reporters, I guess.
    // might be nice to debounce some dots while we wait.
        this.emit('waiting', rootSuite)
        rootSuite.once('run', start)
      } else {
        start()
      }

      return this
    }

/**
 * Cleanly abort execution.
 *
 * @api public
 * @return {Runner} Runner instance.
 */
    Runner.prototype.abort = function () {
      debug('aborting')
      this._abort = true

      return this
    }

/**
 * Filter suites based on `isOnly` logic.
 *
 * @param {Array} suite
 * @returns {Boolean}
 * @api private
 */
    function filterOnly (suite) {
      if (suite._onlyTests.length) {
    // If the suite contains `only` tests, run those and ignore any nested suites.
        suite.tests = suite._onlyTests
        suite.suites = []
      } else {
    // Otherwise, do not run any of the tests in this suite.
        suite.tests = []
        utils.forEach(suite._onlySuites, function (onlySuite) {
      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.
      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.
          if (hasOnly(onlySuite)) {
            filterOnly(onlySuite)
          }
        })
    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.
        suite.suites = filter(suite.suites, function (childSuite) {
          return indexOf(suite._onlySuites, childSuite) !== -1 || filterOnly(childSuite)
        })
      }
  // Keep the suite only if there is something to run
      return suite.tests.length || suite.suites.length
    }

/**
 * Determines whether a suite has an `only` test or suite as a descendant.
 *
 * @param {Array} suite
 * @returns {Boolean}
 * @api private
 */
    function hasOnly (suite) {
      return suite._onlyTests.length || suite._onlySuites.length || some(suite.suites, hasOnly)
    }

/**
 * Filter leaks with the given globals flagged as `ok`.
 *
 * @api private
 * @param {Array} ok
 * @param {Array} globals
 * @return {Array}
 */
    function filterLeaks (ok, globals) {
      return filter(globals, function (key) {
    // Firefox and Chrome exposes iframes as index inside the window object
        if (/^\d+/.test(key)) {
          return false
        }

    // in firefox
    // if runner runs in an iframe, this iframe's window.getInterface method
    // not init at first it is assigned in some seconds
        if (global.navigator && (/^getInterface/).test(key)) {
          return false
        }

    // an iframe could be approached by window[iframeIndex]
    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
        if (global.navigator && (/^\d+/).test(key)) {
          return false
        }

    // Opera and IE expose global variables for HTML element IDs (issue #243)
        if (/^mocha-/.test(key)) {
          return false
        }

        var matched = filter(ok, function (ok) {
          if (~ok.indexOf('*')) {
            return key.indexOf(ok.split('*')[0]) === 0
          }
          return key === ok
        })
        return !matched.length && (!global.navigator || key !== 'onerror')
      })
    }

/**
 * Array of globals dependent on the environment.
 *
 * @return {Array}
 * @api private
 */
    function extraGlobals () {
      if (typeof process === 'object' && typeof process.version === 'string') {
        var parts = process.version.split('.')
        var nodeVersion = utils.reduce(parts, function (a, v) {
          return a << 8 | v
        })

    // 'errno' was renamed to process._errno in v0.9.11.

        if (nodeVersion < 0x00090B) {
          return ['errno']
        }
      }

      return []
    }
  }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, { './pending': 16, './runnable': 33, './utils': 38, '_process': 82, 'debug': 2, 'events': 3 }], 35: [function (require, module, exports) {
  'use strict'

/**
 * Module dependencies.
 */

  var EventEmitter = require('events').EventEmitter
  var Hook = require('./hook')
  var utils = require('./utils')
  var inherits = utils.inherits
  var debug = require('debug')('mocha:suite')
  var milliseconds = require('./ms')

/**
 * Expose `Suite`.
 */

  exports = module.exports = Suite

/**
 * Create a new `Suite` with the given `title` and parent `Suite`. When a suite
 * with the same title is already present, that suite is returned to provide
 * nicer reporter and more flexible meta-testing.
 *
 * @api public
 * @param {Suite} parent
 * @param {string} title
 * @return {Suite}
 */
  exports.create = function (parent, title) {
    var suite = new Suite(title, parent.ctx)
    suite.parent = parent
    title = suite.fullTitle()
    parent.addSuite(suite)
    return suite
  }

/**
 * Initialize a new `Suite` with the given `title` and `ctx`.
 *
 * @api private
 * @param {string} title
 * @param {Context} parentContext
 */
  function Suite (title, parentContext) {
    if (!utils.isString(title)) {
      throw new Error('Suite `title` should be a "string" but "' + typeof title + '" was given instead.')
    }
    this.title = title
    function Context () {}
    Context.prototype = parentContext
    this.ctx = new Context()
    this.suites = []
    this.tests = []
    this.pending = false
    this._beforeEach = []
    this._beforeAll = []
    this._afterEach = []
    this._afterAll = []
    this.root = !title
    this._timeout = 2000
    this._enableTimeouts = true
    this._slow = 75
    this._bail = false
    this._retries = -1
    this._onlyTests = []
    this._onlySuites = []
    this.delayed = false
  }

/**
 * Inherit from `EventEmitter.prototype`.
 */
  inherits(Suite, EventEmitter)

/**
 * Return a clone of this `Suite`.
 *
 * @api private
 * @return {Suite}
 */
  Suite.prototype.clone = function () {
    var suite = new Suite(this.title)
    debug('clone')
    suite.ctx = this.ctx
    suite.timeout(this.timeout())
    suite.retries(this.retries())
    suite.enableTimeouts(this.enableTimeouts())
    suite.slow(this.slow())
    suite.bail(this.bail())
    return suite
  }

/**
 * Set timeout `ms` or short-hand such as "2s".
 *
 * @api private
 * @param {number|string} ms
 * @return {Suite|number} for chaining
 */
  Suite.prototype.timeout = function (ms) {
    if (!arguments.length) {
      return this._timeout
    }
    if (ms.toString() === '0') {
      this._enableTimeouts = false
    }
    if (typeof ms === 'string') {
      ms = milliseconds(ms)
    }
    debug('timeout %d', ms)
    this._timeout = parseInt(ms, 10)
    return this
  }

/**
 * Set number of times to retry a failed test.
 *
 * @api private
 * @param {number|string} n
 * @return {Suite|number} for chaining
 */
  Suite.prototype.retries = function (n) {
    if (!arguments.length) {
      return this._retries
    }
    debug('retries %d', n)
    this._retries = parseInt(n, 10) || 0
    return this
  }

/**
  * Set timeout to `enabled`.
  *
  * @api private
  * @param {boolean} enabled
  * @return {Suite|boolean} self or enabled
  */
  Suite.prototype.enableTimeouts = function (enabled) {
    if (!arguments.length) {
      return this._enableTimeouts
    }
    debug('enableTimeouts %s', enabled)
    this._enableTimeouts = enabled
    return this
  }

/**
 * Set slow `ms` or short-hand such as "2s".
 *
 * @api private
 * @param {number|string} ms
 * @return {Suite|number} for chaining
 */
  Suite.prototype.slow = function (ms) {
    if (!arguments.length) {
      return this._slow
    }
    if (typeof ms === 'string') {
      ms = milliseconds(ms)
    }
    debug('slow %d', ms)
    this._slow = ms
    return this
  }

/**
 * Sets whether to bail after first error.
 *
 * @api private
 * @param {boolean} bail
 * @return {Suite|number} for chaining
 */
  Suite.prototype.bail = function (bail) {
    if (!arguments.length) {
      return this._bail
    }
    debug('bail %s', bail)
    this._bail = bail
    return this
  }

/**
 * Check if this suite or its parent suite is marked as pending.
 *
 * @api private
 */
  Suite.prototype.isPending = function () {
    return this.pending || (this.parent && this.parent.isPending())
  }

/**
 * Run `fn(test[, done])` before running tests.
 *
 * @api private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
  Suite.prototype.beforeAll = function (title, fn) {
    if (this.isPending()) {
      return this
    }
    if (typeof title === 'function') {
      fn = title
      title = fn.name
    }
    title = '"before all" hook' + (title ? ': ' + title : '')

    var hook = new Hook(title, fn)
    hook.parent = this
    hook.timeout(this.timeout())
    hook.retries(this.retries())
    hook.enableTimeouts(this.enableTimeouts())
    hook.slow(this.slow())
    hook.ctx = this.ctx
    this._beforeAll.push(hook)
    this.emit('beforeAll', hook)
    return this
  }

/**
 * Run `fn(test[, done])` after running tests.
 *
 * @api private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
  Suite.prototype.afterAll = function (title, fn) {
    if (this.isPending()) {
      return this
    }
    if (typeof title === 'function') {
      fn = title
      title = fn.name
    }
    title = '"after all" hook' + (title ? ': ' + title : '')

    var hook = new Hook(title, fn)
    hook.parent = this
    hook.timeout(this.timeout())
    hook.retries(this.retries())
    hook.enableTimeouts(this.enableTimeouts())
    hook.slow(this.slow())
    hook.ctx = this.ctx
    this._afterAll.push(hook)
    this.emit('afterAll', hook)
    return this
  }

/**
 * Run `fn(test[, done])` before each test case.
 *
 * @api private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
  Suite.prototype.beforeEach = function (title, fn) {
    if (this.isPending()) {
      return this
    }
    if (typeof title === 'function') {
      fn = title
      title = fn.name
    }
    title = '"before each" hook' + (title ? ': ' + title : '')

    var hook = new Hook(title, fn)
    hook.parent = this
    hook.timeout(this.timeout())
    hook.retries(this.retries())
    hook.enableTimeouts(this.enableTimeouts())
    hook.slow(this.slow())
    hook.ctx = this.ctx
    this._beforeEach.push(hook)
    this.emit('beforeEach', hook)
    return this
  }

/**
 * Run `fn(test[, done])` after each test case.
 *
 * @api private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
  Suite.prototype.afterEach = function (title, fn) {
    if (this.isPending()) {
      return this
    }
    if (typeof title === 'function') {
      fn = title
      title = fn.name
    }
    title = '"after each" hook' + (title ? ': ' + title : '')

    var hook = new Hook(title, fn)
    hook.parent = this
    hook.timeout(this.timeout())
    hook.retries(this.retries())
    hook.enableTimeouts(this.enableTimeouts())
    hook.slow(this.slow())
    hook.ctx = this.ctx
    this._afterEach.push(hook)
    this.emit('afterEach', hook)
    return this
  }

/**
 * Add a test `suite`.
 *
 * @api private
 * @param {Suite} suite
 * @return {Suite} for chaining
 */
  Suite.prototype.addSuite = function (suite) {
    suite.parent = this
    suite.timeout(this.timeout())
    suite.retries(this.retries())
    suite.enableTimeouts(this.enableTimeouts())
    suite.slow(this.slow())
    suite.bail(this.bail())
    this.suites.push(suite)
    this.emit('suite', suite)
    return this
  }

/**
 * Add a `test` to this suite.
 *
 * @api private
 * @param {Test} test
 * @return {Suite} for chaining
 */
  Suite.prototype.addTest = function (test) {
    test.parent = this
    test.timeout(this.timeout())
    test.retries(this.retries())
    test.enableTimeouts(this.enableTimeouts())
    test.slow(this.slow())
    test.ctx = this.ctx
    this.tests.push(test)
    this.emit('test', test)
    return this
  }

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @api public
 * @return {string}
 */
  Suite.prototype.fullTitle = function () {
    if (this.parent) {
      var full = this.parent.fullTitle()
      if (full) {
        return full + ' ' + this.title
      }
    }
    return this.title
  }

/**
 * Return the total number of tests.
 *
 * @api public
 * @return {number}
 */
  Suite.prototype.total = function () {
    return utils.reduce(this.suites, function (sum, suite) {
      return sum + suite.total()
    }, 0) + this.tests.length
  }

/**
 * Iterates through each suite recursively to find all tests. Applies a
 * function in the format `fn(test)`.
 *
 * @api private
 * @param {Function} fn
 * @return {Suite}
 */
  Suite.prototype.eachTest = function (fn) {
    utils.forEach(this.tests, fn)
    utils.forEach(this.suites, function (suite) {
      suite.eachTest(fn)
    })
    return this
  }

/**
 * This will run the root suite if we happen to be running in delayed mode.
 */
  Suite.prototype.run = function run () {
    if (this.root) {
      this.emit('run')
    }
  }
}, { './hook': 7, './ms': 15, './utils': 38, 'debug': 2, 'events': 3 }], 36: [function (require, module, exports) {
  'use strict'

/**
 * Module dependencies.
 */

  var Runnable = require('./runnable')
  var create = require('lodash.create')
  var isString = require('./utils').isString

/**
 * Expose `Test`.
 */

  module.exports = Test

/**
 * Initialize a new `Test` with the given `title` and callback `fn`.
 *
 * @api private
 * @param {String} title
 * @param {Function} fn
 */
  function Test (title, fn) {
    if (!isString(title)) {
      throw new Error('Test `title` should be a "string" but "' + typeof title + '" was given instead.')
    }
    Runnable.call(this, title, fn)
    this.pending = !fn
    this.type = 'test'
  }

/**
 * Inherit from `Runnable.prototype`.
 */
  Test.prototype = create(Runnable.prototype, {
    constructor: Test
  })

  Test.prototype.clone = function () {
    var test = new Test(this.title, this.fn)
    test.timeout(this.timeout())
    test.slow(this.slow())
    test.enableTimeouts(this.enableTimeouts())
    test.retries(this.retries())
    test.currentRetry(this.currentRetry())
    test.globals(this.globals())
    test.parent = this.parent
    test.file = this.file
    test.ctx = this.ctx
    return test
  }
}, { './runnable': 33, './utils': 38, 'lodash.create': 75 }], 37: [function (require, module, exports) {
  'use strict'

/**
 * Pad a `number` with a ten's place zero.
 *
 * @param {number} number
 * @return {string}
 */
  function pad (number) {
    var n = number.toString()
    return n.length === 1 ? '0' + n : n
  }

/**
 * Turn a `date` into an ISO string.
 *
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString
 *
 * @param {Date} date
 * @return {string}
 */
  function toISOString (date) {
    return date.getUTCFullYear() +
    '-' + pad(date.getUTCMonth() + 1) +
    '-' + pad(date.getUTCDate()) +
    'T' + pad(date.getUTCHours()) +
    ':' + pad(date.getUTCMinutes()) +
    ':' + pad(date.getUTCSeconds()) +
    '.' + String((date.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5) +
    'Z'
  }

/*
 * Exports.
 */

  module.exports = toISOString
}, {}], 38: [function (require, module, exports) {
  (function (process, Buffer) {
    'use strict'

/* eslint-env browser */

/**
 * Module dependencies.
 */

    var JSON = require('json3')
    var basename = require('path').basename
    var debug = require('debug')('mocha:watch')
    var exists = require('fs').existsSync || require('path').existsSync
    var glob = require('glob')
    var path = require('path')
    var join = path.join
    var readdirSync = require('fs').readdirSync
    var statSync = require('fs').statSync
    var watchFile = require('fs').watchFile
    var lstatSync = require('fs').lstatSync
    var toISOString = require('./to-iso-string')
    var he = require('he')

/**
 * Ignored directories.
 */

    var ignore = ['node_modules', '.git']

    exports.inherits = require('util').inherits

/**
 * Escape special characters in the given string of html.
 *
 * @api private
 * @param  {string} html
 * @return {string}
 */
    exports.escape = function (html) {
      return he.encode(String(html), { useNamedReferences: false })
    }

/**
 * Array#forEach (<=IE8)
 *
 * @api private
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object} scope
 */
    exports.forEach = function (arr, fn, scope) {
      for (var i = 0, l = arr.length; i < l; i++) {
        fn.call(scope, arr[i], i)
      }
    }

/**
 * Test if the given obj is type of string.
 *
 * @api private
 * @param {Object} obj
 * @return {boolean}
 */
    exports.isString = function (obj) {
      return typeof obj === 'string'
    }

/**
 * Array#map (<=IE8)
 *
 * @api private
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object} scope
 * @return {Array}
 */
    exports.map = function (arr, fn, scope) {
      var result = []
      for (var i = 0, l = arr.length; i < l; i++) {
        result.push(fn.call(scope, arr[i], i, arr))
      }
      return result
    }

/**
 * Array#indexOf (<=IE8)
 *
 * @api private
 * @param {Array} arr
 * @param {Object} obj to find index of
 * @param {number} start
 * @return {number}
 */
    var indexOf = exports.indexOf = function (arr, obj, start) {
      for (var i = start || 0, l = arr.length; i < l; i++) {
        if (arr[i] === obj) {
          return i
        }
      }
      return -1
    }

/**
 * Array#reduce (<=IE8)
 *
 * @api private
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object} val Initial value.
 * @return {*}
 */
    var reduce = exports.reduce = function (arr, fn, val) {
      var rval = val

      for (var i = 0, l = arr.length; i < l; i++) {
        rval = fn(rval, arr[i], i, arr)
      }

      return rval
    }

/**
 * Array#filter (<=IE8)
 *
 * @api private
 * @param {Array} arr
 * @param {Function} fn
 * @return {Array}
 */
    exports.filter = function (arr, fn) {
      var ret = []

      for (var i = 0, l = arr.length; i < l; i++) {
        var val = arr[i]
        if (fn(val, i, arr)) {
          ret.push(val)
        }
      }

      return ret
    }

/**
 * Array#some (<=IE8)
 *
 * @api private
 * @param {Array} arr
 * @param {Function} fn
 * @return {Array}
 */
    exports.some = function (arr, fn) {
      for (var i = 0, l = arr.length; i < l; i++) {
        if (fn(arr[i])) {
          return true
        }
      }
      return false
    }

/**
 * Object.keys (<=IE8)
 *
 * @api private
 * @param {Object} obj
 * @return {Array} keys
 */
    exports.keys = typeof Object.keys === 'function' ? Object.keys : function (obj) {
      var keys = []
      var has = Object.prototype.hasOwnProperty // for `window` on <=IE8

      for (var key in obj) {
        if (has.call(obj, key)) {
          keys.push(key)
        }
      }

      return keys
    }

/**
 * Watch the given `files` for changes
 * and invoke `fn(file)` on modification.
 *
 * @api private
 * @param {Array} files
 * @param {Function} fn
 */
    exports.watch = function (files, fn) {
      var options = { interval: 100 }
      files.forEach(function (file) {
        debug('file %s', file)
        watchFile(file, options, function (curr, prev) {
          if (prev.mtime < curr.mtime) {
            fn(file)
          }
        })
      })
    }

/**
 * Array.isArray (<=IE8)
 *
 * @api private
 * @param {Object} obj
 * @return {Boolean}
 */
    var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]'
    }

    exports.isArray = isArray

/**
 * Buffer.prototype.toJSON polyfill.
 *
 * @type {Function}
 */
    if (typeof Buffer !== 'undefined' && Buffer.prototype) {
      Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {
        return Array.prototype.slice.call(this, 0)
      }
    }

/**
 * Ignored files.
 *
 * @api private
 * @param {string} path
 * @return {boolean}
 */
    function ignored (path) {
      return !~ignore.indexOf(path)
    }

/**
 * Lookup files in the given `dir`.
 *
 * @api private
 * @param {string} dir
 * @param {string[]} [ext=['.js']]
 * @param {Array} [ret=[]]
 * @return {Array}
 */
    exports.files = function (dir, ext, ret) {
      ret = ret || []
      ext = ext || ['js']

      var re = new RegExp('\\.(' + ext.join('|') + ')$')

      readdirSync(dir)
    .filter(ignored)
    .forEach(function (path) {
      path = join(dir, path)
      if (lstatSync(path).isDirectory()) {
        exports.files(path, ext, ret)
      } else if (path.match(re)) {
        ret.push(path)
      }
    })

      return ret
    }

/**
 * Compute a slug from the given `str`.
 *
 * @api private
 * @param {string} str
 * @return {string}
 */
    exports.slug = function (str) {
      return str
    .toLowerCase()
    .replace(/ +/g, '-')
    .replace(/[^-\w]/g, '')
    }

/**
 * Strip the function definition from `str`, and re-indent for pre whitespace.
 *
 * @param {string} str
 * @return {string}
 */
    exports.clean = function (str) {
      str = str
    .replace(/\r\n?|[\n\u2028\u2029]/g, '\n').replace(/^\uFEFF/, '')
    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content
    .replace(/^function(?:\s*|\s+[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\s*\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\s*\}|((?:.|\n)*))$/, '$1$2$3')

      var spaces = str.match(/^\n?( *)/)[1].length
      var tabs = str.match(/^\n?(\t*)/)[1].length
      var re = new RegExp('^\n?' + (tabs ? '\t' : ' ') + '{' + (tabs || spaces) + '}', 'gm')

      str = str.replace(re, '')

      return exports.trim(str)
    }

/**
 * Trim the given `str`.
 *
 * @api private
 * @param {string} str
 * @return {string}
 */
    exports.trim = function (str) {
      return str.replace(/^\s+|\s+$/g, '')
    }

/**
 * Parse the given `qs`.
 *
 * @api private
 * @param {string} qs
 * @return {Object}
 */
    exports.parseQuery = function (qs) {
      return reduce(qs.replace('?', '').split('&'), function (obj, pair) {
        var i = pair.indexOf('=')
        var key = pair.slice(0, i)
        var val = pair.slice(++i)

    // Due to how the URLSearchParams API treats spaces
        obj[key] = decodeURIComponent(val.replace(/\+/g, '%20'))

        return obj
      }, {})
    }

/**
 * Highlight the given string of `js`.
 *
 * @api private
 * @param {string} js
 * @return {string}
 */
    function highlight (js) {
      return js
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
    .replace(/('.*?')/gm, '<span class="string">$1</span>')
    .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
    .replace(/(\d+)/gm, '<span class="number">$1</span>')
    .replace(/\bnew[ \t]+(\w+)/gm, '<span class="keyword">new</span> <span class="init">$1</span>')
    .replace(/\b(function|new|throw|return|var|if|else)\b/gm, '<span class="keyword">$1</span>')
    }

/**
 * Highlight the contents of tag `name`.
 *
 * @api private
 * @param {string} name
 */
    exports.highlightTags = function (name) {
      var code = document.getElementById('mocha').getElementsByTagName(name)
      for (var i = 0, len = code.length; i < len; ++i) {
        code[i].innerHTML = highlight(code[i].innerHTML)
      }
    }

/**
 * If a value could have properties, and has none, this function is called,
 * which returns a string representation of the empty value.
 *
 * Functions w/ no properties return `'[Function]'`
 * Arrays w/ length === 0 return `'[]'`
 * Objects w/ no properties return `'{}'`
 * All else: return result of `value.toString()`
 *
 * @api private
 * @param {*} value The value to inspect.
 * @param {string} typeHint The type of the value
 * @returns {string}
 */
    function emptyRepresentation (value, typeHint) {
      switch (typeHint) {
        case 'function':
          return '[Function]'
        case 'object':
          return '{}'
        case 'array':
          return '[]'
        default:
          return value.toString()
      }
    }

/**
 * Takes some variable and asks `Object.prototype.toString()` what it thinks it
 * is.
 *
 * @api private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
 * @param {*} value The value to test.
 * @returns {string} Computed type
 * @example
 * type({}) // 'object'
 * type([]) // 'array'
 * type(1) // 'number'
 * type(false) // 'boolean'
 * type(Infinity) // 'number'
 * type(null) // 'null'
 * type(new Date()) // 'date'
 * type(/foo/) // 'regexp'
 * type('type') // 'string'
 * type(global) // 'global'
 * type(new String('foo') // 'object'
 */
    var type = exports.type = function type (value) {
      if (value === undefined) {
        return 'undefined'
      } else if (value === null) {
        return 'null'
      } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
        return 'buffer'
      }
      return Object.prototype.toString.call(value)
    .replace(/^\[.+\s(.+?)]$/, '$1')
    .toLowerCase()
    }

/**
 * Stringify `value`. Different behavior depending on type of value:
 *
 * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.
 * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.
 * - If `value` is an *empty* object, function, or array, return result of function
 *   {@link emptyRepresentation}.
 * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of
 *   JSON.stringify().
 *
 * @api private
 * @see exports.type
 * @param {*} value
 * @return {string}
 */
    exports.stringify = function (value) {
      var typeHint = type(value)

      if (!~indexOf(['object', 'array', 'function'], typeHint)) {
        if (typeHint === 'buffer') {
          var json = value.toJSON()
      // Based on the toJSON result
          return jsonStringify(json.data && json.type ? json.data : json, 2)
        .replace(/,(\n|$)/g, '$1')
        }

    // IE7/IE8 has a bizarre String constructor; needs to be coerced
    // into an array and back to obj.
        if (typeHint === 'string' && typeof value === 'object') {
          value = reduce(value.split(''), function (acc, char, idx) {
            acc[idx] = char
            return acc
          }, {})
          typeHint = 'object'
        } else {
          return jsonStringify(value)
        }
      }

      for (var prop in value) {
        if (Object.prototype.hasOwnProperty.call(value, prop)) {
          return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\n|$)/g, '$1')
        }
      }

      return emptyRepresentation(value, typeHint)
    }

/**
 * like JSON.stringify but more sense.
 *
 * @api private
 * @param {Object}  object
 * @param {number=} spaces
 * @param {number=} depth
 * @returns {*}
 */
    function jsonStringify (object, spaces, depth) {
      if (typeof spaces === 'undefined') {
    // primitive types
        return _stringify(object)
      }

      depth = depth || 1
      var space = spaces * depth
      var str = isArray(object) ? '[' : '{'
      var end = isArray(object) ? ']' : '}'
      var length = typeof object.length === 'number' ? object.length : exports.keys(object).length
  // `.repeat()` polyfill
      function repeat (s, n) {
        return new Array(n).join(s)
      }

      function _stringify (val) {
        switch (type(val)) {
          case 'null':
          case 'undefined':
            val = '[' + val + ']'
            break
          case 'array':
          case 'object':
            val = jsonStringify(val, spaces, depth + 1)
            break
          case 'boolean':
          case 'regexp':
          case 'symbol':
          case 'number':
            val = val === 0 && (1 / val) === -Infinity // `-0`
          ? '-0'
          : val.toString()
            break
          case 'date':
            var sDate
            if (isNaN(val.getTime())) { // Invalid date
              sDate = val.toString()
            } else {
              sDate = val.toISOString ? val.toISOString() : toISOString(val)
            }
            val = '[Date: ' + sDate + ']'
            break
          case 'buffer':
            var json = val.toJSON()
        // Based on the toJSON result
            json = json.data && json.type ? json.data : json
            val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']'
            break
          default:
            val = (val === '[Function]' || val === '[Circular]')
          ? val
          : JSON.stringify(val) // string
        }
        return val
      }

      for (var i in object) {
        if (!Object.prototype.hasOwnProperty.call(object, i)) {
          continue // not my business
        }
        --length
        str += '\n ' + repeat(' ', space) +
      (isArray(object) ? '' : '"' + i + '": ') + // key
      _stringify(object[i]) +                    // value
      (length ? ',' : '')                       // comma
      }

      return str +
    // [], {}
    (str.length !== 1 ? '\n' + repeat(' ', --space) + end : end)
    }

/**
 * Test if a value is a buffer.
 *
 * @api private
 * @param {*} value The value to test.
 * @return {boolean} True if `value` is a buffer, otherwise false
 */
    exports.isBuffer = function (value) {
      return typeof Buffer !== 'undefined' && Buffer.isBuffer(value)
    }

/**
 * Return a new Thing that has the keys in sorted order. Recursive.
 *
 * If the Thing...
 * - has already been seen, return string `'[Circular]'`
 * - is `undefined`, return string `'[undefined]'`
 * - is `null`, return value `null`
 * - is some other primitive, return the value
 * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method
 * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.
 * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`
 *
 * @api private
 * @see {@link exports.stringify}
 * @param {*} value Thing to inspect.  May or may not have properties.
 * @param {Array} [stack=[]] Stack of seen values
 * @param {string} [typeHint] Type hint
 * @return {(Object|Array|Function|string|undefined)}
 */
    exports.canonicalize = function canonicalize (value, stack, typeHint) {
      var canonicalizedObj
  /* eslint-disable no-unused-vars */
      var prop
  /* eslint-enable no-unused-vars */
      typeHint = typeHint || type(value)
      function withStack (value, fn) {
        stack.push(value)
        fn()
        stack.pop()
      }

      stack = stack || []

      if (indexOf(stack, value) !== -1) {
        return '[Circular]'
      }

      switch (typeHint) {
        case 'undefined':
        case 'buffer':
        case 'null':
          canonicalizedObj = value
          break
        case 'array':
          withStack(value, function () {
            canonicalizedObj = exports.map(value, function (item) {
              return exports.canonicalize(item, stack)
            })
          })
          break
        case 'function':
      /* eslint-disable guard-for-in */
          for (prop in value) {
            canonicalizedObj = {}
            break
          }
      /* eslint-enable guard-for-in */
          if (!canonicalizedObj) {
            canonicalizedObj = emptyRepresentation(value, typeHint)
            break
          }
    /* falls through */
        case 'object':
          canonicalizedObj = canonicalizedObj || {}
          withStack(value, function () {
            exports.forEach(exports.keys(value).sort(), function (key) {
              canonicalizedObj[key] = exports.canonicalize(value[key], stack)
            })
          })
          break
        case 'date':
        case 'number':
        case 'regexp':
        case 'boolean':
        case 'symbol':
          canonicalizedObj = value
          break
        default:
          canonicalizedObj = value + ''
      }

      return canonicalizedObj
    }

/**
 * Lookup file names at the given `path`.
 *
 * @api public
 * @param {string} path Base path to start searching from.
 * @param {string[]} extensions File extensions to look for.
 * @param {boolean} recursive Whether or not to recurse into subdirectories.
 * @return {string[]} An array of paths.
 */
    exports.lookupFiles = function lookupFiles (path, extensions, recursive) {
      var files = []
      var re = new RegExp('\\.(' + extensions.join('|') + ')$')

      if (!exists(path)) {
        if (exists(path + '.js')) {
          path += '.js'
        } else {
          files = glob.sync(path)
          if (!files.length) {
            throw new Error("cannot resolve path (or pattern) '" + path + "'")
          }
          return files
        }
      }

      try {
        var stat = statSync(path)
        if (stat.isFile()) {
          return path
        }
      } catch (err) {
    // ignore error
        return
      }

      readdirSync(path).forEach(function (file) {
        file = join(path, file)
        try {
          var stat = statSync(file)
          if (stat.isDirectory()) {
            if (recursive) {
              files = files.concat(lookupFiles(file, extensions, recursive))
            }
            return
          }
        } catch (err) {
      // ignore error
          return
        }
        if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {
          return
        }
        files.push(file)
      })

      return files
    }

/**
 * Generate an undefined error with a message warning the user.
 *
 * @return {Error}
 */

    exports.undefinedError = function () {
      return new Error('Caught undefined error, did you throw without specifying what?')
    }

/**
 * Generate an undefined error if `err` is not defined.
 *
 * @param {Error} err
 * @return {Error}
 */

    exports.getError = function (err) {
      return err || exports.undefinedError()
    }

/**
 * @summary
 * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)
 * @description
 * When invoking this function you get a filter function that get the Error.stack as an input,
 * and return a prettify output.
 * (i.e: strip Mocha and internal node functions from stack trace).
 * @returns {Function}
 */
    exports.stackTraceFilter = function () {
  // TODO: Replace with `process.browser`
      var is = typeof document === 'undefined' ? { node: true } : { browser: true }
      var slash = path.sep
      var cwd
      if (is.node) {
        cwd = process.cwd() + slash
      } else {
        cwd = (typeof location === 'undefined'
      ? window.location
      : location).href.replace(/\/[^/]*$/, '/')
        slash = '/'
      }

      function isMochaInternal (line) {
        return (~line.indexOf('node_modules' + slash + 'mocha' + slash)) ||
      (~line.indexOf('node_modules' + slash + 'mocha.js')) ||
      (~line.indexOf('bower_components' + slash + 'mocha.js')) ||
      (~line.indexOf(slash + 'mocha.js'))
      }

      function isNodeInternal (line) {
        return (~line.indexOf('(timers.js:')) ||
      (~line.indexOf('(events.js:')) ||
      (~line.indexOf('(node.js:')) ||
      (~line.indexOf('(module.js:')) ||
      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||
      false
      }

      return function (stack) {
        stack = stack.split('\n')

        stack = reduce(stack, function (list, line) {
          if (isMochaInternal(line)) {
            return list
          }

          if (is.node && isNodeInternal(line)) {
            return list
          }

      // Clean up cwd(absolute)
          if (/\(?.+:\d+:\d+\)?$/.test(line)) {
            line = line.replace(cwd, '')
          }

          list.push(line)
          return list
        }, [])

        return stack.join('\n')
      }
    }

/**
 * Crude, but effective.
 * @api
 * @param {*} value
 * @returns {boolean} Whether or not `value` is a Promise
 */
    exports.isPromise = function isPromise (value) {
      return typeof value === 'object' && typeof value.then === 'function'
    }

/**
 * It's a noop.
 * @api
 */
    exports.noop = function () {}
  }).call(this, require('_process'), require('buffer').Buffer)
}, { './to-iso-string': 37, '_process': 82, 'buffer': 43, 'debug': 2, 'fs': 42, 'glob': 42, 'he': 64, 'json3': 69, 'path': 42, 'util': 102 }], 39: [function (require, module, exports) {
  'use strict'

  exports.byteLength = byteLength
  exports.toByteArray = toByteArray
  exports.fromByteArray = fromByteArray

  var lookup = []
  var revLookup = []
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63

  function placeHoldersCount (b64) {
    var len = b64.length
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
  }

  function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
    return (b64.length * 3 / 4) - placeHoldersCount(b64)
  }

  function toByteArray (b64) {
    var i, l, tmp, placeHolders, arr
    var len = b64.length
    placeHolders = placeHoldersCount(b64)

    arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len

    var L = 0

    for (i = 0; i < l; i += 4) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
      arr[L++] = (tmp >> 16) & 0xFF
      arr[L++] = (tmp >> 8) & 0xFF
      arr[L++] = tmp & 0xFF
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
      arr[L++] = tmp & 0xFF
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
      arr[L++] = (tmp >> 8) & 0xFF
      arr[L++] = tmp & 0xFF
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp
    var output = []
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
      output.push(tripletToBase64(tmp))
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    var tmp
    var len = uint8.length
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    var output = ''
    var parts = []
    var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
    }

  // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1]
      output += lookup[tmp >> 2]
      output += lookup[(tmp << 4) & 0x3F]
      output += '=='
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
      output += lookup[tmp >> 10]
      output += lookup[(tmp >> 4) & 0x3F]
      output += lookup[(tmp << 2) & 0x3F]
      output += '='
    }

    parts.push(output)

    return parts.join('')
  }
}, {}], 40: [function (require, module, exports) {

}, {}], 41: [function (require, module, exports) {
  (function (process) {
    var WritableStream = require('stream').Writable
    var inherits = require('util').inherits

    module.exports = BrowserStdout

    inherits(BrowserStdout, WritableStream)

    function BrowserStdout (opts) {
      if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)

      opts = opts || {}
      WritableStream.call(this, opts)
      this.label = (opts.label !== undefined) ? opts.label : 'stdout'
    }

    BrowserStdout.prototype._write = function (chunks, encoding, cb) {
      var output = chunks.toString ? chunks.toString() : chunks
      if (this.label === false) {
        console.log(output)
      } else {
        console.log(this.label + ':', output)
      }
      process.nextTick(cb)
    }
  }).call(this, require('_process'))
}, { '_process': 82, 'stream': 96, 'util': 102 }], 42: [function (require, module, exports) {
  arguments[4][40][0].apply(exports, arguments)
}, { 'dup': 40 }], 43: [function (require, module, exports) {
  (function (global) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

    'use strict'

    var base64 = require('base64-js')
    var ieee754 = require('ieee754')
    var isArray = require('isarray')

    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
    exports.kMaxLength = kMaxLength()

    function typedArraySupport () {
      try {
        var arr = new Uint8Array(1)
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
        return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
      } catch (e) {
        return false
      }
    }

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length)
        that.__proto__ = Buffer.prototype
      } else {
    // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length)
        }
        that.length = length
      }

      return that
    }

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

  // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype
      return arr
    }

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype
      Buffer.__proto__ = Uint8Array
      if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        })
      }
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
        return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    }

    function allocUnsafe (that, size) {
      assertSize(size)
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0
        }
      }
      return that
    }

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    }
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    }

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0
      that = createBuffer(that, length)

      var actual = that.write(string, encoding)

      if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual)
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0
      that = createBuffer(that, length)
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array)
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset)
      } else {
        array = new Uint8Array(array, byteOffset, length)
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
        that = array
        that.__proto__ = Buffer.prototype
      } else {
    // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array)
      }
      return that
    }

    function fromObject (that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0
        that = createBuffer(that, len)

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len)
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }

    Buffer.isBuffer = function isBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length
      var y = b.length

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    }

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }

      var buffer = Buffer.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list.length; ++i) {
        var buf = list[i]
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }

    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string
      }

      var len = string.length
      if (len === 0) return 0

  // Use a for loop to avoid recursion
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength

    function slowToString (encoding, start, end) {
      var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length
      }

      if (end <= 0) {
        return ''
      }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8'

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
    Buffer.prototype._isBuffer = true

    function swap (b, n, m) {
      var i = b[n]
      b[n] = b[m]
      b[m] = i
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }

    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }

    Buffer.prototype.inspect = function inspect () {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
        if (this.length > max) str += ' ... '
      }
      return '<Buffer ' + str + '>'
    }

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0

      if (this === target) return 0

      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)

      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    }

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
      if (buffer.length === 0) return -1

  // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset  // Coerce to Number.
      if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }

  // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }

  // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1
      var arrLength = arr.length
      var valLength = val.length

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i
      if (dir) {
        var foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          var found = true
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }

  // must be an even number of digits
      var strLen = string.length
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
  // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
  // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
  // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
      }

      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8'

      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
        // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []

      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }

        if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }

        res.push(codePoint)
        i += bytesPerSequence
      }

      return decodeCodePointsArray(res)
    }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

  // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length

      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len

      var out = ''
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i])
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end

      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }

      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }

      if (end < start) end = start

      var newBuf
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer(sliceLen, undefined)
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start]
        }
      }

      return newBuf
    }

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)

      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }

      return val
    }

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }

      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }

      return val
    }

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
    }

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
    }

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)

      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80

      if (val >= mul) val -= Math.pow(2, 8 * byteLength)

      return val
    }

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)

      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80

      if (val >= mul) val -= Math.pow(2, 8 * byteLength)

      return val
    }

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
    }

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
    }

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }

    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }

      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }

      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      this[offset] = (value & 0xff)
      return offset + 1
    }

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24)
        this[offset + 2] = (value >>> 16)
        this[offset + 1] = (value >>> 8)
        this[offset] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)

        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }

      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)

        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }

      var i = byteLength - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        this[offset + 2] = (value >>> 16)
        this[offset + 3] = (value >>> 24)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }

      var len = end - start
      var i

      if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
      }

      return len
    }

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if (code < 256) {
            val = code
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255
      }

  // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0

      if (!val) val = 0

      var i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
        var len = bytes.length
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }

      return this
    }

// HELPER FUNCTIONS
// ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

    function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

    // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
          if (!leadSurrogate) {
        // no lead yet
            if (codePoint > 0xDBFF) {
          // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
          // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }

        // valid lead
            leadSurrogate = codePoint

            continue
          }

      // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }

      // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }

        leadSurrogate = null

    // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }

      return byteArray
    }

    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, { 'base64-js': 39, 'ieee754': 65, 'isarray': 68 }], 44: [function (require, module, exports) {
  (function (Buffer) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

    function isArray (arg) {
      if (Array.isArray) {
        return Array.isArray(arg)
      }
      return objectToString(arg) === '[object Array]'
    }
    exports.isArray = isArray

    function isBoolean (arg) {
      return typeof arg === 'boolean'
    }
    exports.isBoolean = isBoolean

    function isNull (arg) {
      return arg === null
    }
    exports.isNull = isNull

    function isNullOrUndefined (arg) {
      return arg == null
    }
    exports.isNullOrUndefined = isNullOrUndefined

    function isNumber (arg) {
      return typeof arg === 'number'
    }
    exports.isNumber = isNumber

    function isString (arg) {
      return typeof arg === 'string'
    }
    exports.isString = isString

    function isSymbol (arg) {
      return typeof arg === 'symbol'
    }
    exports.isSymbol = isSymbol

    function isUndefined (arg) {
      return arg === void 0
    }
    exports.isUndefined = isUndefined

    function isRegExp (re) {
      return objectToString(re) === '[object RegExp]'
    }
    exports.isRegExp = isRegExp

    function isObject (arg) {
      return typeof arg === 'object' && arg !== null
    }
    exports.isObject = isObject

    function isDate (d) {
      return objectToString(d) === '[object Date]'
    }
    exports.isDate = isDate

    function isError (e) {
      return (objectToString(e) === '[object Error]' || e instanceof Error)
    }
    exports.isError = isError

    function isFunction (arg) {
      return typeof arg === 'function'
    }
    exports.isFunction = isFunction

    function isPrimitive (arg) {
      return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined'
    }
    exports.isPrimitive = isPrimitive

    exports.isBuffer = Buffer.isBuffer

    function objectToString (o) {
      return Object.prototype.toString.call(o)
    }
  }).call(this, { 'isBuffer': require('../../is-buffer/index.js') })
}, { '../../is-buffer/index.js': 67 }], 45: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.convertChangesToDMP = convertChangesToDMP
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
  function convertChangesToDMP (changes) {
    var ret = [],
      change = /* istanbul ignore start*/void 0 /* istanbul ignore end*/,
      operation = /* istanbul ignore start*/void 0 /* istanbul ignore end*/
    for (var i = 0; i < changes.length; i++) {
      change = changes[i]
      if (change.added) {
        operation = 1
      } else if (change.removed) {
        operation = -1
      } else {
        operation = 0
      }

      ret.push([operation, change.value])
    }
    return ret
  }
}, {}], 46: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.convertChangesToXML = convertChangesToXML
  function convertChangesToXML (changes) {
    var ret = []
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i]
      if (change.added) {
        ret.push('<ins>')
      } else if (change.removed) {
        ret.push('<del>')
      }

      ret.push(escapeHTML(change.value))

      if (change.added) {
        ret.push('</ins>')
      } else if (change.removed) {
        ret.push('</del>')
      }
    }
    return ret.join('')
  }

  function escapeHTML (s) {
    var n = s
    n = n.replace(/&/g, '&amp;')
    n = n.replace(/</g, '&lt;')
    n = n.replace(/>/g, '&gt;')
    n = n.replace(/"/g, '&quot;')

    return n
  }
}, {}], 47: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.arrayDiff = undefined
  exports.diffArrays = diffArrays

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  /* istanbul ignore end*/var arrayDiff = /* istanbul ignore start*/exports.arrayDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
  arrayDiff.tokenize = arrayDiff.join = function (value) {
    return value.slice()
  }

  function diffArrays (oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback)
  }
}, { './base': 48 }], 48: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports['default'] = /* istanbul ignore end*/Diff
  function Diff () {}

  Diff.prototype = { /* istanbul ignore start*/
    /* istanbul ignore end*/diff: function diff (oldString, newString) {
      /* istanbul ignore start*/var /* istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2]

      var callback = options.callback
      if (typeof options === 'function') {
        callback = options
        options = {}
      }
      this.options = options

      var self = this

      function done (value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value)
          }, 0)
          return true
        } else {
          return value
        }
      }

    // Allow subclasses to massage the input prior to running
      oldString = this.castInput(oldString)
      newString = this.castInput(newString)

      oldString = this.removeEmpty(this.tokenize(oldString))
      newString = this.removeEmpty(this.tokenize(newString))

      var newLen = newString.length,
        oldLen = oldString.length
      var editLength = 1
      var maxEditLength = newLen + oldLen
      var bestPath = [{ newPos: -1, components: [] }]

    // Seed editLength = 0, i.e. the content starts with the same values
      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0)
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
        return done([{ value: this.join(newString), count: newString.length }])
      }

    // Main worker method. checks all permutations of a given edit length for acceptance.
      function execEditLength () {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = /* istanbul ignore start*/void 0 /* istanbul ignore end*/
          var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath
          if (addPath) {
          // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined
          }

          var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && _oldPos >= 0 && _oldPos < oldLen
          if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined
            continue
          }

        // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath)
            self.pushComponent(basePath.components, undefined, true)
          } else {
            basePath = addPath // No need to clone, we've pulled it from the list
            basePath.newPos++
            self.pushComponent(basePath.components, true, undefined)
          }

          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath)

        // If we have hit the end of both strings, then we are done
          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken))
          } else {
          // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath
          }
        }

        editLength++
      }

    // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.
      if (callback) {
        (function exec () {
          setTimeout(function () {
          // This should not happen, but we want to be safe.
          /* istanbul ignore next */
            if (editLength > maxEditLength) {
              return callback()
            }

            if (!execEditLength()) {
              exec()
            }
          }, 0)
        })()
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength()
          if (ret) {
            return ret
          }
        }
      }
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/pushComponent: function pushComponent (components, added, removed) {
      var last = components[components.length - 1]
      if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
        components[components.length - 1] = { count: last.count + 1, added: added, removed: removed }
      } else {
        components.push({ count: 1, added: added, removed: removed })
      }
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/extractCommon: function extractCommon (basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0
      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++
        oldPos++
        commonCount++
      }

      if (commonCount) {
        basePath.components.push({ count: commonCount })
      }

      basePath.newPos = newPos
      return oldPos
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/equals: function equals (left, right) {
      return left === right
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/removeEmpty: function removeEmpty (array) {
      var ret = []
      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i])
        }
      }
      return ret
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/castInput: function castInput (value) {
      return value
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/tokenize: function tokenize (value) {
      return value.split('')
    },
    /* istanbul ignore start*/ /* istanbul ignore end*/join: function join (chars) {
      return chars.join('')
    }
  }

  function buildValues (diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0

    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos]
      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count)
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i]
            return oldValue.length > value.length ? oldValue : value
          })

          component.value = diff.join(value)
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count))
        }
        newPos += component.count

      // Common case
        if (!component.added) {
          oldPos += component.count
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count))
        oldPos += component.count

      // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.
        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1]
          components[componentPos - 1] = components[componentPos]
          components[componentPos] = tmp
        }
      }
    }

  // Special case handle for when one terminal is ignored. For this case we merge the
  // terminal into the prior string and drop the change.
    var lastComponent = components[componentLen - 1]
    if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value
      components.pop()
    }

    return components
  }

  function clonePath (path) {
    return { newPos: path.newPos, components: path.components.slice(0) }
  }
}, {}], 49: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.characterDiff = undefined
  exports.diffChars = diffChars

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  /* istanbul ignore end*/var characterDiff = /* istanbul ignore start*/exports.characterDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
  function diffChars (oldStr, newStr, callback) {
    return characterDiff.diff(oldStr, newStr, callback)
  }
}, { './base': 48 }], 50: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.cssDiff = undefined
  exports.diffCss = diffCss

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  /* istanbul ignore end*/var cssDiff = /* istanbul ignore start*/exports.cssDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/)
  }

  function diffCss (oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback)
  }
}, { './base': 48 }], 51: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.jsonDiff = undefined

  var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj }

  exports.diffJson = diffJson
  /* istanbul ignore start*/exports.canonicalize = canonicalize

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

/* istanbul ignore end*/
  var /* istanbul ignore start*/_line = require('./line') /* istanbul ignore end*/

/* istanbul ignore start*/
  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

/* istanbul ignore end*/

  var objectPrototypeToString = Object.prototype.toString

  var jsonDiff = /* istanbul ignore start*/exports.jsonDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
  jsonDiff.useLongestToken = true

  jsonDiff.tokenize = /* istanbul ignore start*/_line.lineDiff.tokenize
  jsonDiff.castInput = function (value) {
    /* istanbul ignore start*/var /* istanbul ignore end*/undefinedReplacement = this.options.undefinedReplacement

    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function (k, v) {
      if (typeof v === 'undefined') {
        return undefinedReplacement
      }

      return v
    }, '  ')
  }
  jsonDiff.equals = function (left, right) {
    return (/* istanbul ignore start*/_base2['default'].prototype.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
  )
  }

  function diffJson (oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options)
  }

// This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed.
  function canonicalize (obj, stack, replacementStack) {
    stack = stack || []
    replacementStack = replacementStack || []

    var i = /* istanbul ignore start*/void 0 /* istanbul ignore end*/

    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i]
      }
    }

    var canonicalizedObj = /* istanbul ignore start*/void 0 /* istanbul ignore end*/

    if (objectPrototypeToString.call(obj) === '[object Array]') {
      stack.push(obj)
      canonicalizedObj = new Array(obj.length)
      replacementStack.push(canonicalizedObj)
      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack)
      }
      stack.pop()
      replacementStack.pop()
      return canonicalizedObj
    }

    if (obj && obj.toJSON) {
      obj = obj.toJSON()
    }

    if (/* istanbul ignore start*/(typeof /* istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
      stack.push(obj)
      canonicalizedObj = {}
      replacementStack.push(canonicalizedObj)
      var sortedKeys = [],
        key = /* istanbul ignore start*/void 0 /* istanbul ignore end*/
      for (key in obj) {
      /* istanbul ignore else */
        if (obj.hasOwnProperty(key)) {
          sortedKeys.push(key)
        }
      }
      sortedKeys.sort()
      for (i = 0; i < sortedKeys.length; i += 1) {
        key = sortedKeys[i]
        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack)
      }
      stack.pop()
      replacementStack.pop()
    } else {
      canonicalizedObj = obj
    }
    return canonicalizedObj
  }
}, { './base': 48, './line': 52 }], 52: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.lineDiff = undefined
  exports.diffLines = diffLines
  /* istanbul ignore start*/exports.diffTrimmedLines = diffTrimmedLines

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

/* istanbul ignore end*/
  var /* istanbul ignore start*/_params = require('../util/params') /* istanbul ignore end*/

/* istanbul ignore start*/
  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  /* istanbul ignore end*/var lineDiff = /* istanbul ignore start*/exports.lineDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
  lineDiff.tokenize = function (value) {
    var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/)

  // Ignore the final empty token that occurs if the string ends with a new line
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop()
    }

  // Merge the content and line separators into single tokens
    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i]

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim()
        }
        retLines.push(line)
      }
    }

    return retLines
  }

  function diffLines (oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback)
  }
  function diffTrimmedLines (oldStr, newStr, callback) {
    var options = /* istanbul ignore start*/(0, _params.generateOptions)(callback, { ignoreWhitespace: true })
    return lineDiff.diff(oldStr, newStr, options)
  }
}, { '../util/params': 60, './base': 48 }], 53: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.sentenceDiff = undefined
  exports.diffSentences = diffSentences

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  /* istanbul ignore end*/var sentenceDiff = /* istanbul ignore start*/exports.sentenceDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/)
  }

  function diffSentences (oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback)
  }
}, { './base': 48 }], 54: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.wordDiff = undefined
  exports.diffWords = diffWords
  /* istanbul ignore start*/exports.diffWordsWithSpace = diffWordsWithSpace

  var /* istanbul ignore start*/_base = require('./base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

/* istanbul ignore end*/
  var /* istanbul ignore start*/_params = require('../util/params') /* istanbul ignore end*/

/* istanbul ignore start*/
  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

/* istanbul ignore end*/

// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 008000FF
//  - U+00D7   Multiplication sign
//  - U+00F7   Division sign
// Latin Extended-A, 0100017F
// Latin Extended-B, 0180024F
// IPA Extensions, 025002AF
// Spacing Modifier Letters, 02B002FF
//  - U+02C7   &#711;  Caron
//  - U+02D8   &#728;  Breve
//  - U+02D9   &#729;  Dot Above
//  - U+02DA   &#730;  Ring Above
//  - U+02DB   &#731;  Ogonek
//  - U+02DC   &#732;  Small Tilde
//  - U+02DD   &#733;  Double Acute Accent
// Latin Extended Additional, 1E001EFF
  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/

  var reWhitespace = /\S/

  var wordDiff = /* istanbul ignore start*/exports.wordDiff = new /* istanbul ignore start*/_base2['default']() /* istanbul ignore end*/
  wordDiff.equals = function (left, right) {
    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)
  }
  wordDiff.tokenize = function (value) {
    var tokens = value.split(/(\s+|\b)/)

  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
    for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2]
        tokens.splice(i + 1, 2)
        i--
      }
    }

    return tokens
  }

  function diffWords (oldStr, newStr, callback) {
    var options = /* istanbul ignore start*/(0, _params.generateOptions)(callback, { ignoreWhitespace: true })
    return wordDiff.diff(oldStr, newStr, options)
  }
  function diffWordsWithSpace (oldStr, newStr, callback) {
    return wordDiff.diff(oldStr, newStr, callback)
  }
}, { '../util/params': 60, './base': 48 }], 55: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined
/* istanbul ignore end*/
  var /* istanbul ignore start*/_base = require('./diff/base') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _base2 = _interopRequireDefault(_base)

/* istanbul ignore end*/
  var /* istanbul ignore start*/_character = require('./diff/character') /* istanbul ignore end*/

  var /* istanbul ignore start*/_word = require('./diff/word') /* istanbul ignore end*/

  var /* istanbul ignore start*/_line = require('./diff/line') /* istanbul ignore end*/

  var /* istanbul ignore start*/_sentence = require('./diff/sentence') /* istanbul ignore end*/

  var /* istanbul ignore start*/_css = require('./diff/css') /* istanbul ignore end*/

  var /* istanbul ignore start*/_json = require('./diff/json') /* istanbul ignore end*/

  var /* istanbul ignore start*/_array = require('./diff/array') /* istanbul ignore end*/

  var /* istanbul ignore start*/_apply = require('./patch/apply') /* istanbul ignore end*/

  var /* istanbul ignore start*/_parse = require('./patch/parse') /* istanbul ignore end*/

  var /* istanbul ignore start*/_create = require('./patch/create') /* istanbul ignore end*/

  var /* istanbul ignore start*/_dmp = require('./convert/dmp') /* istanbul ignore end*/

  var /* istanbul ignore start*/_xml = require('./convert/xml') /* istanbul ignore end*/

/* istanbul ignore start*/
  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  exports.Diff = _base2['default']
  /* istanbul ignore start*/exports.diffChars = _character.diffChars
  /* istanbul ignore start*/exports.diffWords = _word.diffWords
  /* istanbul ignore start*/exports.diffWordsWithSpace = _word.diffWordsWithSpace
  /* istanbul ignore start*/exports.diffLines = _line.diffLines
  /* istanbul ignore start*/exports.diffTrimmedLines = _line.diffTrimmedLines
  /* istanbul ignore start*/exports.diffSentences = _sentence.diffSentences
  /* istanbul ignore start*/exports.diffCss = _css.diffCss
  /* istanbul ignore start*/exports.diffJson = _json.diffJson
  /* istanbul ignore start*/exports.diffArrays = _array.diffArrays
  /* istanbul ignore start*/exports.structuredPatch = _create.structuredPatch
  /* istanbul ignore start*/exports.createTwoFilesPatch = _create.createTwoFilesPatch
  /* istanbul ignore start*/exports.createPatch = _create.createPatch
  /* istanbul ignore start*/exports.applyPatch = _apply.applyPatch
  /* istanbul ignore start*/exports.applyPatches = _apply.applyPatches
  /* istanbul ignore start*/exports.parsePatch = _parse.parsePatch
  /* istanbul ignore start*/exports.convertChangesToDMP = _dmp.convertChangesToDMP
  /* istanbul ignore start*/exports.convertChangesToXML = _xml.convertChangesToXML
  /* istanbul ignore start*/exports.canonicalize = _json.canonicalize /* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 *
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 *
 * JsDiff.diffCss: Diff targeted at CSS content
 *
 * These methods are based on the implementation proposed in
 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */
}, { './convert/dmp': 45, './convert/xml': 46, './diff/array': 47, './diff/base': 48, './diff/character': 49, './diff/css': 50, './diff/json': 51, './diff/line': 52, './diff/sentence': 53, './diff/word': 54, './patch/apply': 56, './patch/create': 57, './patch/parse': 58 }], 56: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.applyPatch = applyPatch
  /* istanbul ignore start*/exports.applyPatches = applyPatches

  var /* istanbul ignore start*/_parse = require('./parse') /* istanbul ignore end*/

  var /* istanbul ignore start*/_distanceIterator = require('../util/distance-iterator') /* istanbul ignore end*/

/* istanbul ignore start*/
  var _distanceIterator2 = _interopRequireDefault(_distanceIterator)

  function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { 'default': obj } }

  /* istanbul ignore end*/function applyPatch (source, uniDiff) {
    /* istanbul ignore start*/var /* istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2]

    if (typeof uniDiff === 'string') {
      uniDiff = /* istanbul ignore start*/(0, _parse.parsePatch)(uniDiff)
    }

    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error('applyPatch only works with a single input.')
      }

      uniDiff = uniDiff[0]
    }

  // Apply the diff to the input
    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /* istanbul ignore start*/{
        return (/* istanbul ignore end*/line === patchContent
    )
      },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL = /* istanbul ignore start*/void 0 /* istanbul ignore end*/,
      addEOFNL = /* istanbul ignore start*/void 0 /* istanbul ignore end*/

  /**
   * Checks if the hunk exactly fits on the provided location
   */
    function hunkFits (hunk, toPos) {
      for (var j = 0; j < hunk.lines.length; j++) {
        var line = hunk.lines[j],
          operation = line[0],
          content = line.substr(1)

        if (operation === ' ' || operation === '-') {
        // Context sanity check
          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
            errorCount++

            if (errorCount > fuzzFactor) {
              return false
            }
          }
          toPos++
        }
      }

      return true
    }

  // Search best fit offsets for each hunk based on the previous ones
    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1

      var iterator = /* istanbul ignore start*/(0, _distanceIterator2['default'])(toPos, minLine, maxLine)

      for (; localOffset !== undefined; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset
          break
        }
      }

      if (localOffset === undefined) {
        return false
      }

    // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text
      minLine = hunk.offset + hunk.oldStart + hunk.oldLines
    }

  // Apply patch hunks
    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i],
        _toPos = _hunk.offset + _hunk.newStart - 1
      if (_hunk.newLines == 0) {
        _toPos++
      }

      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j],
          operation = line[0],
          content = line.substr(1),
          delimiter = _hunk.linedelimiters[j]

        if (operation === ' ') {
          _toPos++
        } else if (operation === '-') {
          lines.splice(_toPos, 1)
          delimiters.splice(_toPos, 1)
        /* istanbul ignore else */
        } else if (operation === '+') {
          lines.splice(_toPos, 0, content)
          delimiters.splice(_toPos, 0, delimiter)
          _toPos++
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null
          if (previousOperation === '+') {
            removeEOFNL = true
          } else if (previousOperation === '-') {
            addEOFNL = true
          }
        }
      }
    }

  // Handle EOFNL insertion/removal
    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop()
        delimiters.pop()
      }
    } else if (addEOFNL) {
      lines.push('')
      delimiters.push('\n')
    }
    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k]
    }
    return lines.join('')
  }

// Wrapper that supports multiple file patches via callbacks.
  function applyPatches (uniDiff, options) {
    if (typeof uniDiff === 'string') {
      uniDiff = /* istanbul ignore start*/(0, _parse.parsePatch)(uniDiff)
    }

    var currentIndex = 0
    function processIndex () {
      var index = uniDiff[currentIndex++]
      if (!index) {
        return options.complete()
      }

      options.loadFile(index, function (err, data) {
        if (err) {
          return options.complete(err)
        }

        var updatedContent = applyPatch(data, index, options)
        options.patched(index, updatedContent, function (err) {
          if (err) {
            return options.complete(err)
          }

          processIndex()
        })
      })
    }
    processIndex()
  }
}, { '../util/distance-iterator': 59, './parse': 58 }], 57: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.structuredPatch = structuredPatch
  /* istanbul ignore start*/exports.createTwoFilesPatch = createTwoFilesPatch
  /* istanbul ignore start*/exports.createPatch = createPatch

  var /* istanbul ignore start*/_line = require('../diff/line') /* istanbul ignore end*/

/* istanbul ignore start*/
  function _toConsumableArray (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } else { return Array.from(arr) } }

  /* istanbul ignore end*/function structuredPatch (oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {}
    }
    if (typeof options.context === 'undefined') {
      options.context = 4
    }

    var diff = /* istanbul ignore start*/(0, _line.diffLines)(oldStr, newStr, options)
    diff.push({ value: '', lines: [] }) // Append an empty value to make cleanup easier

    function contextLines (lines) {
      return lines.map(function (entry) {
        return ' ' + entry
      })
    }

    var hunks = []
    var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1
  /* istanbul ignore start*/
    var _loop = function _loop (/* istanbul ignore end*/i) {
      var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n')
      current.lines = lines

      if (current.added || current.removed) {
      /* istanbul ignore start*/
        var _curRange

      /* istanbul ignore end*/
      // If we have previous context, start with that
        if (!oldRangeStart) {
          var prev = diff[i - 1]
          oldRangeStart = oldLine
          newRangeStart = newLine

          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : []
            oldRangeStart -= curRange.length
            newRangeStart -= curRange.length
          }
        }

      // Output our changes
        /* istanbul ignore start*/(_curRange = /* istanbul ignore end*/curRange).push.apply(/* istanbul ignore start*/_curRange /* istanbul ignore end*/, /* istanbul ignore start*/_toConsumableArray(/* istanbul ignore end*/lines.map(function (entry) {
          return (current.added ? '+' : '-') + entry
        })))

      // Track the updated file position
        if (current.added) {
          newLine += lines.length
        } else {
          oldLine += lines.length
        }
      } else {
      // Identical context lines. Track line changes
        if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
          if (lines.length <= options.context * 2 && i < diff.length - 2) {
          /* istanbul ignore start*/
            var _curRange2;

          /* istanbul ignore end*/
          // Overlapping
            /* istanbul ignore start*/(_curRange2 = /* istanbul ignore end*/curRange).push.apply(/* istanbul ignore start*/_curRange2 /* istanbul ignore end*/, /* istanbul ignore start*/_toConsumableArray(/* istanbul ignore end*/contextLines(lines)))
          } else {
          /* istanbul ignore start*/
            var _curRange3

          /* istanbul ignore end*/
          // end the range and output
            var contextSize = Math.min(lines.length, options.context);
            /* istanbul ignore start*/(_curRange3 = /* istanbul ignore end*/curRange).push.apply(/* istanbul ignore start*/_curRange3 /* istanbul ignore end*/, /* istanbul ignore start*/_toConsumableArray(/* istanbul ignore end*/contextLines(lines.slice(0, contextSize))))

            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            }
            if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
              var oldEOFNewline = /\n$/.test(oldStr)
              var newEOFNewline = /\n$/.test(newStr)
              if (lines.length == 0 && !oldEOFNewline) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file')
              } else if (!oldEOFNewline || !newEOFNewline) {
                curRange.push('\\ No newline at end of file')
              }
            }
            hunks.push(hunk)

            oldRangeStart = 0
            newRangeStart = 0
            curRange = []
          }
        }
        oldLine += lines.length
        newLine += lines.length
      }
    }

    for (var i = 0; i < diff.length; i++) {
    /* istanbul ignore start*/
      _loop(/* istanbul ignore end*/i)
    }

    return {
      oldFileName: oldFileName, newFileName: newFileName,
      oldHeader: oldHeader, newHeader: newHeader,
      hunks: hunks
    }
  }

  function createTwoFilesPatch (oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options)

    var ret = []
    if (oldFileName == newFileName) {
      ret.push('Index: ' + oldFileName)
    }
    ret.push('===================================================================')
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader))
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader))

    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i]
      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@')
      ret.push.apply(ret, hunk.lines)
    }

    return ret.join('\n') + '\n'
  }

  function createPatch (fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options)
  }
}, { '../diff/line': 52 }], 58: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.parsePatch = parsePatch
  function parsePatch (uniDiff) {
    /* istanbul ignore start*/var /* istanbul ignore end*/options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1]

    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0

    function parseIndex () {
      var index = {}
      list.push(index)

    // Parse diff metadata
      while (i < diffstr.length) {
        var line = diffstr[i]

      // File header found, end parsing diff metadata
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break
        }

      // Diff index
        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line)
        if (header) {
          index.index = header[1]
        }

        i++
      }

    // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header
      parseFileHeader(index)
      parseFileHeader(index)

    // Parse hunks
      index.hunks = []

      while (i < diffstr.length) {
        var _line = diffstr[i]

        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk())
        } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line))
        } else {
          i++
        }
      }
    }

  // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.
    function parseFileHeader (index) {
      var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/
      var fileHeader = headerPattern.exec(diffstr[i])
      if (fileHeader) {
        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new'
        index[keyPrefix + 'FileName'] = fileHeader[2]
        index[keyPrefix + 'Header'] = fileHeader[3]

        i++
      }
    }

  // Parses a hunk
  // This assumes that we are at the start of a hunk.
    function parseHunk () {
      var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/)

      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: +chunkHeader[2] || 1,
        newStart: +chunkHeader[3],
        newLines: +chunkHeader[4] || 1,
        lines: [],
        linedelimiters: []
      }

      var addCount = 0,
        removeCount = 0
      for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
          break
        }
        var operation = diffstr[i][0]

        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
          hunk.lines.push(diffstr[i])
          hunk.linedelimiters.push(delimiters[i] || '\n')

          if (operation === '+') {
            addCount++
          } else if (operation === '-') {
            removeCount++
          } else if (operation === ' ') {
            addCount++
            removeCount++
          }
        } else {
          break
        }
      }

    // Handle the empty block count case
      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0
      }
      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0
      }

    // Perform optional sanity checking
      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1))
        }
        if (removeCount !== hunk.oldLines) {
          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1))
        }
      }

      return hunk
    }

    while (i < diffstr.length) {
      parseIndex()
    }

    return list
  }
}, {}], 59: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true

  exports['default'] = /* istanbul ignore end*/function (start, minLine, maxLine) {
    var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1

    return function iterator () {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++
        } else {
          wantForward = false
        }

      // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)
        if (start + localOffset <= maxLine) {
          return localOffset
        }

        forwardExhausted = true
      }

      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true
        }

      // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location
        if (minLine <= start - localOffset) {
          return -localOffset++
        }

        backwardExhausted = true
        return iterator()
      }

    // We tried to fit hunk before text beginning and beyond text lenght, then
    // hunk can't fit on the text. Return undefined
    }
  }
}, {}], 60: [function (require, module, exports) {
  /* istanbul ignore start*/'use strict'

  exports.__esModule = true
  exports.generateOptions = generateOptions
  function generateOptions (options, defaults) {
    if (typeof options === 'function') {
      defaults.callback = options
    } else if (options) {
      for (var name in options) {
      /* istanbul ignore else */
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name]
        }
      }
    }
    return defaults
  }
}, {}], 61: [function (require, module, exports) {
  'use strict'

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g

  module.exports = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string')
    }

    return str.replace(matchOperatorsRe, '\\$&')
  }
}, {}], 62: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

  function EventEmitter () {
    this._events = this._events || {}
    this._maxListeners = this._maxListeners || undefined
  }
  module.exports = EventEmitter

// Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter

  EventEmitter.prototype._events = undefined
  EventEmitter.prototype._maxListeners = undefined

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function (n) {
    if (!isNumber(n) || n < 0 || isNaN(n)) { throw TypeError('n must be a positive number') }
    this._maxListeners = n
    return this
  }

  EventEmitter.prototype.emit = function (type) {
    var er, handler, len, args, i, listeners

    if (!this._events) { this._events = {} }

  // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1]
        if (er instanceof Error) {
          throw er // Unhandled 'error' event
        } else {
        // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')')
          err.context = er
          throw err
        }
      }
    }

    handler = this._events[type]

    if (isUndefined(handler)) { return false }

    if (isFunction(handler)) {
      switch (arguments.length) {
      // fast cases
        case 1:
          handler.call(this)
          break
        case 2:
          handler.call(this, arguments[1])
          break
        case 3:
          handler.call(this, arguments[1], arguments[2])
          break
      // slower
        default:
          args = Array.prototype.slice.call(arguments, 1)
          handler.apply(this, args)
      }
    } else if (isObject(handler)) {
      args = Array.prototype.slice.call(arguments, 1)
      listeners = handler.slice()
      len = listeners.length
      for (i = 0; i < len; i++) { listeners[i].apply(this, args) }
    }

    return true
  }

  EventEmitter.prototype.addListener = function (type, listener) {
    var m

    if (!isFunction(listener)) { throw TypeError('listener must be a function') }

    if (!this._events) { this._events = {} }

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
    if (this._events.newListener) {
      this.emit('newListener', type,
              isFunction(listener.listener)
              ? listener.listener : listener)
    }

    if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    { this._events[type] = listener } else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    { this._events[type].push(listener) } else
    // Adding the second element, need to change to array.
    { this._events[type] = [this._events[type], listener] }

  // Check for listener leak
    if (isObject(this._events[type]) && !this._events[type].warned) {
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners
      } else {
        m = EventEmitter.defaultMaxListeners
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true
        console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length)
        if (typeof console.trace === 'function') {
        // not supported in IE 10
          console.trace()
        }
      }
    }

    return this
  }

  EventEmitter.prototype.on = EventEmitter.prototype.addListener

  EventEmitter.prototype.once = function (type, listener) {
    if (!isFunction(listener)) { throw TypeError('listener must be a function') }

    var fired = false

    function g () {
      this.removeListener(type, g)

      if (!fired) {
        fired = true
        listener.apply(this, arguments)
      }
    }

    g.listener = listener
    this.on(type, g)

    return this
  }

// emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function (type, listener) {
    var list, position, length, i

    if (!isFunction(listener)) { throw TypeError('listener must be a function') }

    if (!this._events || !this._events[type]) { return this }

    list = this._events[type]
    length = list.length
    position = -1

    if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type]
      if (this._events.removeListener) { this.emit('removeListener', type, listener) }
    } else if (isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
          position = i
          break
        }
      }

      if (position < 0) { return this }

      if (list.length === 1) {
        list.length = 0
        delete this._events[type]
      } else {
        list.splice(position, 1)
      }

      if (this._events.removeListener) { this.emit('removeListener', type, listener) }
    }

    return this
  }

  EventEmitter.prototype.removeAllListeners = function (type) {
    var key, listeners

    if (!this._events) { return this }

  // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0) { this._events = {} } else if (this._events[type]) { delete this._events[type] }
      return this
    }

  // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue
        this.removeAllListeners(key)
      }
      this.removeAllListeners('removeListener')
      this._events = {}
      return this
    }

    listeners = this._events[type]

    if (isFunction(listeners)) {
      this.removeListener(type, listeners)
    } else if (listeners) {
    // LIFO order
      while (listeners.length) { this.removeListener(type, listeners[listeners.length - 1]) }
    }
    delete this._events[type]

    return this
  }

  EventEmitter.prototype.listeners = function (type) {
    var ret
    if (!this._events || !this._events[type]) { ret = [] } else if (isFunction(this._events[type])) { ret = [this._events[type]] } else { ret = this._events[type].slice() }
    return ret
  }

  EventEmitter.prototype.listenerCount = function (type) {
    if (this._events) {
      var evlistener = this._events[type]

      if (isFunction(evlistener)) { return 1 } else if (evlistener) { return evlistener.length }
    }
    return 0
  }

  EventEmitter.listenerCount = function (emitter, type) {
    return emitter.listenerCount(type)
  }

  function isFunction (arg) {
    return typeof arg === 'function'
  }

  function isNumber (arg) {
    return typeof arg === 'number'
  }

  function isObject (arg) {
    return typeof arg === 'object' && arg !== null
  }

  function isUndefined (arg) {
    return arg === void 0
  }
}, {}], 63: [function (require, module, exports) {
  (function (process) {
// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)

/**
 * Module dependencies.
 */

    var exec = require('child_process').exec,
      fs = require('fs'),
      path = require('path'),
      exists = fs.existsSync || path.existsSync,
      os = require('os'),
      quote = JSON.stringify,
      cmd

    function which (name) {
      var paths = process.env.PATH.split(':')
      var loc

      for (var i = 0, len = paths.length; i < len; ++i) {
        loc = path.join(paths[i], name)
        if (exists(loc)) return loc
      }
    }

    switch (os.type()) {
      case 'Darwin':
        if (which('terminal-notifier')) {
          cmd = {
            type: 'Darwin-NotificationCenter',
            pkg: 'terminal-notifier',
            msg: '-message',
            title: '-title',
            subtitle: '-subtitle',
            icon: '-appIcon',
            sound: '-sound',
            url: '-open',
            priority: {
              cmd: '-execute',
              range: []
            }
          }
        } else {
          cmd = {
            type: 'Darwin-Growl',
            pkg: 'growlnotify',
            msg: '-m',
            sticky: '--sticky',
            priority: {
              cmd: '--priority',
              range: [
                -2,
                -1,
                0,
                1,
                2,
                'Very Low',
                'Moderate',
                'Normal',
                'High',
                'Emergency'
              ]
            }
          }
        }
        break
      case 'Linux':
        if (which('growl')) {
          cmd = {
            type: 'Linux-Growl',
            pkg: 'growl',
            msg: '-m',
            title: '-title',
            subtitle: '-subtitle',
            host: {
              cmd: '-H',
              hostname: '192.168.33.1'
            }
          }
        } else {
          cmd = {
            type: 'Linux',
            pkg: 'notify-send',
            msg: '',
            sticky: '-t 0',
            icon: '-i',
            priority: {
              cmd: '-u',
              range: [
                'low',
                'normal',
                'critical'
              ]
            }
          }
        }
        break
      case 'Windows_NT':
        cmd = {
          type: 'Windows',
          pkg: 'growlnotify',
          msg: '',
          sticky: '/s:true',
          title: '/t:',
          icon: '/i:',
          url: '/cu:',
          priority: {
            cmd: '/p:',
            range: [
              -2,
              -1,
              0,
              1,
              2
            ]
          }
        }
        break
    }

/**
 * Expose `growl`.
 */

    exports = module.exports = growl

/**
 * Node-growl version.
 */

    exports.version = '1.4.1'

/**
 * Send growl notification _msg_ with _options_.
 *
 * Options:
 *
 *  - title   Notification title
 *  - sticky  Make the notification stick (defaults to false)
 *  - priority  Specify an int or named key (default is 0)
 *  - name    Application name (defaults to growlnotify)
 *  - sound   Sound efect ( in OSx defined in preferences -> sound -> effects) * works only in OSX > 10.8x
 *  - image
 *    - path to an icon sets --iconpath
 *    - path to an image sets --image
 *    - capitalized word sets --appIcon
 *    - filename uses extname as --icon
 *    - otherwise treated as --icon
 *
 * Examples:
 *
 *   growl('New email')
 *   growl('5 new emails', { title: 'Thunderbird' })
 *   growl('5 new emails', { title: 'Thunderbird', sound: 'Purr' })
 *   growl('Email sent', function(){
 *     // ... notification sent
 *   })
 *
 * @param {string} msg
 * @param {object} options
 * @param {function} fn
 * @api public
 */

    function growl (msg, options, fn) {
      var image,
        args,
        options = options || {},
        fn = fn || function () {}

      if (options.exec) {
        cmd = {
          type: 'Custom',
          pkg: options.exec,
          range: []
        }
      }

  // noop
      if (!cmd) return fn(new Error('growl not supported on this platform'))
      args = [cmd.pkg]

  // image
      if (image = options.image) {
        switch (cmd.type) {
          case 'Darwin-Growl':
            var flag, ext = path.extname(image).substr(1)
            flag = flag || ext == 'icns' && 'iconpath'
            flag = flag || /^[A-Z]/.test(image) && 'appIcon'
            flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'
            flag = flag || ext && (image = ext) && 'icon'
            flag = flag || 'icon'
            args.push('--' + flag, quote(image))
            break
          case 'Darwin-NotificationCenter':
            args.push(cmd.icon, quote(image))
            break
          case 'Linux':
            args.push(cmd.icon, quote(image))
        // libnotify defaults to sticky, set a hint for transient notifications
            if (!options.sticky) args.push('--hint=int:transient:1')
            break
          case 'Windows':
            args.push(cmd.icon + quote(image))
            break
        }
      }

  // sticky
      if (options.sticky) args.push(cmd.sticky)

  // priority
      if (options.priority) {
        var priority = options.priority + ''
        var checkindexOf = cmd.priority.range.indexOf(priority)
        if (~cmd.priority.range.indexOf(priority)) {
          args.push(cmd.priority, options.priority)
        }
      }

  // sound
      if (options.sound && cmd.type === 'Darwin-NotificationCenter') {
        args.push(cmd.sound, options.sound)
      }

  // name
      if (options.name && cmd.type === 'Darwin-Growl') {
        args.push('--name', options.name)
      }

      switch (cmd.type) {
        case 'Darwin-Growl':
          args.push(cmd.msg)
          args.push(quote(msg).replace(/\\n/g, '\n'))
          if (options.title) args.push(quote(options.title))
          break
        case 'Darwin-NotificationCenter':
          args.push(cmd.msg)
          var stringifiedMsg = quote(msg)
          var escapedMsg = stringifiedMsg.replace(/\\n/g, '\n')
          args.push(escapedMsg)
          if (options.title) {
            args.push(cmd.title)
            args.push(quote(options.title))
          }
          if (options.subtitle) {
            args.push(cmd.subtitle)
            args.push(quote(options.subtitle))
          }
          if (options.url) {
            args.push(cmd.url)
            args.push(quote(options.url))
          }
          break
        case 'Linux-Growl':
          args.push(cmd.msg)
          args.push(quote(msg).replace(/\\n/g, '\n'))
          if (options.title) args.push(quote(options.title))
          if (cmd.host) {
            args.push(cmd.host.cmd, cmd.host.hostname)
          }
          break
        case 'Linux':
          if (options.title) {
            args.push(quote(options.title))
            args.push(cmd.msg)
            args.push(quote(msg).replace(/\\n/g, '\n'))
          } else {
            args.push(quote(msg).replace(/\\n/g, '\n'))
          }
          break
        case 'Windows':
          args.push(quote(msg).replace(/\\n/g, '\n'))
          if (options.title) args.push(cmd.title + quote(options.title))
          if (options.url) args.push(cmd.url + quote(options.url))
          break
        case 'Custom':
          args[0] = (function (origCommand) {
            var message = options.title
          ? options.title + ': ' + msg
          : msg
            var command = origCommand.replace(/(^|[^%])%s/g, '$1' + quote(message))
            if (command === origCommand) args.push(quote(message))
            return command
          })(args[0])
          break
      }

  // execute
      exec(args.join(' '), fn)
    };
  }).call(this, require('_process'))
}, { '_process': 82, 'child_process': 42, 'fs': 42, 'os': 80, 'path': 42 }], 64: [function (require, module, exports) {
  (function (global) {
/*! https://mths.be/he v1.1.1 by @mathias | MIT license */
    ;(function (root) {
	// Detect free variables `exports`.
      var freeExports = typeof exports === 'object' && exports

	// Detect free variable `module`.
      var freeModule = typeof module === 'object' && module &&
		module.exports == freeExports && module

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
      var freeGlobal = typeof global === 'object' && global
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal
      }

	/* --------------------------------------------------------------------------*/

	// All astral symbols.
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g
	// All ASCII symbols (not just printable ASCII) except those listed in the
	// first column of the overrides table.
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
      var regexAsciiWhitelist = /[\x01-\x7F]/g
	// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
	// code points listed in the first column of the overrides table on
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g

      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g
      var encodeMap = { '\xAD': 'shy', '\u200C': 'zwnj', '\u200D': 'zwj', '\u200E': 'lrm', '\u2063': 'ic', '\u2062': 'it', '\u2061': 'af', '\u200F': 'rlm', '\u200B': 'ZeroWidthSpace', '\u2060': 'NoBreak', '\u0311': 'DownBreve', '\u20DB': 'tdot', '\u20DC': 'DotDot', '\t': 'Tab', '\n': 'NewLine', '\u2008': 'puncsp', '\u205F': 'MediumSpace', '\u2009': 'thinsp', '\u200A': 'hairsp', '\u2004': 'emsp13', '\u2002': 'ensp', '\u2005': 'emsp14', '\u2003': 'emsp', '\u2007': 'numsp', '\xA0': 'nbsp', '\u205F\u200A': 'ThickSpace', '\u203E': 'oline', '_': 'lowbar', '\u2010': 'dash', '\u2013': 'ndash', '\u2014': 'mdash', '\u2015': 'horbar', ',': 'comma', ';': 'semi', '\u204F': 'bsemi', ':': 'colon', '\u2A74': 'Colone', '!': 'excl', '\xA1': 'iexcl', '?': 'quest', '\xBF': 'iquest', '.': 'period', '\u2025': 'nldr', '\u2026': 'mldr', '\xB7': 'middot', '\'': 'apos', '\u2018': 'lsquo', '\u2019': 'rsquo', '\u201A': 'sbquo', '\u2039': 'lsaquo', '\u203A': 'rsaquo', '"': 'quot', '\u201C': 'ldquo', '\u201D': 'rdquo', '\u201E': 'bdquo', '\xAB': 'laquo', '\xBB': 'raquo', '(': 'lpar', ')': 'rpar', '[': 'lsqb', ']': 'rsqb', '{': 'lcub', '}': 'rcub', '\u2308': 'lceil', '\u2309': 'rceil', '\u230A': 'lfloor', '\u230B': 'rfloor', '\u2985': 'lopar', '\u2986': 'ropar', '\u298B': 'lbrke', '\u298C': 'rbrke', '\u298D': 'lbrkslu', '\u298E': 'rbrksld', '\u298F': 'lbrksld', '\u2990': 'rbrkslu', '\u2991': 'langd', '\u2992': 'rangd', '\u2993': 'lparlt', '\u2994': 'rpargt', '\u2995': 'gtlPar', '\u2996': 'ltrPar', '\u27E6': 'lobrk', '\u27E7': 'robrk', '\u27E8': 'lang', '\u27E9': 'rang', '\u27EA': 'Lang', '\u27EB': 'Rang', '\u27EC': 'loang', '\u27ED': 'roang', '\u2772': 'lbbrk', '\u2773': 'rbbrk', '\u2016': 'Vert', '\xA7': 'sect', '\xB6': 'para', '@': 'commat', '*': 'ast', '/': 'sol', 'undefined': null, '&': 'amp', '#': 'num', '%': 'percnt', '\u2030': 'permil', '\u2031': 'pertenk', '\u2020': 'dagger', '\u2021': 'Dagger', '\u2022': 'bull', '\u2043': 'hybull', '\u2032': 'prime', '\u2033': 'Prime', '\u2034': 'tprime', '\u2057': 'qprime', '\u2035': 'bprime', '\u2041': 'caret', '`': 'grave', '\xB4': 'acute', '\u02DC': 'tilde', '^': 'Hat', '\xAF': 'macr', '\u02D8': 'breve', '\u02D9': 'dot', '\xA8': 'die', '\u02DA': 'ring', '\u02DD': 'dblac', '\xB8': 'cedil', '\u02DB': 'ogon', '\u02C6': 'circ', '\u02C7': 'caron', '\xB0': 'deg', '\xA9': 'copy', '\xAE': 'reg', '\u2117': 'copysr', '\u2118': 'wp', '\u211E': 'rx', '\u2127': 'mho', '\u2129': 'iiota', '\u2190': 'larr', '\u219A': 'nlarr', '\u2192': 'rarr', '\u219B': 'nrarr', '\u2191': 'uarr', '\u2193': 'darr', '\u2194': 'harr', '\u21AE': 'nharr', '\u2195': 'varr', '\u2196': 'nwarr', '\u2197': 'nearr', '\u2198': 'searr', '\u2199': 'swarr', '\u219D': 'rarrw', '\u219D\u0338': 'nrarrw', '\u219E': 'Larr', '\u219F': 'Uarr', '\u21A0': 'Rarr', '\u21A1': 'Darr', '\u21A2': 'larrtl', '\u21A3': 'rarrtl', '\u21A4': 'mapstoleft', '\u21A5': 'mapstoup', '\u21A6': 'map', '\u21A7': 'mapstodown', '\u21A9': 'larrhk', '\u21AA': 'rarrhk', '\u21AB': 'larrlp', '\u21AC': 'rarrlp', '\u21AD': 'harrw', '\u21B0': 'lsh', '\u21B1': 'rsh', '\u21B2': 'ldsh', '\u21B3': 'rdsh', '\u21B5': 'crarr', '\u21B6': 'cularr', '\u21B7': 'curarr', '\u21BA': 'olarr', '\u21BB': 'orarr', '\u21BC': 'lharu', '\u21BD': 'lhard', '\u21BE': 'uharr', '\u21BF': 'uharl', '\u21C0': 'rharu', '\u21C1': 'rhard', '\u21C2': 'dharr', '\u21C3': 'dharl', '\u21C4': 'rlarr', '\u21C5': 'udarr', '\u21C6': 'lrarr', '\u21C7': 'llarr', '\u21C8': 'uuarr', '\u21C9': 'rrarr', '\u21CA': 'ddarr', '\u21CB': 'lrhar', '\u21CC': 'rlhar', '\u21D0': 'lArr', '\u21CD': 'nlArr', '\u21D1': 'uArr', '\u21D2': 'rArr', '\u21CF': 'nrArr', '\u21D3': 'dArr', '\u21D4': 'iff', '\u21CE': 'nhArr', '\u21D5': 'vArr', '\u21D6': 'nwArr', '\u21D7': 'neArr', '\u21D8': 'seArr', '\u21D9': 'swArr', '\u21DA': 'lAarr', '\u21DB': 'rAarr', '\u21DD': 'zigrarr', '\u21E4': 'larrb', '\u21E5': 'rarrb', '\u21F5': 'duarr', '\u21FD': 'loarr', '\u21FE': 'roarr', '\u21FF': 'hoarr', '\u2200': 'forall', '\u2201': 'comp', '\u2202': 'part', '\u2202\u0338': 'npart', '\u2203': 'exist', '\u2204': 'nexist', '\u2205': 'empty', '\u2207': 'Del', '\u2208': 'in', '\u2209': 'notin', '\u220B': 'ni', '\u220C': 'notni', '\u03F6': 'bepsi', '\u220F': 'prod', '\u2210': 'coprod', '\u2211': 'sum', '+': 'plus', '\xB1': 'pm', '\xF7': 'div', '\xD7': 'times', '<': 'lt', '\u226E': 'nlt', '<\u20D2': 'nvlt', '=': 'equals', '\u2260': 'ne', '=\u20E5': 'bne', '\u2A75': 'Equal', '>': 'gt', '\u226F': 'ngt', '>\u20D2': 'nvgt', '\xAC': 'not', '|': 'vert', '\xA6': 'brvbar', '\u2212': 'minus', '\u2213': 'mp', '\u2214': 'plusdo', '\u2044': 'frasl', '\u2216': 'setmn', '\u2217': 'lowast', '\u2218': 'compfn', '\u221A': 'Sqrt', '\u221D': 'prop', '\u221E': 'infin', '\u221F': 'angrt', '\u2220': 'ang', '\u2220\u20D2': 'nang', '\u2221': 'angmsd', '\u2222': 'angsph', '\u2223': 'mid', '\u2224': 'nmid', '\u2225': 'par', '\u2226': 'npar', '\u2227': 'and', '\u2228': 'or', '\u2229': 'cap', '\u2229\uFE00': 'caps', '\u222A': 'cup', '\u222A\uFE00': 'cups', '\u222B': 'int', '\u222C': 'Int', '\u222D': 'tint', '\u2A0C': 'qint', '\u222E': 'oint', '\u222F': 'Conint', '\u2230': 'Cconint', '\u2231': 'cwint', '\u2232': 'cwconint', '\u2233': 'awconint', '\u2234': 'there4', '\u2235': 'becaus', '\u2236': 'ratio', '\u2237': 'Colon', '\u2238': 'minusd', '\u223A': 'mDDot', '\u223B': 'homtht', '\u223C': 'sim', '\u2241': 'nsim', '\u223C\u20D2': 'nvsim', '\u223D': 'bsim', '\u223D\u0331': 'race', '\u223E': 'ac', '\u223E\u0333': 'acE', '\u223F': 'acd', '\u2240': 'wr', '\u2242': 'esim', '\u2242\u0338': 'nesim', '\u2243': 'sime', '\u2244': 'nsime', '\u2245': 'cong', '\u2247': 'ncong', '\u2246': 'simne', '\u2248': 'ap', '\u2249': 'nap', '\u224A': 'ape', '\u224B': 'apid', '\u224B\u0338': 'napid', '\u224C': 'bcong', '\u224D': 'CupCap', '\u226D': 'NotCupCap', '\u224D\u20D2': 'nvap', '\u224E': 'bump', '\u224E\u0338': 'nbump', '\u224F': 'bumpe', '\u224F\u0338': 'nbumpe', '\u2250': 'doteq', '\u2250\u0338': 'nedot', '\u2251': 'eDot', '\u2252': 'efDot', '\u2253': 'erDot', '\u2254': 'colone', '\u2255': 'ecolon', '\u2256': 'ecir', '\u2257': 'cire', '\u2259': 'wedgeq', '\u225A': 'veeeq', '\u225C': 'trie', '\u225F': 'equest', '\u2261': 'equiv', '\u2262': 'nequiv', '\u2261\u20E5': 'bnequiv', '\u2264': 'le', '\u2270': 'nle', '\u2264\u20D2': 'nvle', '\u2265': 'ge', '\u2271': 'nge', '\u2265\u20D2': 'nvge', '\u2266': 'lE', '\u2266\u0338': 'nlE', '\u2267': 'gE', '\u2267\u0338': 'ngE', '\u2268\uFE00': 'lvnE', '\u2268': 'lnE', '\u2269': 'gnE', '\u2269\uFE00': 'gvnE', '\u226A': 'll', '\u226A\u0338': 'nLtv', '\u226A\u20D2': 'nLt', '\u226B': 'gg', '\u226B\u0338': 'nGtv', '\u226B\u20D2': 'nGt', '\u226C': 'twixt', '\u2272': 'lsim', '\u2274': 'nlsim', '\u2273': 'gsim', '\u2275': 'ngsim', '\u2276': 'lg', '\u2278': 'ntlg', '\u2277': 'gl', '\u2279': 'ntgl', '\u227A': 'pr', '\u2280': 'npr', '\u227B': 'sc', '\u2281': 'nsc', '\u227C': 'prcue', '\u22E0': 'nprcue', '\u227D': 'sccue', '\u22E1': 'nsccue', '\u227E': 'prsim', '\u227F': 'scsim', '\u227F\u0338': 'NotSucceedsTilde', '\u2282': 'sub', '\u2284': 'nsub', '\u2282\u20D2': 'vnsub', '\u2283': 'sup', '\u2285': 'nsup', '\u2283\u20D2': 'vnsup', '\u2286': 'sube', '\u2288': 'nsube', '\u2287': 'supe', '\u2289': 'nsupe', '\u228A\uFE00': 'vsubne', '\u228A': 'subne', '\u228B\uFE00': 'vsupne', '\u228B': 'supne', '\u228D': 'cupdot', '\u228E': 'uplus', '\u228F': 'sqsub', '\u228F\u0338': 'NotSquareSubset', '\u2290': 'sqsup', '\u2290\u0338': 'NotSquareSuperset', '\u2291': 'sqsube', '\u22E2': 'nsqsube', '\u2292': 'sqsupe', '\u22E3': 'nsqsupe', '\u2293': 'sqcap', '\u2293\uFE00': 'sqcaps', '\u2294': 'sqcup', '\u2294\uFE00': 'sqcups', '\u2295': 'oplus', '\u2296': 'ominus', '\u2297': 'otimes', '\u2298': 'osol', '\u2299': 'odot', '\u229A': 'ocir', '\u229B': 'oast', '\u229D': 'odash', '\u229E': 'plusb', '\u229F': 'minusb', '\u22A0': 'timesb', '\u22A1': 'sdotb', '\u22A2': 'vdash', '\u22AC': 'nvdash', '\u22A3': 'dashv', '\u22A4': 'top', '\u22A5': 'bot', '\u22A7': 'models', '\u22A8': 'vDash', '\u22AD': 'nvDash', '\u22A9': 'Vdash', '\u22AE': 'nVdash', '\u22AA': 'Vvdash', '\u22AB': 'VDash', '\u22AF': 'nVDash', '\u22B0': 'prurel', '\u22B2': 'vltri', '\u22EA': 'nltri', '\u22B3': 'vrtri', '\u22EB': 'nrtri', '\u22B4': 'ltrie', '\u22EC': 'nltrie', '\u22B4\u20D2': 'nvltrie', '\u22B5': 'rtrie', '\u22ED': 'nrtrie', '\u22B5\u20D2': 'nvrtrie', '\u22B6': 'origof', '\u22B7': 'imof', '\u22B8': 'mumap', '\u22B9': 'hercon', '\u22BA': 'intcal', '\u22BB': 'veebar', '\u22BD': 'barvee', '\u22BE': 'angrtvb', '\u22BF': 'lrtri', '\u22C0': 'Wedge', '\u22C1': 'Vee', '\u22C2': 'xcap', '\u22C3': 'xcup', '\u22C4': 'diam', '\u22C5': 'sdot', '\u22C6': 'Star', '\u22C7': 'divonx', '\u22C8': 'bowtie', '\u22C9': 'ltimes', '\u22CA': 'rtimes', '\u22CB': 'lthree', '\u22CC': 'rthree', '\u22CD': 'bsime', '\u22CE': 'cuvee', '\u22CF': 'cuwed', '\u22D0': 'Sub', '\u22D1': 'Sup', '\u22D2': 'Cap', '\u22D3': 'Cup', '\u22D4': 'fork', '\u22D5': 'epar', '\u22D6': 'ltdot', '\u22D7': 'gtdot', '\u22D8': 'Ll', '\u22D8\u0338': 'nLl', '\u22D9': 'Gg', '\u22D9\u0338': 'nGg', '\u22DA\uFE00': 'lesg', '\u22DA': 'leg', '\u22DB': 'gel', '\u22DB\uFE00': 'gesl', '\u22DE': 'cuepr', '\u22DF': 'cuesc', '\u22E6': 'lnsim', '\u22E7': 'gnsim', '\u22E8': 'prnsim', '\u22E9': 'scnsim', '\u22EE': 'vellip', '\u22EF': 'ctdot', '\u22F0': 'utdot', '\u22F1': 'dtdot', '\u22F2': 'disin', '\u22F3': 'isinsv', '\u22F4': 'isins', '\u22F5': 'isindot', '\u22F5\u0338': 'notindot', '\u22F6': 'notinvc', '\u22F7': 'notinvb', '\u22F9': 'isinE', '\u22F9\u0338': 'notinE', '\u22FA': 'nisd', '\u22FB': 'xnis', '\u22FC': 'nis', '\u22FD': 'notnivc', '\u22FE': 'notnivb', '\u2305': 'barwed', '\u2306': 'Barwed', '\u230C': 'drcrop', '\u230D': 'dlcrop', '\u230E': 'urcrop', '\u230F': 'ulcrop', '\u2310': 'bnot', '\u2312': 'profline', '\u2313': 'profsurf', '\u2315': 'telrec', '\u2316': 'target', '\u231C': 'ulcorn', '\u231D': 'urcorn', '\u231E': 'dlcorn', '\u231F': 'drcorn', '\u2322': 'frown', '\u2323': 'smile', '\u232D': 'cylcty', '\u232E': 'profalar', '\u2336': 'topbot', '\u233D': 'ovbar', '\u233F': 'solbar', '\u237C': 'angzarr', '\u23B0': 'lmoust', '\u23B1': 'rmoust', '\u23B4': 'tbrk', '\u23B5': 'bbrk', '\u23B6': 'bbrktbrk', '\u23DC': 'OverParenthesis', '\u23DD': 'UnderParenthesis', '\u23DE': 'OverBrace', '\u23DF': 'UnderBrace', '\u23E2': 'trpezium', '\u23E7': 'elinters', '\u2423': 'blank', '\u2500': 'boxh', '\u2502': 'boxv', '\u250C': 'boxdr', '\u2510': 'boxdl', '\u2514': 'boxur', '\u2518': 'boxul', '\u251C': 'boxvr', '\u2524': 'boxvl', '\u252C': 'boxhd', '\u2534': 'boxhu', '\u253C': 'boxvh', '\u2550': 'boxH', '\u2551': 'boxV', '\u2552': 'boxdR', '\u2553': 'boxDr', '\u2554': 'boxDR', '\u2555': 'boxdL', '\u2556': 'boxDl', '\u2557': 'boxDL', '\u2558': 'boxuR', '\u2559': 'boxUr', '\u255A': 'boxUR', '\u255B': 'boxuL', '\u255C': 'boxUl', '\u255D': 'boxUL', '\u255E': 'boxvR', '\u255F': 'boxVr', '\u2560': 'boxVR', '\u2561': 'boxvL', '\u2562': 'boxVl', '\u2563': 'boxVL', '\u2564': 'boxHd', '\u2565': 'boxhD', '\u2566': 'boxHD', '\u2567': 'boxHu', '\u2568': 'boxhU', '\u2569': 'boxHU', '\u256A': 'boxvH', '\u256B': 'boxVh', '\u256C': 'boxVH', '\u2580': 'uhblk', '\u2584': 'lhblk', '\u2588': 'block', '\u2591': 'blk14', '\u2592': 'blk12', '\u2593': 'blk34', '\u25A1': 'squ', '\u25AA': 'squf', '\u25AB': 'EmptyVerySmallSquare', '\u25AD': 'rect', '\u25AE': 'marker', '\u25B1': 'fltns', '\u25B3': 'xutri', '\u25B4': 'utrif', '\u25B5': 'utri', '\u25B8': 'rtrif', '\u25B9': 'rtri', '\u25BD': 'xdtri', '\u25BE': 'dtrif', '\u25BF': 'dtri', '\u25C2': 'ltrif', '\u25C3': 'ltri', '\u25CA': 'loz', '\u25CB': 'cir', '\u25EC': 'tridot', '\u25EF': 'xcirc', '\u25F8': 'ultri', '\u25F9': 'urtri', '\u25FA': 'lltri', '\u25FB': 'EmptySmallSquare', '\u25FC': 'FilledSmallSquare', '\u2605': 'starf', '\u2606': 'star', '\u260E': 'phone', '\u2640': 'female', '\u2642': 'male', '\u2660': 'spades', '\u2663': 'clubs', '\u2665': 'hearts', '\u2666': 'diams', '\u266A': 'sung', '\u2713': 'check', '\u2717': 'cross', '\u2720': 'malt', '\u2736': 'sext', '\u2758': 'VerticalSeparator', '\u27C8': 'bsolhsub', '\u27C9': 'suphsol', '\u27F5': 'xlarr', '\u27F6': 'xrarr', '\u27F7': 'xharr', '\u27F8': 'xlArr', '\u27F9': 'xrArr', '\u27FA': 'xhArr', '\u27FC': 'xmap', '\u27FF': 'dzigrarr', '\u2902': 'nvlArr', '\u2903': 'nvrArr', '\u2904': 'nvHarr', '\u2905': 'Map', '\u290C': 'lbarr', '\u290D': 'rbarr', '\u290E': 'lBarr', '\u290F': 'rBarr', '\u2910': 'RBarr', '\u2911': 'DDotrahd', '\u2912': 'UpArrowBar', '\u2913': 'DownArrowBar', '\u2916': 'Rarrtl', '\u2919': 'latail', '\u291A': 'ratail', '\u291B': 'lAtail', '\u291C': 'rAtail', '\u291D': 'larrfs', '\u291E': 'rarrfs', '\u291F': 'larrbfs', '\u2920': 'rarrbfs', '\u2923': 'nwarhk', '\u2924': 'nearhk', '\u2925': 'searhk', '\u2926': 'swarhk', '\u2927': 'nwnear', '\u2928': 'toea', '\u2929': 'tosa', '\u292A': 'swnwar', '\u2933': 'rarrc', '\u2933\u0338': 'nrarrc', '\u2935': 'cudarrr', '\u2936': 'ldca', '\u2937': 'rdca', '\u2938': 'cudarrl', '\u2939': 'larrpl', '\u293C': 'curarrm', '\u293D': 'cularrp', '\u2945': 'rarrpl', '\u2948': 'harrcir', '\u2949': 'Uarrocir', '\u294A': 'lurdshar', '\u294B': 'ldrushar', '\u294E': 'LeftRightVector', '\u294F': 'RightUpDownVector', '\u2950': 'DownLeftRightVector', '\u2951': 'LeftUpDownVector', '\u2952': 'LeftVectorBar', '\u2953': 'RightVectorBar', '\u2954': 'RightUpVectorBar', '\u2955': 'RightDownVectorBar', '\u2956': 'DownLeftVectorBar', '\u2957': 'DownRightVectorBar', '\u2958': 'LeftUpVectorBar', '\u2959': 'LeftDownVectorBar', '\u295A': 'LeftTeeVector', '\u295B': 'RightTeeVector', '\u295C': 'RightUpTeeVector', '\u295D': 'RightDownTeeVector', '\u295E': 'DownLeftTeeVector', '\u295F': 'DownRightTeeVector', '\u2960': 'LeftUpTeeVector', '\u2961': 'LeftDownTeeVector', '\u2962': 'lHar', '\u2963': 'uHar', '\u2964': 'rHar', '\u2965': 'dHar', '\u2966': 'luruhar', '\u2967': 'ldrdhar', '\u2968': 'ruluhar', '\u2969': 'rdldhar', '\u296A': 'lharul', '\u296B': 'llhard', '\u296C': 'rharul', '\u296D': 'lrhard', '\u296E': 'udhar', '\u296F': 'duhar', '\u2970': 'RoundImplies', '\u2971': 'erarr', '\u2972': 'simrarr', '\u2973': 'larrsim', '\u2974': 'rarrsim', '\u2975': 'rarrap', '\u2976': 'ltlarr', '\u2978': 'gtrarr', '\u2979': 'subrarr', '\u297B': 'suplarr', '\u297C': 'lfisht', '\u297D': 'rfisht', '\u297E': 'ufisht', '\u297F': 'dfisht', '\u299A': 'vzigzag', '\u299C': 'vangrt', '\u299D': 'angrtvbd', '\u29A4': 'ange', '\u29A5': 'range', '\u29A6': 'dwangle', '\u29A7': 'uwangle', '\u29A8': 'angmsdaa', '\u29A9': 'angmsdab', '\u29AA': 'angmsdac', '\u29AB': 'angmsdad', '\u29AC': 'angmsdae', '\u29AD': 'angmsdaf', '\u29AE': 'angmsdag', '\u29AF': 'angmsdah', '\u29B0': 'bemptyv', '\u29B1': 'demptyv', '\u29B2': 'cemptyv', '\u29B3': 'raemptyv', '\u29B4': 'laemptyv', '\u29B5': 'ohbar', '\u29B6': 'omid', '\u29B7': 'opar', '\u29B9': 'operp', '\u29BB': 'olcross', '\u29BC': 'odsold', '\u29BE': 'olcir', '\u29BF': 'ofcir', '\u29C0': 'olt', '\u29C1': 'ogt', '\u29C2': 'cirscir', '\u29C3': 'cirE', '\u29C4': 'solb', '\u29C5': 'bsolb', '\u29C9': 'boxbox', '\u29CD': 'trisb', '\u29CE': 'rtriltri', '\u29CF': 'LeftTriangleBar', '\u29CF\u0338': 'NotLeftTriangleBar', '\u29D0': 'RightTriangleBar', '\u29D0\u0338': 'NotRightTriangleBar', '\u29DC': 'iinfin', '\u29DD': 'infintie', '\u29DE': 'nvinfin', '\u29E3': 'eparsl', '\u29E4': 'smeparsl', '\u29E5': 'eqvparsl', '\u29EB': 'lozf', '\u29F4': 'RuleDelayed', '\u29F6': 'dsol', '\u2A00': 'xodot', '\u2A01': 'xoplus', '\u2A02': 'xotime', '\u2A04': 'xuplus', '\u2A06': 'xsqcup', '\u2A0D': 'fpartint', '\u2A10': 'cirfnint', '\u2A11': 'awint', '\u2A12': 'rppolint', '\u2A13': 'scpolint', '\u2A14': 'npolint', '\u2A15': 'pointint', '\u2A16': 'quatint', '\u2A17': 'intlarhk', '\u2A22': 'pluscir', '\u2A23': 'plusacir', '\u2A24': 'simplus', '\u2A25': 'plusdu', '\u2A26': 'plussim', '\u2A27': 'plustwo', '\u2A29': 'mcomma', '\u2A2A': 'minusdu', '\u2A2D': 'loplus', '\u2A2E': 'roplus', '\u2A2F': 'Cross', '\u2A30': 'timesd', '\u2A31': 'timesbar', '\u2A33': 'smashp', '\u2A34': 'lotimes', '\u2A35': 'rotimes', '\u2A36': 'otimesas', '\u2A37': 'Otimes', '\u2A38': 'odiv', '\u2A39': 'triplus', '\u2A3A': 'triminus', '\u2A3B': 'tritime', '\u2A3C': 'iprod', '\u2A3F': 'amalg', '\u2A40': 'capdot', '\u2A42': 'ncup', '\u2A43': 'ncap', '\u2A44': 'capand', '\u2A45': 'cupor', '\u2A46': 'cupcap', '\u2A47': 'capcup', '\u2A48': 'cupbrcap', '\u2A49': 'capbrcup', '\u2A4A': 'cupcup', '\u2A4B': 'capcap', '\u2A4C': 'ccups', '\u2A4D': 'ccaps', '\u2A50': 'ccupssm', '\u2A53': 'And', '\u2A54': 'Or', '\u2A55': 'andand', '\u2A56': 'oror', '\u2A57': 'orslope', '\u2A58': 'andslope', '\u2A5A': 'andv', '\u2A5B': 'orv', '\u2A5C': 'andd', '\u2A5D': 'ord', '\u2A5F': 'wedbar', '\u2A66': 'sdote', '\u2A6A': 'simdot', '\u2A6D': 'congdot', '\u2A6D\u0338': 'ncongdot', '\u2A6E': 'easter', '\u2A6F': 'apacir', '\u2A70': 'apE', '\u2A70\u0338': 'napE', '\u2A71': 'eplus', '\u2A72': 'pluse', '\u2A73': 'Esim', '\u2A77': 'eDDot', '\u2A78': 'equivDD', '\u2A79': 'ltcir', '\u2A7A': 'gtcir', '\u2A7B': 'ltquest', '\u2A7C': 'gtquest', '\u2A7D': 'les', '\u2A7D\u0338': 'nles', '\u2A7E': 'ges', '\u2A7E\u0338': 'nges', '\u2A7F': 'lesdot', '\u2A80': 'gesdot', '\u2A81': 'lesdoto', '\u2A82': 'gesdoto', '\u2A83': 'lesdotor', '\u2A84': 'gesdotol', '\u2A85': 'lap', '\u2A86': 'gap', '\u2A87': 'lne', '\u2A88': 'gne', '\u2A89': 'lnap', '\u2A8A': 'gnap', '\u2A8B': 'lEg', '\u2A8C': 'gEl', '\u2A8D': 'lsime', '\u2A8E': 'gsime', '\u2A8F': 'lsimg', '\u2A90': 'gsiml', '\u2A91': 'lgE', '\u2A92': 'glE', '\u2A93': 'lesges', '\u2A94': 'gesles', '\u2A95': 'els', '\u2A96': 'egs', '\u2A97': 'elsdot', '\u2A98': 'egsdot', '\u2A99': 'el', '\u2A9A': 'eg', '\u2A9D': 'siml', '\u2A9E': 'simg', '\u2A9F': 'simlE', '\u2AA0': 'simgE', '\u2AA1': 'LessLess', '\u2AA1\u0338': 'NotNestedLessLess', '\u2AA2': 'GreaterGreater', '\u2AA2\u0338': 'NotNestedGreaterGreater', '\u2AA4': 'glj', '\u2AA5': 'gla', '\u2AA6': 'ltcc', '\u2AA7': 'gtcc', '\u2AA8': 'lescc', '\u2AA9': 'gescc', '\u2AAA': 'smt', '\u2AAB': 'lat', '\u2AAC': 'smte', '\u2AAC\uFE00': 'smtes', '\u2AAD': 'late', '\u2AAD\uFE00': 'lates', '\u2AAE': 'bumpE', '\u2AAF': 'pre', '\u2AAF\u0338': 'npre', '\u2AB0': 'sce', '\u2AB0\u0338': 'nsce', '\u2AB3': 'prE', '\u2AB4': 'scE', '\u2AB5': 'prnE', '\u2AB6': 'scnE', '\u2AB7': 'prap', '\u2AB8': 'scap', '\u2AB9': 'prnap', '\u2ABA': 'scnap', '\u2ABB': 'Pr', '\u2ABC': 'Sc', '\u2ABD': 'subdot', '\u2ABE': 'supdot', '\u2ABF': 'subplus', '\u2AC0': 'supplus', '\u2AC1': 'submult', '\u2AC2': 'supmult', '\u2AC3': 'subedot', '\u2AC4': 'supedot', '\u2AC5': 'subE', '\u2AC5\u0338': 'nsubE', '\u2AC6': 'supE', '\u2AC6\u0338': 'nsupE', '\u2AC7': 'subsim', '\u2AC8': 'supsim', '\u2ACB\uFE00': 'vsubnE', '\u2ACB': 'subnE', '\u2ACC\uFE00': 'vsupnE', '\u2ACC': 'supnE', '\u2ACF': 'csub', '\u2AD0': 'csup', '\u2AD1': 'csube', '\u2AD2': 'csupe', '\u2AD3': 'subsup', '\u2AD4': 'supsub', '\u2AD5': 'subsub', '\u2AD6': 'supsup', '\u2AD7': 'suphsub', '\u2AD8': 'supdsub', '\u2AD9': 'forkv', '\u2ADA': 'topfork', '\u2ADB': 'mlcp', '\u2AE4': 'Dashv', '\u2AE6': 'Vdashl', '\u2AE7': 'Barv', '\u2AE8': 'vBar', '\u2AE9': 'vBarv', '\u2AEB': 'Vbar', '\u2AEC': 'Not', '\u2AED': 'bNot', '\u2AEE': 'rnmid', '\u2AEF': 'cirmid', '\u2AF0': 'midcir', '\u2AF1': 'topcir', '\u2AF2': 'nhpar', '\u2AF3': 'parsim', '\u2AFD': 'parsl', '\u2AFD\u20E5': 'nparsl', '\u266D': 'flat', '\u266E': 'natur', '\u266F': 'sharp', '\xA4': 'curren', '\xA2': 'cent', '$': 'dollar', '\xA3': 'pound', '\xA5': 'yen', '\u20AC': 'euro', '\xB9': 'sup1', '\xBD': 'half', '\u2153': 'frac13', '\xBC': 'frac14', '\u2155': 'frac15', '\u2159': 'frac16', '\u215B': 'frac18', '\xB2': 'sup2', '\u2154': 'frac23', '\u2156': 'frac25', '\xB3': 'sup3', '\xBE': 'frac34', '\u2157': 'frac35', '\u215C': 'frac38', '\u2158': 'frac45', '\u215A': 'frac56', '\u215D': 'frac58', '\u215E': 'frac78', '\uD835\uDCB6': 'ascr', '\uD835\uDD52': 'aopf', '\uD835\uDD1E': 'afr', '\uD835\uDD38': 'Aopf', '\uD835\uDD04': 'Afr', '\uD835\uDC9C': 'Ascr', '\xAA': 'ordf', '\xE1': 'aacute', '\xC1': 'Aacute', '\xE0': 'agrave', '\xC0': 'Agrave', '\u0103': 'abreve', '\u0102': 'Abreve', '\xE2': 'acirc', '\xC2': 'Acirc', '\xE5': 'aring', '\xC5': 'angst', '\xE4': 'auml', '\xC4': 'Auml', '\xE3': 'atilde', '\xC3': 'Atilde', '\u0105': 'aogon', '\u0104': 'Aogon', '\u0101': 'amacr', '\u0100': 'Amacr', '\xE6': 'aelig', '\xC6': 'AElig', '\uD835\uDCB7': 'bscr', '\uD835\uDD53': 'bopf', '\uD835\uDD1F': 'bfr', '\uD835\uDD39': 'Bopf', '\u212C': 'Bscr', '\uD835\uDD05': 'Bfr', '\uD835\uDD20': 'cfr', '\uD835\uDCB8': 'cscr', '\uD835\uDD54': 'copf', '\u212D': 'Cfr', '\uD835\uDC9E': 'Cscr', '\u2102': 'Copf', '\u0107': 'cacute', '\u0106': 'Cacute', '\u0109': 'ccirc', '\u0108': 'Ccirc', '\u010D': 'ccaron', '\u010C': 'Ccaron', '\u010B': 'cdot', '\u010A': 'Cdot', '\xE7': 'ccedil', '\xC7': 'Ccedil', '\u2105': 'incare', '\uD835\uDD21': 'dfr', '\u2146': 'dd', '\uD835\uDD55': 'dopf', '\uD835\uDCB9': 'dscr', '\uD835\uDC9F': 'Dscr', '\uD835\uDD07': 'Dfr', '\u2145': 'DD', '\uD835\uDD3B': 'Dopf', '\u010F': 'dcaron', '\u010E': 'Dcaron', '\u0111': 'dstrok', '\u0110': 'Dstrok', '\xF0': 'eth', '\xD0': 'ETH', '\u2147': 'ee', '\u212F': 'escr', '\uD835\uDD22': 'efr', '\uD835\uDD56': 'eopf', '\u2130': 'Escr', '\uD835\uDD08': 'Efr', '\uD835\uDD3C': 'Eopf', '\xE9': 'eacute', '\xC9': 'Eacute', '\xE8': 'egrave', '\xC8': 'Egrave', '\xEA': 'ecirc', '\xCA': 'Ecirc', '\u011B': 'ecaron', '\u011A': 'Ecaron', '\xEB': 'euml', '\xCB': 'Euml', '\u0117': 'edot', '\u0116': 'Edot', '\u0119': 'eogon', '\u0118': 'Eogon', '\u0113': 'emacr', '\u0112': 'Emacr', '\uD835\uDD23': 'ffr', '\uD835\uDD57': 'fopf', '\uD835\uDCBB': 'fscr', '\uD835\uDD09': 'Ffr', '\uD835\uDD3D': 'Fopf', '\u2131': 'Fscr', '\uFB00': 'fflig', '\uFB03': 'ffilig', '\uFB04': 'ffllig', '\uFB01': 'filig', 'fj': 'fjlig', '\uFB02': 'fllig', '\u0192': 'fnof', '\u210A': 'gscr', '\uD835\uDD58': 'gopf', '\uD835\uDD24': 'gfr', '\uD835\uDCA2': 'Gscr', '\uD835\uDD3E': 'Gopf', '\uD835\uDD0A': 'Gfr', '\u01F5': 'gacute', '\u011F': 'gbreve', '\u011E': 'Gbreve', '\u011D': 'gcirc', '\u011C': 'Gcirc', '\u0121': 'gdot', '\u0120': 'Gdot', '\u0122': 'Gcedil', '\uD835\uDD25': 'hfr', '\u210E': 'planckh', '\uD835\uDCBD': 'hscr', '\uD835\uDD59': 'hopf', '\u210B': 'Hscr', '\u210C': 'Hfr', '\u210D': 'Hopf', '\u0125': 'hcirc', '\u0124': 'Hcirc', '\u210F': 'hbar', '\u0127': 'hstrok', '\u0126': 'Hstrok', '\uD835\uDD5A': 'iopf', '\uD835\uDD26': 'ifr', '\uD835\uDCBE': 'iscr', '\u2148': 'ii', '\uD835\uDD40': 'Iopf', '\u2110': 'Iscr', '\u2111': 'Im', '\xED': 'iacute', '\xCD': 'Iacute', '\xEC': 'igrave', '\xCC': 'Igrave', '\xEE': 'icirc', '\xCE': 'Icirc', '\xEF': 'iuml', '\xCF': 'Iuml', '\u0129': 'itilde', '\u0128': 'Itilde', '\u0130': 'Idot', '\u012F': 'iogon', '\u012E': 'Iogon', '\u012B': 'imacr', '\u012A': 'Imacr', '\u0133': 'ijlig', '\u0132': 'IJlig', '\u0131': 'imath', '\uD835\uDCBF': 'jscr', '\uD835\uDD5B': 'jopf', '\uD835\uDD27': 'jfr', '\uD835\uDCA5': 'Jscr', '\uD835\uDD0D': 'Jfr', '\uD835\uDD41': 'Jopf', '\u0135': 'jcirc', '\u0134': 'Jcirc', '\u0237': 'jmath', '\uD835\uDD5C': 'kopf', '\uD835\uDCC0': 'kscr', '\uD835\uDD28': 'kfr', '\uD835\uDCA6': 'Kscr', '\uD835\uDD42': 'Kopf', '\uD835\uDD0E': 'Kfr', '\u0137': 'kcedil', '\u0136': 'Kcedil', '\uD835\uDD29': 'lfr', '\uD835\uDCC1': 'lscr', '\u2113': 'ell', '\uD835\uDD5D': 'lopf', '\u2112': 'Lscr', '\uD835\uDD0F': 'Lfr', '\uD835\uDD43': 'Lopf', '\u013A': 'lacute', '\u0139': 'Lacute', '\u013E': 'lcaron', '\u013D': 'Lcaron', '\u013C': 'lcedil', '\u013B': 'Lcedil', '\u0142': 'lstrok', '\u0141': 'Lstrok', '\u0140': 'lmidot', '\u013F': 'Lmidot', '\uD835\uDD2A': 'mfr', '\uD835\uDD5E': 'mopf', '\uD835\uDCC2': 'mscr', '\uD835\uDD10': 'Mfr', '\uD835\uDD44': 'Mopf', '\u2133': 'Mscr', '\uD835\uDD2B': 'nfr', '\uD835\uDD5F': 'nopf', '\uD835\uDCC3': 'nscr', '\u2115': 'Nopf', '\uD835\uDCA9': 'Nscr', '\uD835\uDD11': 'Nfr', '\u0144': 'nacute', '\u0143': 'Nacute', '\u0148': 'ncaron', '\u0147': 'Ncaron', '\xF1': 'ntilde', '\xD1': 'Ntilde', '\u0146': 'ncedil', '\u0145': 'Ncedil', '\u2116': 'numero', '\u014B': 'eng', '\u014A': 'ENG', '\uD835\uDD60': 'oopf', '\uD835\uDD2C': 'ofr', '\u2134': 'oscr', '\uD835\uDCAA': 'Oscr', '\uD835\uDD12': 'Ofr', '\uD835\uDD46': 'Oopf', '\xBA': 'ordm', '\xF3': 'oacute', '\xD3': 'Oacute', '\xF2': 'ograve', '\xD2': 'Ograve', '\xF4': 'ocirc', '\xD4': 'Ocirc', '\xF6': 'ouml', '\xD6': 'Ouml', '\u0151': 'odblac', '\u0150': 'Odblac', '\xF5': 'otilde', '\xD5': 'Otilde', '\xF8': 'oslash', '\xD8': 'Oslash', '\u014D': 'omacr', '\u014C': 'Omacr', '\u0153': 'oelig', '\u0152': 'OElig', '\uD835\uDD2D': 'pfr', '\uD835\uDCC5': 'pscr', '\uD835\uDD61': 'popf', '\u2119': 'Popf', '\uD835\uDD13': 'Pfr', '\uD835\uDCAB': 'Pscr', '\uD835\uDD62': 'qopf', '\uD835\uDD2E': 'qfr', '\uD835\uDCC6': 'qscr', '\uD835\uDCAC': 'Qscr', '\uD835\uDD14': 'Qfr', '\u211A': 'Qopf', '\u0138': 'kgreen', '\uD835\uDD2F': 'rfr', '\uD835\uDD63': 'ropf', '\uD835\uDCC7': 'rscr', '\u211B': 'Rscr', '\u211C': 'Re', '\u211D': 'Ropf', '\u0155': 'racute', '\u0154': 'Racute', '\u0159': 'rcaron', '\u0158': 'Rcaron', '\u0157': 'rcedil', '\u0156': 'Rcedil', '\uD835\uDD64': 'sopf', '\uD835\uDCC8': 'sscr', '\uD835\uDD30': 'sfr', '\uD835\uDD4A': 'Sopf', '\uD835\uDD16': 'Sfr', '\uD835\uDCAE': 'Sscr', '\u24C8': 'oS', '\u015B': 'sacute', '\u015A': 'Sacute', '\u015D': 'scirc', '\u015C': 'Scirc', '\u0161': 'scaron', '\u0160': 'Scaron', '\u015F': 'scedil', '\u015E': 'Scedil', '\xDF': 'szlig', '\uD835\uDD31': 'tfr', '\uD835\uDCC9': 'tscr', '\uD835\uDD65': 'topf', '\uD835\uDCAF': 'Tscr', '\uD835\uDD17': 'Tfr', '\uD835\uDD4B': 'Topf', '\u0165': 'tcaron', '\u0164': 'Tcaron', '\u0163': 'tcedil', '\u0162': 'Tcedil', '\u2122': 'trade', '\u0167': 'tstrok', '\u0166': 'Tstrok', '\uD835\uDCCA': 'uscr', '\uD835\uDD66': 'uopf', '\uD835\uDD32': 'ufr', '\uD835\uDD4C': 'Uopf', '\uD835\uDD18': 'Ufr', '\uD835\uDCB0': 'Uscr', '\xFA': 'uacute', '\xDA': 'Uacute', '\xF9': 'ugrave', '\xD9': 'Ugrave', '\u016D': 'ubreve', '\u016C': 'Ubreve', '\xFB': 'ucirc', '\xDB': 'Ucirc', '\u016F': 'uring', '\u016E': 'Uring', '\xFC': 'uuml', '\xDC': 'Uuml', '\u0171': 'udblac', '\u0170': 'Udblac', '\u0169': 'utilde', '\u0168': 'Utilde', '\u0173': 'uogon', '\u0172': 'Uogon', '\u016B': 'umacr', '\u016A': 'Umacr', '\uD835\uDD33': 'vfr', '\uD835\uDD67': 'vopf', '\uD835\uDCCB': 'vscr', '\uD835\uDD19': 'Vfr', '\uD835\uDD4D': 'Vopf', '\uD835\uDCB1': 'Vscr', '\uD835\uDD68': 'wopf', '\uD835\uDCCC': 'wscr', '\uD835\uDD34': 'wfr', '\uD835\uDCB2': 'Wscr', '\uD835\uDD4E': 'Wopf', '\uD835\uDD1A': 'Wfr', '\u0175': 'wcirc', '\u0174': 'Wcirc', '\uD835\uDD35': 'xfr', '\uD835\uDCCD': 'xscr', '\uD835\uDD69': 'xopf', '\uD835\uDD4F': 'Xopf', '\uD835\uDD1B': 'Xfr', '\uD835\uDCB3': 'Xscr', '\uD835\uDD36': 'yfr', '\uD835\uDCCE': 'yscr', '\uD835\uDD6A': 'yopf', '\uD835\uDCB4': 'Yscr', '\uD835\uDD1C': 'Yfr', '\uD835\uDD50': 'Yopf', '\xFD': 'yacute', '\xDD': 'Yacute', '\u0177': 'ycirc', '\u0176': 'Ycirc', '\xFF': 'yuml', '\u0178': 'Yuml', '\uD835\uDCCF': 'zscr', '\uD835\uDD37': 'zfr', '\uD835\uDD6B': 'zopf', '\u2128': 'Zfr', '\u2124': 'Zopf', '\uD835\uDCB5': 'Zscr', '\u017A': 'zacute', '\u0179': 'Zacute', '\u017E': 'zcaron', '\u017D': 'Zcaron', '\u017C': 'zdot', '\u017B': 'Zdot', '\u01B5': 'imped', '\xFE': 'thorn', '\xDE': 'THORN', '\u0149': 'napos', '\u03B1': 'alpha', '\u0391': 'Alpha', '\u03B2': 'beta', '\u0392': 'Beta', '\u03B3': 'gamma', '\u0393': 'Gamma', '\u03B4': 'delta', '\u0394': 'Delta', '\u03B5': 'epsi', '\u03F5': 'epsiv', '\u0395': 'Epsilon', '\u03DD': 'gammad', '\u03DC': 'Gammad', '\u03B6': 'zeta', '\u0396': 'Zeta', '\u03B7': 'eta', '\u0397': 'Eta', '\u03B8': 'theta', '\u03D1': 'thetav', '\u0398': 'Theta', '\u03B9': 'iota', '\u0399': 'Iota', '\u03BA': 'kappa', '\u03F0': 'kappav', '\u039A': 'Kappa', '\u03BB': 'lambda', '\u039B': 'Lambda', '\u03BC': 'mu', '\xB5': 'micro', '\u039C': 'Mu', '\u03BD': 'nu', '\u039D': 'Nu', '\u03BE': 'xi', '\u039E': 'Xi', '\u03BF': 'omicron', '\u039F': 'Omicron', '\u03C0': 'pi', '\u03D6': 'piv', '\u03A0': 'Pi', '\u03C1': 'rho', '\u03F1': 'rhov', '\u03A1': 'Rho', '\u03C3': 'sigma', '\u03A3': 'Sigma', '\u03C2': 'sigmaf', '\u03C4': 'tau', '\u03A4': 'Tau', '\u03C5': 'upsi', '\u03A5': 'Upsilon', '\u03D2': 'Upsi', '\u03C6': 'phi', '\u03D5': 'phiv', '\u03A6': 'Phi', '\u03C7': 'chi', '\u03A7': 'Chi', '\u03C8': 'psi', '\u03A8': 'Psi', '\u03C9': 'omega', '\u03A9': 'ohm', '\u0430': 'acy', '\u0410': 'Acy', '\u0431': 'bcy', '\u0411': 'Bcy', '\u0432': 'vcy', '\u0412': 'Vcy', '\u0433': 'gcy', '\u0413': 'Gcy', '\u0453': 'gjcy', '\u0403': 'GJcy', '\u0434': 'dcy', '\u0414': 'Dcy', '\u0452': 'djcy', '\u0402': 'DJcy', '\u0435': 'iecy', '\u0415': 'IEcy', '\u0451': 'iocy', '\u0401': 'IOcy', '\u0454': 'jukcy', '\u0404': 'Jukcy', '\u0436': 'zhcy', '\u0416': 'ZHcy', '\u0437': 'zcy', '\u0417': 'Zcy', '\u0455': 'dscy', '\u0405': 'DScy', '\u0438': 'icy', '\u0418': 'Icy', '\u0456': 'iukcy', '\u0406': 'Iukcy', '\u0457': 'yicy', '\u0407': 'YIcy', '\u0439': 'jcy', '\u0419': 'Jcy', '\u0458': 'jsercy', '\u0408': 'Jsercy', '\u043A': 'kcy', '\u041A': 'Kcy', '\u045C': 'kjcy', '\u040C': 'KJcy', '\u043B': 'lcy', '\u041B': 'Lcy', '\u0459': 'ljcy', '\u0409': 'LJcy', '\u043C': 'mcy', '\u041C': 'Mcy', '\u043D': 'ncy', '\u041D': 'Ncy', '\u045A': 'njcy', '\u040A': 'NJcy', '\u043E': 'ocy', '\u041E': 'Ocy', '\u043F': 'pcy', '\u041F': 'Pcy', '\u0440': 'rcy', '\u0420': 'Rcy', '\u0441': 'scy', '\u0421': 'Scy', '\u0442': 'tcy', '\u0422': 'Tcy', '\u045B': 'tshcy', '\u040B': 'TSHcy', '\u0443': 'ucy', '\u0423': 'Ucy', '\u045E': 'ubrcy', '\u040E': 'Ubrcy', '\u0444': 'fcy', '\u0424': 'Fcy', '\u0445': 'khcy', '\u0425': 'KHcy', '\u0446': 'tscy', '\u0426': 'TScy', '\u0447': 'chcy', '\u0427': 'CHcy', '\u045F': 'dzcy', '\u040F': 'DZcy', '\u0448': 'shcy', '\u0428': 'SHcy', '\u0449': 'shchcy', '\u0429': 'SHCHcy', '\u044A': 'hardcy', '\u042A': 'HARDcy', '\u044B': 'ycy', '\u042B': 'Ycy', '\u044C': 'softcy', '\u042C': 'SOFTcy', '\u044D': 'ecy', '\u042D': 'Ecy', '\u044E': 'yucy', '\u042E': 'YUcy', '\u044F': 'yacy', '\u042F': 'YAcy', '\u2135': 'aleph', '\u2136': 'beth', '\u2137': 'gimel', '\u2138': 'daleth' }

      var regexEscape = /["&'<>`]/g
      var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
		// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
		// following is not strictly necessary unless its part of a tag or an
		// unquoted attribute value. Were only escaping it to support those
		// situations, and for XML support.
        '>': '&gt;',
		// In Internet Explorer  8, the backtick character can be used
		// to break out of (un)quoted attribute values or HTML comments.
		// See http://html5sec.org/#102, http://html5sec.org/#108, and
		// http://html5sec.org/#133.
        '`': '&#x60;'
      }

      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
      var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g
      var decodeMap = { 'aacute': '\xE1', 'Aacute': '\xC1', 'abreve': '\u0103', 'Abreve': '\u0102', 'ac': '\u223E', 'acd': '\u223F', 'acE': '\u223E\u0333', 'acirc': '\xE2', 'Acirc': '\xC2', 'acute': '\xB4', 'acy': '\u0430', 'Acy': '\u0410', 'aelig': '\xE6', 'AElig': '\xC6', 'af': '\u2061', 'afr': '\uD835\uDD1E', 'Afr': '\uD835\uDD04', 'agrave': '\xE0', 'Agrave': '\xC0', 'alefsym': '\u2135', 'aleph': '\u2135', 'alpha': '\u03B1', 'Alpha': '\u0391', 'amacr': '\u0101', 'Amacr': '\u0100', 'amalg': '\u2A3F', 'amp': '&', 'AMP': '&', 'and': '\u2227', 'And': '\u2A53', 'andand': '\u2A55', 'andd': '\u2A5C', 'andslope': '\u2A58', 'andv': '\u2A5A', 'ang': '\u2220', 'ange': '\u29A4', 'angle': '\u2220', 'angmsd': '\u2221', 'angmsdaa': '\u29A8', 'angmsdab': '\u29A9', 'angmsdac': '\u29AA', 'angmsdad': '\u29AB', 'angmsdae': '\u29AC', 'angmsdaf': '\u29AD', 'angmsdag': '\u29AE', 'angmsdah': '\u29AF', 'angrt': '\u221F', 'angrtvb': '\u22BE', 'angrtvbd': '\u299D', 'angsph': '\u2222', 'angst': '\xC5', 'angzarr': '\u237C', 'aogon': '\u0105', 'Aogon': '\u0104', 'aopf': '\uD835\uDD52', 'Aopf': '\uD835\uDD38', 'ap': '\u2248', 'apacir': '\u2A6F', 'ape': '\u224A', 'apE': '\u2A70', 'apid': '\u224B', 'apos': '\'', 'ApplyFunction': '\u2061', 'approx': '\u2248', 'approxeq': '\u224A', 'aring': '\xE5', 'Aring': '\xC5', 'ascr': '\uD835\uDCB6', 'Ascr': '\uD835\uDC9C', 'Assign': '\u2254', 'ast': '*', 'asymp': '\u2248', 'asympeq': '\u224D', 'atilde': '\xE3', 'Atilde': '\xC3', 'auml': '\xE4', 'Auml': '\xC4', 'awconint': '\u2233', 'awint': '\u2A11', 'backcong': '\u224C', 'backepsilon': '\u03F6', 'backprime': '\u2035', 'backsim': '\u223D', 'backsimeq': '\u22CD', 'Backslash': '\u2216', 'Barv': '\u2AE7', 'barvee': '\u22BD', 'barwed': '\u2305', 'Barwed': '\u2306', 'barwedge': '\u2305', 'bbrk': '\u23B5', 'bbrktbrk': '\u23B6', 'bcong': '\u224C', 'bcy': '\u0431', 'Bcy': '\u0411', 'bdquo': '\u201E', 'becaus': '\u2235', 'because': '\u2235', 'Because': '\u2235', 'bemptyv': '\u29B0', 'bepsi': '\u03F6', 'bernou': '\u212C', 'Bernoullis': '\u212C', 'beta': '\u03B2', 'Beta': '\u0392', 'beth': '\u2136', 'between': '\u226C', 'bfr': '\uD835\uDD1F', 'Bfr': '\uD835\uDD05', 'bigcap': '\u22C2', 'bigcirc': '\u25EF', 'bigcup': '\u22C3', 'bigodot': '\u2A00', 'bigoplus': '\u2A01', 'bigotimes': '\u2A02', 'bigsqcup': '\u2A06', 'bigstar': '\u2605', 'bigtriangledown': '\u25BD', 'bigtriangleup': '\u25B3', 'biguplus': '\u2A04', 'bigvee': '\u22C1', 'bigwedge': '\u22C0', 'bkarow': '\u290D', 'blacklozenge': '\u29EB', 'blacksquare': '\u25AA', 'blacktriangle': '\u25B4', 'blacktriangledown': '\u25BE', 'blacktriangleleft': '\u25C2', 'blacktriangleright': '\u25B8', 'blank': '\u2423', 'blk12': '\u2592', 'blk14': '\u2591', 'blk34': '\u2593', 'block': '\u2588', 'bne': '=\u20E5', 'bnequiv': '\u2261\u20E5', 'bnot': '\u2310', 'bNot': '\u2AED', 'bopf': '\uD835\uDD53', 'Bopf': '\uD835\uDD39', 'bot': '\u22A5', 'bottom': '\u22A5', 'bowtie': '\u22C8', 'boxbox': '\u29C9', 'boxdl': '\u2510', 'boxdL': '\u2555', 'boxDl': '\u2556', 'boxDL': '\u2557', 'boxdr': '\u250C', 'boxdR': '\u2552', 'boxDr': '\u2553', 'boxDR': '\u2554', 'boxh': '\u2500', 'boxH': '\u2550', 'boxhd': '\u252C', 'boxhD': '\u2565', 'boxHd': '\u2564', 'boxHD': '\u2566', 'boxhu': '\u2534', 'boxhU': '\u2568', 'boxHu': '\u2567', 'boxHU': '\u2569', 'boxminus': '\u229F', 'boxplus': '\u229E', 'boxtimes': '\u22A0', 'boxul': '\u2518', 'boxuL': '\u255B', 'boxUl': '\u255C', 'boxUL': '\u255D', 'boxur': '\u2514', 'boxuR': '\u2558', 'boxUr': '\u2559', 'boxUR': '\u255A', 'boxv': '\u2502', 'boxV': '\u2551', 'boxvh': '\u253C', 'boxvH': '\u256A', 'boxVh': '\u256B', 'boxVH': '\u256C', 'boxvl': '\u2524', 'boxvL': '\u2561', 'boxVl': '\u2562', 'boxVL': '\u2563', 'boxvr': '\u251C', 'boxvR': '\u255E', 'boxVr': '\u255F', 'boxVR': '\u2560', 'bprime': '\u2035', 'breve': '\u02D8', 'Breve': '\u02D8', 'brvbar': '\xA6', 'bscr': '\uD835\uDCB7', 'Bscr': '\u212C', 'bsemi': '\u204F', 'bsim': '\u223D', 'bsime': '\u22CD', 'bsol': '\\', 'bsolb': '\u29C5', 'bsolhsub': '\u27C8', 'bull': '\u2022', 'bullet': '\u2022', 'bump': '\u224E', 'bumpe': '\u224F', 'bumpE': '\u2AAE', 'bumpeq': '\u224F', 'Bumpeq': '\u224E', 'cacute': '\u0107', 'Cacute': '\u0106', 'cap': '\u2229', 'Cap': '\u22D2', 'capand': '\u2A44', 'capbrcup': '\u2A49', 'capcap': '\u2A4B', 'capcup': '\u2A47', 'capdot': '\u2A40', 'CapitalDifferentialD': '\u2145', 'caps': '\u2229\uFE00', 'caret': '\u2041', 'caron': '\u02C7', 'Cayleys': '\u212D', 'ccaps': '\u2A4D', 'ccaron': '\u010D', 'Ccaron': '\u010C', 'ccedil': '\xE7', 'Ccedil': '\xC7', 'ccirc': '\u0109', 'Ccirc': '\u0108', 'Cconint': '\u2230', 'ccups': '\u2A4C', 'ccupssm': '\u2A50', 'cdot': '\u010B', 'Cdot': '\u010A', 'cedil': '\xB8', 'Cedilla': '\xB8', 'cemptyv': '\u29B2', 'cent': '\xA2', 'centerdot': '\xB7', 'CenterDot': '\xB7', 'cfr': '\uD835\uDD20', 'Cfr': '\u212D', 'chcy': '\u0447', 'CHcy': '\u0427', 'check': '\u2713', 'checkmark': '\u2713', 'chi': '\u03C7', 'Chi': '\u03A7', 'cir': '\u25CB', 'circ': '\u02C6', 'circeq': '\u2257', 'circlearrowleft': '\u21BA', 'circlearrowright': '\u21BB', 'circledast': '\u229B', 'circledcirc': '\u229A', 'circleddash': '\u229D', 'CircleDot': '\u2299', 'circledR': '\xAE', 'circledS': '\u24C8', 'CircleMinus': '\u2296', 'CirclePlus': '\u2295', 'CircleTimes': '\u2297', 'cire': '\u2257', 'cirE': '\u29C3', 'cirfnint': '\u2A10', 'cirmid': '\u2AEF', 'cirscir': '\u29C2', 'ClockwiseContourIntegral': '\u2232', 'CloseCurlyDoubleQuote': '\u201D', 'CloseCurlyQuote': '\u2019', 'clubs': '\u2663', 'clubsuit': '\u2663', 'colon': ':', 'Colon': '\u2237', 'colone': '\u2254', 'Colone': '\u2A74', 'coloneq': '\u2254', 'comma': ',', 'commat': '@', 'comp': '\u2201', 'compfn': '\u2218', 'complement': '\u2201', 'complexes': '\u2102', 'cong': '\u2245', 'congdot': '\u2A6D', 'Congruent': '\u2261', 'conint': '\u222E', 'Conint': '\u222F', 'ContourIntegral': '\u222E', 'copf': '\uD835\uDD54', 'Copf': '\u2102', 'coprod': '\u2210', 'Coproduct': '\u2210', 'copy': '\xA9', 'COPY': '\xA9', 'copysr': '\u2117', 'CounterClockwiseContourIntegral': '\u2233', 'crarr': '\u21B5', 'cross': '\u2717', 'Cross': '\u2A2F', 'cscr': '\uD835\uDCB8', 'Cscr': '\uD835\uDC9E', 'csub': '\u2ACF', 'csube': '\u2AD1', 'csup': '\u2AD0', 'csupe': '\u2AD2', 'ctdot': '\u22EF', 'cudarrl': '\u2938', 'cudarrr': '\u2935', 'cuepr': '\u22DE', 'cuesc': '\u22DF', 'cularr': '\u21B6', 'cularrp': '\u293D', 'cup': '\u222A', 'Cup': '\u22D3', 'cupbrcap': '\u2A48', 'cupcap': '\u2A46', 'CupCap': '\u224D', 'cupcup': '\u2A4A', 'cupdot': '\u228D', 'cupor': '\u2A45', 'cups': '\u222A\uFE00', 'curarr': '\u21B7', 'curarrm': '\u293C', 'curlyeqprec': '\u22DE', 'curlyeqsucc': '\u22DF', 'curlyvee': '\u22CE', 'curlywedge': '\u22CF', 'curren': '\xA4', 'curvearrowleft': '\u21B6', 'curvearrowright': '\u21B7', 'cuvee': '\u22CE', 'cuwed': '\u22CF', 'cwconint': '\u2232', 'cwint': '\u2231', 'cylcty': '\u232D', 'dagger': '\u2020', 'Dagger': '\u2021', 'daleth': '\u2138', 'darr': '\u2193', 'dArr': '\u21D3', 'Darr': '\u21A1', 'dash': '\u2010', 'dashv': '\u22A3', 'Dashv': '\u2AE4', 'dbkarow': '\u290F', 'dblac': '\u02DD', 'dcaron': '\u010F', 'Dcaron': '\u010E', 'dcy': '\u0434', 'Dcy': '\u0414', 'dd': '\u2146', 'DD': '\u2145', 'ddagger': '\u2021', 'ddarr': '\u21CA', 'DDotrahd': '\u2911', 'ddotseq': '\u2A77', 'deg': '\xB0', 'Del': '\u2207', 'delta': '\u03B4', 'Delta': '\u0394', 'demptyv': '\u29B1', 'dfisht': '\u297F', 'dfr': '\uD835\uDD21', 'Dfr': '\uD835\uDD07', 'dHar': '\u2965', 'dharl': '\u21C3', 'dharr': '\u21C2', 'DiacriticalAcute': '\xB4', 'DiacriticalDot': '\u02D9', 'DiacriticalDoubleAcute': '\u02DD', 'DiacriticalGrave': '`', 'DiacriticalTilde': '\u02DC', 'diam': '\u22C4', 'diamond': '\u22C4', 'Diamond': '\u22C4', 'diamondsuit': '\u2666', 'diams': '\u2666', 'die': '\xA8', 'DifferentialD': '\u2146', 'digamma': '\u03DD', 'disin': '\u22F2', 'div': '\xF7', 'divide': '\xF7', 'divideontimes': '\u22C7', 'divonx': '\u22C7', 'djcy': '\u0452', 'DJcy': '\u0402', 'dlcorn': '\u231E', 'dlcrop': '\u230D', 'dollar': '$', 'dopf': '\uD835\uDD55', 'Dopf': '\uD835\uDD3B', 'dot': '\u02D9', 'Dot': '\xA8', 'DotDot': '\u20DC', 'doteq': '\u2250', 'doteqdot': '\u2251', 'DotEqual': '\u2250', 'dotminus': '\u2238', 'dotplus': '\u2214', 'dotsquare': '\u22A1', 'doublebarwedge': '\u2306', 'DoubleContourIntegral': '\u222F', 'DoubleDot': '\xA8', 'DoubleDownArrow': '\u21D3', 'DoubleLeftArrow': '\u21D0', 'DoubleLeftRightArrow': '\u21D4', 'DoubleLeftTee': '\u2AE4', 'DoubleLongLeftArrow': '\u27F8', 'DoubleLongLeftRightArrow': '\u27FA', 'DoubleLongRightArrow': '\u27F9', 'DoubleRightArrow': '\u21D2', 'DoubleRightTee': '\u22A8', 'DoubleUpArrow': '\u21D1', 'DoubleUpDownArrow': '\u21D5', 'DoubleVerticalBar': '\u2225', 'downarrow': '\u2193', 'Downarrow': '\u21D3', 'DownArrow': '\u2193', 'DownArrowBar': '\u2913', 'DownArrowUpArrow': '\u21F5', 'DownBreve': '\u0311', 'downdownarrows': '\u21CA', 'downharpoonleft': '\u21C3', 'downharpoonright': '\u21C2', 'DownLeftRightVector': '\u2950', 'DownLeftTeeVector': '\u295E', 'DownLeftVector': '\u21BD', 'DownLeftVectorBar': '\u2956', 'DownRightTeeVector': '\u295F', 'DownRightVector': '\u21C1', 'DownRightVectorBar': '\u2957', 'DownTee': '\u22A4', 'DownTeeArrow': '\u21A7', 'drbkarow': '\u2910', 'drcorn': '\u231F', 'drcrop': '\u230C', 'dscr': '\uD835\uDCB9', 'Dscr': '\uD835\uDC9F', 'dscy': '\u0455', 'DScy': '\u0405', 'dsol': '\u29F6', 'dstrok': '\u0111', 'Dstrok': '\u0110', 'dtdot': '\u22F1', 'dtri': '\u25BF', 'dtrif': '\u25BE', 'duarr': '\u21F5', 'duhar': '\u296F', 'dwangle': '\u29A6', 'dzcy': '\u045F', 'DZcy': '\u040F', 'dzigrarr': '\u27FF', 'eacute': '\xE9', 'Eacute': '\xC9', 'easter': '\u2A6E', 'ecaron': '\u011B', 'Ecaron': '\u011A', 'ecir': '\u2256', 'ecirc': '\xEA', 'Ecirc': '\xCA', 'ecolon': '\u2255', 'ecy': '\u044D', 'Ecy': '\u042D', 'eDDot': '\u2A77', 'edot': '\u0117', 'eDot': '\u2251', 'Edot': '\u0116', 'ee': '\u2147', 'efDot': '\u2252', 'efr': '\uD835\uDD22', 'Efr': '\uD835\uDD08', 'eg': '\u2A9A', 'egrave': '\xE8', 'Egrave': '\xC8', 'egs': '\u2A96', 'egsdot': '\u2A98', 'el': '\u2A99', 'Element': '\u2208', 'elinters': '\u23E7', 'ell': '\u2113', 'els': '\u2A95', 'elsdot': '\u2A97', 'emacr': '\u0113', 'Emacr': '\u0112', 'empty': '\u2205', 'emptyset': '\u2205', 'EmptySmallSquare': '\u25FB', 'emptyv': '\u2205', 'EmptyVerySmallSquare': '\u25AB', 'emsp': '\u2003', 'emsp13': '\u2004', 'emsp14': '\u2005', 'eng': '\u014B', 'ENG': '\u014A', 'ensp': '\u2002', 'eogon': '\u0119', 'Eogon': '\u0118', 'eopf': '\uD835\uDD56', 'Eopf': '\uD835\uDD3C', 'epar': '\u22D5', 'eparsl': '\u29E3', 'eplus': '\u2A71', 'epsi': '\u03B5', 'epsilon': '\u03B5', 'Epsilon': '\u0395', 'epsiv': '\u03F5', 'eqcirc': '\u2256', 'eqcolon': '\u2255', 'eqsim': '\u2242', 'eqslantgtr': '\u2A96', 'eqslantless': '\u2A95', 'Equal': '\u2A75', 'equals': '=', 'EqualTilde': '\u2242', 'equest': '\u225F', 'Equilibrium': '\u21CC', 'equiv': '\u2261', 'equivDD': '\u2A78', 'eqvparsl': '\u29E5', 'erarr': '\u2971', 'erDot': '\u2253', 'escr': '\u212F', 'Escr': '\u2130', 'esdot': '\u2250', 'esim': '\u2242', 'Esim': '\u2A73', 'eta': '\u03B7', 'Eta': '\u0397', 'eth': '\xF0', 'ETH': '\xD0', 'euml': '\xEB', 'Euml': '\xCB', 'euro': '\u20AC', 'excl': '!', 'exist': '\u2203', 'Exists': '\u2203', 'expectation': '\u2130', 'exponentiale': '\u2147', 'ExponentialE': '\u2147', 'fallingdotseq': '\u2252', 'fcy': '\u0444', 'Fcy': '\u0424', 'female': '\u2640', 'ffilig': '\uFB03', 'fflig': '\uFB00', 'ffllig': '\uFB04', 'ffr': '\uD835\uDD23', 'Ffr': '\uD835\uDD09', 'filig': '\uFB01', 'FilledSmallSquare': '\u25FC', 'FilledVerySmallSquare': '\u25AA', 'fjlig': 'fj', 'flat': '\u266D', 'fllig': '\uFB02', 'fltns': '\u25B1', 'fnof': '\u0192', 'fopf': '\uD835\uDD57', 'Fopf': '\uD835\uDD3D', 'forall': '\u2200', 'ForAll': '\u2200', 'fork': '\u22D4', 'forkv': '\u2AD9', 'Fouriertrf': '\u2131', 'fpartint': '\u2A0D', 'frac12': '\xBD', 'frac13': '\u2153', 'frac14': '\xBC', 'frac15': '\u2155', 'frac16': '\u2159', 'frac18': '\u215B', 'frac23': '\u2154', 'frac25': '\u2156', 'frac34': '\xBE', 'frac35': '\u2157', 'frac38': '\u215C', 'frac45': '\u2158', 'frac56': '\u215A', 'frac58': '\u215D', 'frac78': '\u215E', 'frasl': '\u2044', 'frown': '\u2322', 'fscr': '\uD835\uDCBB', 'Fscr': '\u2131', 'gacute': '\u01F5', 'gamma': '\u03B3', 'Gamma': '\u0393', 'gammad': '\u03DD', 'Gammad': '\u03DC', 'gap': '\u2A86', 'gbreve': '\u011F', 'Gbreve': '\u011E', 'Gcedil': '\u0122', 'gcirc': '\u011D', 'Gcirc': '\u011C', 'gcy': '\u0433', 'Gcy': '\u0413', 'gdot': '\u0121', 'Gdot': '\u0120', 'ge': '\u2265', 'gE': '\u2267', 'gel': '\u22DB', 'gEl': '\u2A8C', 'geq': '\u2265', 'geqq': '\u2267', 'geqslant': '\u2A7E', 'ges': '\u2A7E', 'gescc': '\u2AA9', 'gesdot': '\u2A80', 'gesdoto': '\u2A82', 'gesdotol': '\u2A84', 'gesl': '\u22DB\uFE00', 'gesles': '\u2A94', 'gfr': '\uD835\uDD24', 'Gfr': '\uD835\uDD0A', 'gg': '\u226B', 'Gg': '\u22D9', 'ggg': '\u22D9', 'gimel': '\u2137', 'gjcy': '\u0453', 'GJcy': '\u0403', 'gl': '\u2277', 'gla': '\u2AA5', 'glE': '\u2A92', 'glj': '\u2AA4', 'gnap': '\u2A8A', 'gnapprox': '\u2A8A', 'gne': '\u2A88', 'gnE': '\u2269', 'gneq': '\u2A88', 'gneqq': '\u2269', 'gnsim': '\u22E7', 'gopf': '\uD835\uDD58', 'Gopf': '\uD835\uDD3E', 'grave': '`', 'GreaterEqual': '\u2265', 'GreaterEqualLess': '\u22DB', 'GreaterFullEqual': '\u2267', 'GreaterGreater': '\u2AA2', 'GreaterLess': '\u2277', 'GreaterSlantEqual': '\u2A7E', 'GreaterTilde': '\u2273', 'gscr': '\u210A', 'Gscr': '\uD835\uDCA2', 'gsim': '\u2273', 'gsime': '\u2A8E', 'gsiml': '\u2A90', 'gt': '>', 'Gt': '\u226B', 'GT': '>', 'gtcc': '\u2AA7', 'gtcir': '\u2A7A', 'gtdot': '\u22D7', 'gtlPar': '\u2995', 'gtquest': '\u2A7C', 'gtrapprox': '\u2A86', 'gtrarr': '\u2978', 'gtrdot': '\u22D7', 'gtreqless': '\u22DB', 'gtreqqless': '\u2A8C', 'gtrless': '\u2277', 'gtrsim': '\u2273', 'gvertneqq': '\u2269\uFE00', 'gvnE': '\u2269\uFE00', 'Hacek': '\u02C7', 'hairsp': '\u200A', 'half': '\xBD', 'hamilt': '\u210B', 'hardcy': '\u044A', 'HARDcy': '\u042A', 'harr': '\u2194', 'hArr': '\u21D4', 'harrcir': '\u2948', 'harrw': '\u21AD', 'Hat': '^', 'hbar': '\u210F', 'hcirc': '\u0125', 'Hcirc': '\u0124', 'hearts': '\u2665', 'heartsuit': '\u2665', 'hellip': '\u2026', 'hercon': '\u22B9', 'hfr': '\uD835\uDD25', 'Hfr': '\u210C', 'HilbertSpace': '\u210B', 'hksearow': '\u2925', 'hkswarow': '\u2926', 'hoarr': '\u21FF', 'homtht': '\u223B', 'hookleftarrow': '\u21A9', 'hookrightarrow': '\u21AA', 'hopf': '\uD835\uDD59', 'Hopf': '\u210D', 'horbar': '\u2015', 'HorizontalLine': '\u2500', 'hscr': '\uD835\uDCBD', 'Hscr': '\u210B', 'hslash': '\u210F', 'hstrok': '\u0127', 'Hstrok': '\u0126', 'HumpDownHump': '\u224E', 'HumpEqual': '\u224F', 'hybull': '\u2043', 'hyphen': '\u2010', 'iacute': '\xED', 'Iacute': '\xCD', 'ic': '\u2063', 'icirc': '\xEE', 'Icirc': '\xCE', 'icy': '\u0438', 'Icy': '\u0418', 'Idot': '\u0130', 'iecy': '\u0435', 'IEcy': '\u0415', 'iexcl': '\xA1', 'iff': '\u21D4', 'ifr': '\uD835\uDD26', 'Ifr': '\u2111', 'igrave': '\xEC', 'Igrave': '\xCC', 'ii': '\u2148', 'iiiint': '\u2A0C', 'iiint': '\u222D', 'iinfin': '\u29DC', 'iiota': '\u2129', 'ijlig': '\u0133', 'IJlig': '\u0132', 'Im': '\u2111', 'imacr': '\u012B', 'Imacr': '\u012A', 'image': '\u2111', 'ImaginaryI': '\u2148', 'imagline': '\u2110', 'imagpart': '\u2111', 'imath': '\u0131', 'imof': '\u22B7', 'imped': '\u01B5', 'Implies': '\u21D2', 'in': '\u2208', 'incare': '\u2105', 'infin': '\u221E', 'infintie': '\u29DD', 'inodot': '\u0131', 'int': '\u222B', 'Int': '\u222C', 'intcal': '\u22BA', 'integers': '\u2124', 'Integral': '\u222B', 'intercal': '\u22BA', 'Intersection': '\u22C2', 'intlarhk': '\u2A17', 'intprod': '\u2A3C', 'InvisibleComma': '\u2063', 'InvisibleTimes': '\u2062', 'iocy': '\u0451', 'IOcy': '\u0401', 'iogon': '\u012F', 'Iogon': '\u012E', 'iopf': '\uD835\uDD5A', 'Iopf': '\uD835\uDD40', 'iota': '\u03B9', 'Iota': '\u0399', 'iprod': '\u2A3C', 'iquest': '\xBF', 'iscr': '\uD835\uDCBE', 'Iscr': '\u2110', 'isin': '\u2208', 'isindot': '\u22F5', 'isinE': '\u22F9', 'isins': '\u22F4', 'isinsv': '\u22F3', 'isinv': '\u2208', 'it': '\u2062', 'itilde': '\u0129', 'Itilde': '\u0128', 'iukcy': '\u0456', 'Iukcy': '\u0406', 'iuml': '\xEF', 'Iuml': '\xCF', 'jcirc': '\u0135', 'Jcirc': '\u0134', 'jcy': '\u0439', 'Jcy': '\u0419', 'jfr': '\uD835\uDD27', 'Jfr': '\uD835\uDD0D', 'jmath': '\u0237', 'jopf': '\uD835\uDD5B', 'Jopf': '\uD835\uDD41', 'jscr': '\uD835\uDCBF', 'Jscr': '\uD835\uDCA5', 'jsercy': '\u0458', 'Jsercy': '\u0408', 'jukcy': '\u0454', 'Jukcy': '\u0404', 'kappa': '\u03BA', 'Kappa': '\u039A', 'kappav': '\u03F0', 'kcedil': '\u0137', 'Kcedil': '\u0136', 'kcy': '\u043A', 'Kcy': '\u041A', 'kfr': '\uD835\uDD28', 'Kfr': '\uD835\uDD0E', 'kgreen': '\u0138', 'khcy': '\u0445', 'KHcy': '\u0425', 'kjcy': '\u045C', 'KJcy': '\u040C', 'kopf': '\uD835\uDD5C', 'Kopf': '\uD835\uDD42', 'kscr': '\uD835\uDCC0', 'Kscr': '\uD835\uDCA6', 'lAarr': '\u21DA', 'lacute': '\u013A', 'Lacute': '\u0139', 'laemptyv': '\u29B4', 'lagran': '\u2112', 'lambda': '\u03BB', 'Lambda': '\u039B', 'lang': '\u27E8', 'Lang': '\u27EA', 'langd': '\u2991', 'langle': '\u27E8', 'lap': '\u2A85', 'Laplacetrf': '\u2112', 'laquo': '\xAB', 'larr': '\u2190', 'lArr': '\u21D0', 'Larr': '\u219E', 'larrb': '\u21E4', 'larrbfs': '\u291F', 'larrfs': '\u291D', 'larrhk': '\u21A9', 'larrlp': '\u21AB', 'larrpl': '\u2939', 'larrsim': '\u2973', 'larrtl': '\u21A2', 'lat': '\u2AAB', 'latail': '\u2919', 'lAtail': '\u291B', 'late': '\u2AAD', 'lates': '\u2AAD\uFE00', 'lbarr': '\u290C', 'lBarr': '\u290E', 'lbbrk': '\u2772', 'lbrace': '{', 'lbrack': '[', 'lbrke': '\u298B', 'lbrksld': '\u298F', 'lbrkslu': '\u298D', 'lcaron': '\u013E', 'Lcaron': '\u013D', 'lcedil': '\u013C', 'Lcedil': '\u013B', 'lceil': '\u2308', 'lcub': '{', 'lcy': '\u043B', 'Lcy': '\u041B', 'ldca': '\u2936', 'ldquo': '\u201C', 'ldquor': '\u201E', 'ldrdhar': '\u2967', 'ldrushar': '\u294B', 'ldsh': '\u21B2', 'le': '\u2264', 'lE': '\u2266', 'LeftAngleBracket': '\u27E8', 'leftarrow': '\u2190', 'Leftarrow': '\u21D0', 'LeftArrow': '\u2190', 'LeftArrowBar': '\u21E4', 'LeftArrowRightArrow': '\u21C6', 'leftarrowtail': '\u21A2', 'LeftCeiling': '\u2308', 'LeftDoubleBracket': '\u27E6', 'LeftDownTeeVector': '\u2961', 'LeftDownVector': '\u21C3', 'LeftDownVectorBar': '\u2959', 'LeftFloor': '\u230A', 'leftharpoondown': '\u21BD', 'leftharpoonup': '\u21BC', 'leftleftarrows': '\u21C7', 'leftrightarrow': '\u2194', 'Leftrightarrow': '\u21D4', 'LeftRightArrow': '\u2194', 'leftrightarrows': '\u21C6', 'leftrightharpoons': '\u21CB', 'leftrightsquigarrow': '\u21AD', 'LeftRightVector': '\u294E', 'LeftTee': '\u22A3', 'LeftTeeArrow': '\u21A4', 'LeftTeeVector': '\u295A', 'leftthreetimes': '\u22CB', 'LeftTriangle': '\u22B2', 'LeftTriangleBar': '\u29CF', 'LeftTriangleEqual': '\u22B4', 'LeftUpDownVector': '\u2951', 'LeftUpTeeVector': '\u2960', 'LeftUpVector': '\u21BF', 'LeftUpVectorBar': '\u2958', 'LeftVector': '\u21BC', 'LeftVectorBar': '\u2952', 'leg': '\u22DA', 'lEg': '\u2A8B', 'leq': '\u2264', 'leqq': '\u2266', 'leqslant': '\u2A7D', 'les': '\u2A7D', 'lescc': '\u2AA8', 'lesdot': '\u2A7F', 'lesdoto': '\u2A81', 'lesdotor': '\u2A83', 'lesg': '\u22DA\uFE00', 'lesges': '\u2A93', 'lessapprox': '\u2A85', 'lessdot': '\u22D6', 'lesseqgtr': '\u22DA', 'lesseqqgtr': '\u2A8B', 'LessEqualGreater': '\u22DA', 'LessFullEqual': '\u2266', 'LessGreater': '\u2276', 'lessgtr': '\u2276', 'LessLess': '\u2AA1', 'lesssim': '\u2272', 'LessSlantEqual': '\u2A7D', 'LessTilde': '\u2272', 'lfisht': '\u297C', 'lfloor': '\u230A', 'lfr': '\uD835\uDD29', 'Lfr': '\uD835\uDD0F', 'lg': '\u2276', 'lgE': '\u2A91', 'lHar': '\u2962', 'lhard': '\u21BD', 'lharu': '\u21BC', 'lharul': '\u296A', 'lhblk': '\u2584', 'ljcy': '\u0459', 'LJcy': '\u0409', 'll': '\u226A', 'Ll': '\u22D8', 'llarr': '\u21C7', 'llcorner': '\u231E', 'Lleftarrow': '\u21DA', 'llhard': '\u296B', 'lltri': '\u25FA', 'lmidot': '\u0140', 'Lmidot': '\u013F', 'lmoust': '\u23B0', 'lmoustache': '\u23B0', 'lnap': '\u2A89', 'lnapprox': '\u2A89', 'lne': '\u2A87', 'lnE': '\u2268', 'lneq': '\u2A87', 'lneqq': '\u2268', 'lnsim': '\u22E6', 'loang': '\u27EC', 'loarr': '\u21FD', 'lobrk': '\u27E6', 'longleftarrow': '\u27F5', 'Longleftarrow': '\u27F8', 'LongLeftArrow': '\u27F5', 'longleftrightarrow': '\u27F7', 'Longleftrightarrow': '\u27FA', 'LongLeftRightArrow': '\u27F7', 'longmapsto': '\u27FC', 'longrightarrow': '\u27F6', 'Longrightarrow': '\u27F9', 'LongRightArrow': '\u27F6', 'looparrowleft': '\u21AB', 'looparrowright': '\u21AC', 'lopar': '\u2985', 'lopf': '\uD835\uDD5D', 'Lopf': '\uD835\uDD43', 'loplus': '\u2A2D', 'lotimes': '\u2A34', 'lowast': '\u2217', 'lowbar': '_', 'LowerLeftArrow': '\u2199', 'LowerRightArrow': '\u2198', 'loz': '\u25CA', 'lozenge': '\u25CA', 'lozf': '\u29EB', 'lpar': '(', 'lparlt': '\u2993', 'lrarr': '\u21C6', 'lrcorner': '\u231F', 'lrhar': '\u21CB', 'lrhard': '\u296D', 'lrm': '\u200E', 'lrtri': '\u22BF', 'lsaquo': '\u2039', 'lscr': '\uD835\uDCC1', 'Lscr': '\u2112', 'lsh': '\u21B0', 'Lsh': '\u21B0', 'lsim': '\u2272', 'lsime': '\u2A8D', 'lsimg': '\u2A8F', 'lsqb': '[', 'lsquo': '\u2018', 'lsquor': '\u201A', 'lstrok': '\u0142', 'Lstrok': '\u0141', 'lt': '<', 'Lt': '\u226A', 'LT': '<', 'ltcc': '\u2AA6', 'ltcir': '\u2A79', 'ltdot': '\u22D6', 'lthree': '\u22CB', 'ltimes': '\u22C9', 'ltlarr': '\u2976', 'ltquest': '\u2A7B', 'ltri': '\u25C3', 'ltrie': '\u22B4', 'ltrif': '\u25C2', 'ltrPar': '\u2996', 'lurdshar': '\u294A', 'luruhar': '\u2966', 'lvertneqq': '\u2268\uFE00', 'lvnE': '\u2268\uFE00', 'macr': '\xAF', 'male': '\u2642', 'malt': '\u2720', 'maltese': '\u2720', 'map': '\u21A6', 'Map': '\u2905', 'mapsto': '\u21A6', 'mapstodown': '\u21A7', 'mapstoleft': '\u21A4', 'mapstoup': '\u21A5', 'marker': '\u25AE', 'mcomma': '\u2A29', 'mcy': '\u043C', 'Mcy': '\u041C', 'mdash': '\u2014', 'mDDot': '\u223A', 'measuredangle': '\u2221', 'MediumSpace': '\u205F', 'Mellintrf': '\u2133', 'mfr': '\uD835\uDD2A', 'Mfr': '\uD835\uDD10', 'mho': '\u2127', 'micro': '\xB5', 'mid': '\u2223', 'midast': '*', 'midcir': '\u2AF0', 'middot': '\xB7', 'minus': '\u2212', 'minusb': '\u229F', 'minusd': '\u2238', 'minusdu': '\u2A2A', 'MinusPlus': '\u2213', 'mlcp': '\u2ADB', 'mldr': '\u2026', 'mnplus': '\u2213', 'models': '\u22A7', 'mopf': '\uD835\uDD5E', 'Mopf': '\uD835\uDD44', 'mp': '\u2213', 'mscr': '\uD835\uDCC2', 'Mscr': '\u2133', 'mstpos': '\u223E', 'mu': '\u03BC', 'Mu': '\u039C', 'multimap': '\u22B8', 'mumap': '\u22B8', 'nabla': '\u2207', 'nacute': '\u0144', 'Nacute': '\u0143', 'nang': '\u2220\u20D2', 'nap': '\u2249', 'napE': '\u2A70\u0338', 'napid': '\u224B\u0338', 'napos': '\u0149', 'napprox': '\u2249', 'natur': '\u266E', 'natural': '\u266E', 'naturals': '\u2115', 'nbsp': '\xA0', 'nbump': '\u224E\u0338', 'nbumpe': '\u224F\u0338', 'ncap': '\u2A43', 'ncaron': '\u0148', 'Ncaron': '\u0147', 'ncedil': '\u0146', 'Ncedil': '\u0145', 'ncong': '\u2247', 'ncongdot': '\u2A6D\u0338', 'ncup': '\u2A42', 'ncy': '\u043D', 'Ncy': '\u041D', 'ndash': '\u2013', 'ne': '\u2260', 'nearhk': '\u2924', 'nearr': '\u2197', 'neArr': '\u21D7', 'nearrow': '\u2197', 'nedot': '\u2250\u0338', 'NegativeMediumSpace': '\u200B', 'NegativeThickSpace': '\u200B', 'NegativeThinSpace': '\u200B', 'NegativeVeryThinSpace': '\u200B', 'nequiv': '\u2262', 'nesear': '\u2928', 'nesim': '\u2242\u0338', 'NestedGreaterGreater': '\u226B', 'NestedLessLess': '\u226A', 'NewLine': '\n', 'nexist': '\u2204', 'nexists': '\u2204', 'nfr': '\uD835\uDD2B', 'Nfr': '\uD835\uDD11', 'nge': '\u2271', 'ngE': '\u2267\u0338', 'ngeq': '\u2271', 'ngeqq': '\u2267\u0338', 'ngeqslant': '\u2A7E\u0338', 'nges': '\u2A7E\u0338', 'nGg': '\u22D9\u0338', 'ngsim': '\u2275', 'ngt': '\u226F', 'nGt': '\u226B\u20D2', 'ngtr': '\u226F', 'nGtv': '\u226B\u0338', 'nharr': '\u21AE', 'nhArr': '\u21CE', 'nhpar': '\u2AF2', 'ni': '\u220B', 'nis': '\u22FC', 'nisd': '\u22FA', 'niv': '\u220B', 'njcy': '\u045A', 'NJcy': '\u040A', 'nlarr': '\u219A', 'nlArr': '\u21CD', 'nldr': '\u2025', 'nle': '\u2270', 'nlE': '\u2266\u0338', 'nleftarrow': '\u219A', 'nLeftarrow': '\u21CD', 'nleftrightarrow': '\u21AE', 'nLeftrightarrow': '\u21CE', 'nleq': '\u2270', 'nleqq': '\u2266\u0338', 'nleqslant': '\u2A7D\u0338', 'nles': '\u2A7D\u0338', 'nless': '\u226E', 'nLl': '\u22D8\u0338', 'nlsim': '\u2274', 'nlt': '\u226E', 'nLt': '\u226A\u20D2', 'nltri': '\u22EA', 'nltrie': '\u22EC', 'nLtv': '\u226A\u0338', 'nmid': '\u2224', 'NoBreak': '\u2060', 'NonBreakingSpace': '\xA0', 'nopf': '\uD835\uDD5F', 'Nopf': '\u2115', 'not': '\xAC', 'Not': '\u2AEC', 'NotCongruent': '\u2262', 'NotCupCap': '\u226D', 'NotDoubleVerticalBar': '\u2226', 'NotElement': '\u2209', 'NotEqual': '\u2260', 'NotEqualTilde': '\u2242\u0338', 'NotExists': '\u2204', 'NotGreater': '\u226F', 'NotGreaterEqual': '\u2271', 'NotGreaterFullEqual': '\u2267\u0338', 'NotGreaterGreater': '\u226B\u0338', 'NotGreaterLess': '\u2279', 'NotGreaterSlantEqual': '\u2A7E\u0338', 'NotGreaterTilde': '\u2275', 'NotHumpDownHump': '\u224E\u0338', 'NotHumpEqual': '\u224F\u0338', 'notin': '\u2209', 'notindot': '\u22F5\u0338', 'notinE': '\u22F9\u0338', 'notinva': '\u2209', 'notinvb': '\u22F7', 'notinvc': '\u22F6', 'NotLeftTriangle': '\u22EA', 'NotLeftTriangleBar': '\u29CF\u0338', 'NotLeftTriangleEqual': '\u22EC', 'NotLess': '\u226E', 'NotLessEqual': '\u2270', 'NotLessGreater': '\u2278', 'NotLessLess': '\u226A\u0338', 'NotLessSlantEqual': '\u2A7D\u0338', 'NotLessTilde': '\u2274', 'NotNestedGreaterGreater': '\u2AA2\u0338', 'NotNestedLessLess': '\u2AA1\u0338', 'notni': '\u220C', 'notniva': '\u220C', 'notnivb': '\u22FE', 'notnivc': '\u22FD', 'NotPrecedes': '\u2280', 'NotPrecedesEqual': '\u2AAF\u0338', 'NotPrecedesSlantEqual': '\u22E0', 'NotReverseElement': '\u220C', 'NotRightTriangle': '\u22EB', 'NotRightTriangleBar': '\u29D0\u0338', 'NotRightTriangleEqual': '\u22ED', 'NotSquareSubset': '\u228F\u0338', 'NotSquareSubsetEqual': '\u22E2', 'NotSquareSuperset': '\u2290\u0338', 'NotSquareSupersetEqual': '\u22E3', 'NotSubset': '\u2282\u20D2', 'NotSubsetEqual': '\u2288', 'NotSucceeds': '\u2281', 'NotSucceedsEqual': '\u2AB0\u0338', 'NotSucceedsSlantEqual': '\u22E1', 'NotSucceedsTilde': '\u227F\u0338', 'NotSuperset': '\u2283\u20D2', 'NotSupersetEqual': '\u2289', 'NotTilde': '\u2241', 'NotTildeEqual': '\u2244', 'NotTildeFullEqual': '\u2247', 'NotTildeTilde': '\u2249', 'NotVerticalBar': '\u2224', 'npar': '\u2226', 'nparallel': '\u2226', 'nparsl': '\u2AFD\u20E5', 'npart': '\u2202\u0338', 'npolint': '\u2A14', 'npr': '\u2280', 'nprcue': '\u22E0', 'npre': '\u2AAF\u0338', 'nprec': '\u2280', 'npreceq': '\u2AAF\u0338', 'nrarr': '\u219B', 'nrArr': '\u21CF', 'nrarrc': '\u2933\u0338', 'nrarrw': '\u219D\u0338', 'nrightarrow': '\u219B', 'nRightarrow': '\u21CF', 'nrtri': '\u22EB', 'nrtrie': '\u22ED', 'nsc': '\u2281', 'nsccue': '\u22E1', 'nsce': '\u2AB0\u0338', 'nscr': '\uD835\uDCC3', 'Nscr': '\uD835\uDCA9', 'nshortmid': '\u2224', 'nshortparallel': '\u2226', 'nsim': '\u2241', 'nsime': '\u2244', 'nsimeq': '\u2244', 'nsmid': '\u2224', 'nspar': '\u2226', 'nsqsube': '\u22E2', 'nsqsupe': '\u22E3', 'nsub': '\u2284', 'nsube': '\u2288', 'nsubE': '\u2AC5\u0338', 'nsubset': '\u2282\u20D2', 'nsubseteq': '\u2288', 'nsubseteqq': '\u2AC5\u0338', 'nsucc': '\u2281', 'nsucceq': '\u2AB0\u0338', 'nsup': '\u2285', 'nsupe': '\u2289', 'nsupE': '\u2AC6\u0338', 'nsupset': '\u2283\u20D2', 'nsupseteq': '\u2289', 'nsupseteqq': '\u2AC6\u0338', 'ntgl': '\u2279', 'ntilde': '\xF1', 'Ntilde': '\xD1', 'ntlg': '\u2278', 'ntriangleleft': '\u22EA', 'ntrianglelefteq': '\u22EC', 'ntriangleright': '\u22EB', 'ntrianglerighteq': '\u22ED', 'nu': '\u03BD', 'Nu': '\u039D', 'num': '#', 'numero': '\u2116', 'numsp': '\u2007', 'nvap': '\u224D\u20D2', 'nvdash': '\u22AC', 'nvDash': '\u22AD', 'nVdash': '\u22AE', 'nVDash': '\u22AF', 'nvge': '\u2265\u20D2', 'nvgt': '>\u20D2', 'nvHarr': '\u2904', 'nvinfin': '\u29DE', 'nvlArr': '\u2902', 'nvle': '\u2264\u20D2', 'nvlt': '<\u20D2', 'nvltrie': '\u22B4\u20D2', 'nvrArr': '\u2903', 'nvrtrie': '\u22B5\u20D2', 'nvsim': '\u223C\u20D2', 'nwarhk': '\u2923', 'nwarr': '\u2196', 'nwArr': '\u21D6', 'nwarrow': '\u2196', 'nwnear': '\u2927', 'oacute': '\xF3', 'Oacute': '\xD3', 'oast': '\u229B', 'ocir': '\u229A', 'ocirc': '\xF4', 'Ocirc': '\xD4', 'ocy': '\u043E', 'Ocy': '\u041E', 'odash': '\u229D', 'odblac': '\u0151', 'Odblac': '\u0150', 'odiv': '\u2A38', 'odot': '\u2299', 'odsold': '\u29BC', 'oelig': '\u0153', 'OElig': '\u0152', 'ofcir': '\u29BF', 'ofr': '\uD835\uDD2C', 'Ofr': '\uD835\uDD12', 'ogon': '\u02DB', 'ograve': '\xF2', 'Ograve': '\xD2', 'ogt': '\u29C1', 'ohbar': '\u29B5', 'ohm': '\u03A9', 'oint': '\u222E', 'olarr': '\u21BA', 'olcir': '\u29BE', 'olcross': '\u29BB', 'oline': '\u203E', 'olt': '\u29C0', 'omacr': '\u014D', 'Omacr': '\u014C', 'omega': '\u03C9', 'Omega': '\u03A9', 'omicron': '\u03BF', 'Omicron': '\u039F', 'omid': '\u29B6', 'ominus': '\u2296', 'oopf': '\uD835\uDD60', 'Oopf': '\uD835\uDD46', 'opar': '\u29B7', 'OpenCurlyDoubleQuote': '\u201C', 'OpenCurlyQuote': '\u2018', 'operp': '\u29B9', 'oplus': '\u2295', 'or': '\u2228', 'Or': '\u2A54', 'orarr': '\u21BB', 'ord': '\u2A5D', 'order': '\u2134', 'orderof': '\u2134', 'ordf': '\xAA', 'ordm': '\xBA', 'origof': '\u22B6', 'oror': '\u2A56', 'orslope': '\u2A57', 'orv': '\u2A5B', 'oS': '\u24C8', 'oscr': '\u2134', 'Oscr': '\uD835\uDCAA', 'oslash': '\xF8', 'Oslash': '\xD8', 'osol': '\u2298', 'otilde': '\xF5', 'Otilde': '\xD5', 'otimes': '\u2297', 'Otimes': '\u2A37', 'otimesas': '\u2A36', 'ouml': '\xF6', 'Ouml': '\xD6', 'ovbar': '\u233D', 'OverBar': '\u203E', 'OverBrace': '\u23DE', 'OverBracket': '\u23B4', 'OverParenthesis': '\u23DC', 'par': '\u2225', 'para': '\xB6', 'parallel': '\u2225', 'parsim': '\u2AF3', 'parsl': '\u2AFD', 'part': '\u2202', 'PartialD': '\u2202', 'pcy': '\u043F', 'Pcy': '\u041F', 'percnt': '%', 'period': '.', 'permil': '\u2030', 'perp': '\u22A5', 'pertenk': '\u2031', 'pfr': '\uD835\uDD2D', 'Pfr': '\uD835\uDD13', 'phi': '\u03C6', 'Phi': '\u03A6', 'phiv': '\u03D5', 'phmmat': '\u2133', 'phone': '\u260E', 'pi': '\u03C0', 'Pi': '\u03A0', 'pitchfork': '\u22D4', 'piv': '\u03D6', 'planck': '\u210F', 'planckh': '\u210E', 'plankv': '\u210F', 'plus': '+', 'plusacir': '\u2A23', 'plusb': '\u229E', 'pluscir': '\u2A22', 'plusdo': '\u2214', 'plusdu': '\u2A25', 'pluse': '\u2A72', 'PlusMinus': '\xB1', 'plusmn': '\xB1', 'plussim': '\u2A26', 'plustwo': '\u2A27', 'pm': '\xB1', 'Poincareplane': '\u210C', 'pointint': '\u2A15', 'popf': '\uD835\uDD61', 'Popf': '\u2119', 'pound': '\xA3', 'pr': '\u227A', 'Pr': '\u2ABB', 'prap': '\u2AB7', 'prcue': '\u227C', 'pre': '\u2AAF', 'prE': '\u2AB3', 'prec': '\u227A', 'precapprox': '\u2AB7', 'preccurlyeq': '\u227C', 'Precedes': '\u227A', 'PrecedesEqual': '\u2AAF', 'PrecedesSlantEqual': '\u227C', 'PrecedesTilde': '\u227E', 'preceq': '\u2AAF', 'precnapprox': '\u2AB9', 'precneqq': '\u2AB5', 'precnsim': '\u22E8', 'precsim': '\u227E', 'prime': '\u2032', 'Prime': '\u2033', 'primes': '\u2119', 'prnap': '\u2AB9', 'prnE': '\u2AB5', 'prnsim': '\u22E8', 'prod': '\u220F', 'Product': '\u220F', 'profalar': '\u232E', 'profline': '\u2312', 'profsurf': '\u2313', 'prop': '\u221D', 'Proportion': '\u2237', 'Proportional': '\u221D', 'propto': '\u221D', 'prsim': '\u227E', 'prurel': '\u22B0', 'pscr': '\uD835\uDCC5', 'Pscr': '\uD835\uDCAB', 'psi': '\u03C8', 'Psi': '\u03A8', 'puncsp': '\u2008', 'qfr': '\uD835\uDD2E', 'Qfr': '\uD835\uDD14', 'qint': '\u2A0C', 'qopf': '\uD835\uDD62', 'Qopf': '\u211A', 'qprime': '\u2057', 'qscr': '\uD835\uDCC6', 'Qscr': '\uD835\uDCAC', 'quaternions': '\u210D', 'quatint': '\u2A16', 'quest': '?', 'questeq': '\u225F', 'quot': '"', 'QUOT': '"', 'rAarr': '\u21DB', 'race': '\u223D\u0331', 'racute': '\u0155', 'Racute': '\u0154', 'radic': '\u221A', 'raemptyv': '\u29B3', 'rang': '\u27E9', 'Rang': '\u27EB', 'rangd': '\u2992', 'range': '\u29A5', 'rangle': '\u27E9', 'raquo': '\xBB', 'rarr': '\u2192', 'rArr': '\u21D2', 'Rarr': '\u21A0', 'rarrap': '\u2975', 'rarrb': '\u21E5', 'rarrbfs': '\u2920', 'rarrc': '\u2933', 'rarrfs': '\u291E', 'rarrhk': '\u21AA', 'rarrlp': '\u21AC', 'rarrpl': '\u2945', 'rarrsim': '\u2974', 'rarrtl': '\u21A3', 'Rarrtl': '\u2916', 'rarrw': '\u219D', 'ratail': '\u291A', 'rAtail': '\u291C', 'ratio': '\u2236', 'rationals': '\u211A', 'rbarr': '\u290D', 'rBarr': '\u290F', 'RBarr': '\u2910', 'rbbrk': '\u2773', 'rbrace': '}', 'rbrack': ']', 'rbrke': '\u298C', 'rbrksld': '\u298E', 'rbrkslu': '\u2990', 'rcaron': '\u0159', 'Rcaron': '\u0158', 'rcedil': '\u0157', 'Rcedil': '\u0156', 'rceil': '\u2309', 'rcub': '}', 'rcy': '\u0440', 'Rcy': '\u0420', 'rdca': '\u2937', 'rdldhar': '\u2969', 'rdquo': '\u201D', 'rdquor': '\u201D', 'rdsh': '\u21B3', 'Re': '\u211C', 'real': '\u211C', 'realine': '\u211B', 'realpart': '\u211C', 'reals': '\u211D', 'rect': '\u25AD', 'reg': '\xAE', 'REG': '\xAE', 'ReverseElement': '\u220B', 'ReverseEquilibrium': '\u21CB', 'ReverseUpEquilibrium': '\u296F', 'rfisht': '\u297D', 'rfloor': '\u230B', 'rfr': '\uD835\uDD2F', 'Rfr': '\u211C', 'rHar': '\u2964', 'rhard': '\u21C1', 'rharu': '\u21C0', 'rharul': '\u296C', 'rho': '\u03C1', 'Rho': '\u03A1', 'rhov': '\u03F1', 'RightAngleBracket': '\u27E9', 'rightarrow': '\u2192', 'Rightarrow': '\u21D2', 'RightArrow': '\u2192', 'RightArrowBar': '\u21E5', 'RightArrowLeftArrow': '\u21C4', 'rightarrowtail': '\u21A3', 'RightCeiling': '\u2309', 'RightDoubleBracket': '\u27E7', 'RightDownTeeVector': '\u295D', 'RightDownVector': '\u21C2', 'RightDownVectorBar': '\u2955', 'RightFloor': '\u230B', 'rightharpoondown': '\u21C1', 'rightharpoonup': '\u21C0', 'rightleftarrows': '\u21C4', 'rightleftharpoons': '\u21CC', 'rightrightarrows': '\u21C9', 'rightsquigarrow': '\u219D', 'RightTee': '\u22A2', 'RightTeeArrow': '\u21A6', 'RightTeeVector': '\u295B', 'rightthreetimes': '\u22CC', 'RightTriangle': '\u22B3', 'RightTriangleBar': '\u29D0', 'RightTriangleEqual': '\u22B5', 'RightUpDownVector': '\u294F', 'RightUpTeeVector': '\u295C', 'RightUpVector': '\u21BE', 'RightUpVectorBar': '\u2954', 'RightVector': '\u21C0', 'RightVectorBar': '\u2953', 'ring': '\u02DA', 'risingdotseq': '\u2253', 'rlarr': '\u21C4', 'rlhar': '\u21CC', 'rlm': '\u200F', 'rmoust': '\u23B1', 'rmoustache': '\u23B1', 'rnmid': '\u2AEE', 'roang': '\u27ED', 'roarr': '\u21FE', 'robrk': '\u27E7', 'ropar': '\u2986', 'ropf': '\uD835\uDD63', 'Ropf': '\u211D', 'roplus': '\u2A2E', 'rotimes': '\u2A35', 'RoundImplies': '\u2970', 'rpar': ')', 'rpargt': '\u2994', 'rppolint': '\u2A12', 'rrarr': '\u21C9', 'Rrightarrow': '\u21DB', 'rsaquo': '\u203A', 'rscr': '\uD835\uDCC7', 'Rscr': '\u211B', 'rsh': '\u21B1', 'Rsh': '\u21B1', 'rsqb': ']', 'rsquo': '\u2019', 'rsquor': '\u2019', 'rthree': '\u22CC', 'rtimes': '\u22CA', 'rtri': '\u25B9', 'rtrie': '\u22B5', 'rtrif': '\u25B8', 'rtriltri': '\u29CE', 'RuleDelayed': '\u29F4', 'ruluhar': '\u2968', 'rx': '\u211E', 'sacute': '\u015B', 'Sacute': '\u015A', 'sbquo': '\u201A', 'sc': '\u227B', 'Sc': '\u2ABC', 'scap': '\u2AB8', 'scaron': '\u0161', 'Scaron': '\u0160', 'sccue': '\u227D', 'sce': '\u2AB0', 'scE': '\u2AB4', 'scedil': '\u015F', 'Scedil': '\u015E', 'scirc': '\u015D', 'Scirc': '\u015C', 'scnap': '\u2ABA', 'scnE': '\u2AB6', 'scnsim': '\u22E9', 'scpolint': '\u2A13', 'scsim': '\u227F', 'scy': '\u0441', 'Scy': '\u0421', 'sdot': '\u22C5', 'sdotb': '\u22A1', 'sdote': '\u2A66', 'searhk': '\u2925', 'searr': '\u2198', 'seArr': '\u21D8', 'searrow': '\u2198', 'sect': '\xA7', 'semi': ';', 'seswar': '\u2929', 'setminus': '\u2216', 'setmn': '\u2216', 'sext': '\u2736', 'sfr': '\uD835\uDD30', 'Sfr': '\uD835\uDD16', 'sfrown': '\u2322', 'sharp': '\u266F', 'shchcy': '\u0449', 'SHCHcy': '\u0429', 'shcy': '\u0448', 'SHcy': '\u0428', 'ShortDownArrow': '\u2193', 'ShortLeftArrow': '\u2190', 'shortmid': '\u2223', 'shortparallel': '\u2225', 'ShortRightArrow': '\u2192', 'ShortUpArrow': '\u2191', 'shy': '\xAD', 'sigma': '\u03C3', 'Sigma': '\u03A3', 'sigmaf': '\u03C2', 'sigmav': '\u03C2', 'sim': '\u223C', 'simdot': '\u2A6A', 'sime': '\u2243', 'simeq': '\u2243', 'simg': '\u2A9E', 'simgE': '\u2AA0', 'siml': '\u2A9D', 'simlE': '\u2A9F', 'simne': '\u2246', 'simplus': '\u2A24', 'simrarr': '\u2972', 'slarr': '\u2190', 'SmallCircle': '\u2218', 'smallsetminus': '\u2216', 'smashp': '\u2A33', 'smeparsl': '\u29E4', 'smid': '\u2223', 'smile': '\u2323', 'smt': '\u2AAA', 'smte': '\u2AAC', 'smtes': '\u2AAC\uFE00', 'softcy': '\u044C', 'SOFTcy': '\u042C', 'sol': '/', 'solb': '\u29C4', 'solbar': '\u233F', 'sopf': '\uD835\uDD64', 'Sopf': '\uD835\uDD4A', 'spades': '\u2660', 'spadesuit': '\u2660', 'spar': '\u2225', 'sqcap': '\u2293', 'sqcaps': '\u2293\uFE00', 'sqcup': '\u2294', 'sqcups': '\u2294\uFE00', 'Sqrt': '\u221A', 'sqsub': '\u228F', 'sqsube': '\u2291', 'sqsubset': '\u228F', 'sqsubseteq': '\u2291', 'sqsup': '\u2290', 'sqsupe': '\u2292', 'sqsupset': '\u2290', 'sqsupseteq': '\u2292', 'squ': '\u25A1', 'square': '\u25A1', 'Square': '\u25A1', 'SquareIntersection': '\u2293', 'SquareSubset': '\u228F', 'SquareSubsetEqual': '\u2291', 'SquareSuperset': '\u2290', 'SquareSupersetEqual': '\u2292', 'SquareUnion': '\u2294', 'squarf': '\u25AA', 'squf': '\u25AA', 'srarr': '\u2192', 'sscr': '\uD835\uDCC8', 'Sscr': '\uD835\uDCAE', 'ssetmn': '\u2216', 'ssmile': '\u2323', 'sstarf': '\u22C6', 'star': '\u2606', 'Star': '\u22C6', 'starf': '\u2605', 'straightepsilon': '\u03F5', 'straightphi': '\u03D5', 'strns': '\xAF', 'sub': '\u2282', 'Sub': '\u22D0', 'subdot': '\u2ABD', 'sube': '\u2286', 'subE': '\u2AC5', 'subedot': '\u2AC3', 'submult': '\u2AC1', 'subne': '\u228A', 'subnE': '\u2ACB', 'subplus': '\u2ABF', 'subrarr': '\u2979', 'subset': '\u2282', 'Subset': '\u22D0', 'subseteq': '\u2286', 'subseteqq': '\u2AC5', 'SubsetEqual': '\u2286', 'subsetneq': '\u228A', 'subsetneqq': '\u2ACB', 'subsim': '\u2AC7', 'subsub': '\u2AD5', 'subsup': '\u2AD3', 'succ': '\u227B', 'succapprox': '\u2AB8', 'succcurlyeq': '\u227D', 'Succeeds': '\u227B', 'SucceedsEqual': '\u2AB0', 'SucceedsSlantEqual': '\u227D', 'SucceedsTilde': '\u227F', 'succeq': '\u2AB0', 'succnapprox': '\u2ABA', 'succneqq': '\u2AB6', 'succnsim': '\u22E9', 'succsim': '\u227F', 'SuchThat': '\u220B', 'sum': '\u2211', 'Sum': '\u2211', 'sung': '\u266A', 'sup': '\u2283', 'Sup': '\u22D1', 'sup1': '\xB9', 'sup2': '\xB2', 'sup3': '\xB3', 'supdot': '\u2ABE', 'supdsub': '\u2AD8', 'supe': '\u2287', 'supE': '\u2AC6', 'supedot': '\u2AC4', 'Superset': '\u2283', 'SupersetEqual': '\u2287', 'suphsol': '\u27C9', 'suphsub': '\u2AD7', 'suplarr': '\u297B', 'supmult': '\u2AC2', 'supne': '\u228B', 'supnE': '\u2ACC', 'supplus': '\u2AC0', 'supset': '\u2283', 'Supset': '\u22D1', 'supseteq': '\u2287', 'supseteqq': '\u2AC6', 'supsetneq': '\u228B', 'supsetneqq': '\u2ACC', 'supsim': '\u2AC8', 'supsub': '\u2AD4', 'supsup': '\u2AD6', 'swarhk': '\u2926', 'swarr': '\u2199', 'swArr': '\u21D9', 'swarrow': '\u2199', 'swnwar': '\u292A', 'szlig': '\xDF', 'Tab': '\t', 'target': '\u2316', 'tau': '\u03C4', 'Tau': '\u03A4', 'tbrk': '\u23B4', 'tcaron': '\u0165', 'Tcaron': '\u0164', 'tcedil': '\u0163', 'Tcedil': '\u0162', 'tcy': '\u0442', 'Tcy': '\u0422', 'tdot': '\u20DB', 'telrec': '\u2315', 'tfr': '\uD835\uDD31', 'Tfr': '\uD835\uDD17', 'there4': '\u2234', 'therefore': '\u2234', 'Therefore': '\u2234', 'theta': '\u03B8', 'Theta': '\u0398', 'thetasym': '\u03D1', 'thetav': '\u03D1', 'thickapprox': '\u2248', 'thicksim': '\u223C', 'ThickSpace': '\u205F\u200A', 'thinsp': '\u2009', 'ThinSpace': '\u2009', 'thkap': '\u2248', 'thksim': '\u223C', 'thorn': '\xFE', 'THORN': '\xDE', 'tilde': '\u02DC', 'Tilde': '\u223C', 'TildeEqual': '\u2243', 'TildeFullEqual': '\u2245', 'TildeTilde': '\u2248', 'times': '\xD7', 'timesb': '\u22A0', 'timesbar': '\u2A31', 'timesd': '\u2A30', 'tint': '\u222D', 'toea': '\u2928', 'top': '\u22A4', 'topbot': '\u2336', 'topcir': '\u2AF1', 'topf': '\uD835\uDD65', 'Topf': '\uD835\uDD4B', 'topfork': '\u2ADA', 'tosa': '\u2929', 'tprime': '\u2034', 'trade': '\u2122', 'TRADE': '\u2122', 'triangle': '\u25B5', 'triangledown': '\u25BF', 'triangleleft': '\u25C3', 'trianglelefteq': '\u22B4', 'triangleq': '\u225C', 'triangleright': '\u25B9', 'trianglerighteq': '\u22B5', 'tridot': '\u25EC', 'trie': '\u225C', 'triminus': '\u2A3A', 'TripleDot': '\u20DB', 'triplus': '\u2A39', 'trisb': '\u29CD', 'tritime': '\u2A3B', 'trpezium': '\u23E2', 'tscr': '\uD835\uDCC9', 'Tscr': '\uD835\uDCAF', 'tscy': '\u0446', 'TScy': '\u0426', 'tshcy': '\u045B', 'TSHcy': '\u040B', 'tstrok': '\u0167', 'Tstrok': '\u0166', 'twixt': '\u226C', 'twoheadleftarrow': '\u219E', 'twoheadrightarrow': '\u21A0', 'uacute': '\xFA', 'Uacute': '\xDA', 'uarr': '\u2191', 'uArr': '\u21D1', 'Uarr': '\u219F', 'Uarrocir': '\u2949', 'ubrcy': '\u045E', 'Ubrcy': '\u040E', 'ubreve': '\u016D', 'Ubreve': '\u016C', 'ucirc': '\xFB', 'Ucirc': '\xDB', 'ucy': '\u0443', 'Ucy': '\u0423', 'udarr': '\u21C5', 'udblac': '\u0171', 'Udblac': '\u0170', 'udhar': '\u296E', 'ufisht': '\u297E', 'ufr': '\uD835\uDD32', 'Ufr': '\uD835\uDD18', 'ugrave': '\xF9', 'Ugrave': '\xD9', 'uHar': '\u2963', 'uharl': '\u21BF', 'uharr': '\u21BE', 'uhblk': '\u2580', 'ulcorn': '\u231C', 'ulcorner': '\u231C', 'ulcrop': '\u230F', 'ultri': '\u25F8', 'umacr': '\u016B', 'Umacr': '\u016A', 'uml': '\xA8', 'UnderBar': '_', 'UnderBrace': '\u23DF', 'UnderBracket': '\u23B5', 'UnderParenthesis': '\u23DD', 'Union': '\u22C3', 'UnionPlus': '\u228E', 'uogon': '\u0173', 'Uogon': '\u0172', 'uopf': '\uD835\uDD66', 'Uopf': '\uD835\uDD4C', 'uparrow': '\u2191', 'Uparrow': '\u21D1', 'UpArrow': '\u2191', 'UpArrowBar': '\u2912', 'UpArrowDownArrow': '\u21C5', 'updownarrow': '\u2195', 'Updownarrow': '\u21D5', 'UpDownArrow': '\u2195', 'UpEquilibrium': '\u296E', 'upharpoonleft': '\u21BF', 'upharpoonright': '\u21BE', 'uplus': '\u228E', 'UpperLeftArrow': '\u2196', 'UpperRightArrow': '\u2197', 'upsi': '\u03C5', 'Upsi': '\u03D2', 'upsih': '\u03D2', 'upsilon': '\u03C5', 'Upsilon': '\u03A5', 'UpTee': '\u22A5', 'UpTeeArrow': '\u21A5', 'upuparrows': '\u21C8', 'urcorn': '\u231D', 'urcorner': '\u231D', 'urcrop': '\u230E', 'uring': '\u016F', 'Uring': '\u016E', 'urtri': '\u25F9', 'uscr': '\uD835\uDCCA', 'Uscr': '\uD835\uDCB0', 'utdot': '\u22F0', 'utilde': '\u0169', 'Utilde': '\u0168', 'utri': '\u25B5', 'utrif': '\u25B4', 'uuarr': '\u21C8', 'uuml': '\xFC', 'Uuml': '\xDC', 'uwangle': '\u29A7', 'vangrt': '\u299C', 'varepsilon': '\u03F5', 'varkappa': '\u03F0', 'varnothing': '\u2205', 'varphi': '\u03D5', 'varpi': '\u03D6', 'varpropto': '\u221D', 'varr': '\u2195', 'vArr': '\u21D5', 'varrho': '\u03F1', 'varsigma': '\u03C2', 'varsubsetneq': '\u228A\uFE00', 'varsubsetneqq': '\u2ACB\uFE00', 'varsupsetneq': '\u228B\uFE00', 'varsupsetneqq': '\u2ACC\uFE00', 'vartheta': '\u03D1', 'vartriangleleft': '\u22B2', 'vartriangleright': '\u22B3', 'vBar': '\u2AE8', 'Vbar': '\u2AEB', 'vBarv': '\u2AE9', 'vcy': '\u0432', 'Vcy': '\u0412', 'vdash': '\u22A2', 'vDash': '\u22A8', 'Vdash': '\u22A9', 'VDash': '\u22AB', 'Vdashl': '\u2AE6', 'vee': '\u2228', 'Vee': '\u22C1', 'veebar': '\u22BB', 'veeeq': '\u225A', 'vellip': '\u22EE', 'verbar': '|', 'Verbar': '\u2016', 'vert': '|', 'Vert': '\u2016', 'VerticalBar': '\u2223', 'VerticalLine': '|', 'VerticalSeparator': '\u2758', 'VerticalTilde': '\u2240', 'VeryThinSpace': '\u200A', 'vfr': '\uD835\uDD33', 'Vfr': '\uD835\uDD19', 'vltri': '\u22B2', 'vnsub': '\u2282\u20D2', 'vnsup': '\u2283\u20D2', 'vopf': '\uD835\uDD67', 'Vopf': '\uD835\uDD4D', 'vprop': '\u221D', 'vrtri': '\u22B3', 'vscr': '\uD835\uDCCB', 'Vscr': '\uD835\uDCB1', 'vsubne': '\u228A\uFE00', 'vsubnE': '\u2ACB\uFE00', 'vsupne': '\u228B\uFE00', 'vsupnE': '\u2ACC\uFE00', 'Vvdash': '\u22AA', 'vzigzag': '\u299A', 'wcirc': '\u0175', 'Wcirc': '\u0174', 'wedbar': '\u2A5F', 'wedge': '\u2227', 'Wedge': '\u22C0', 'wedgeq': '\u2259', 'weierp': '\u2118', 'wfr': '\uD835\uDD34', 'Wfr': '\uD835\uDD1A', 'wopf': '\uD835\uDD68', 'Wopf': '\uD835\uDD4E', 'wp': '\u2118', 'wr': '\u2240', 'wreath': '\u2240', 'wscr': '\uD835\uDCCC', 'Wscr': '\uD835\uDCB2', 'xcap': '\u22C2', 'xcirc': '\u25EF', 'xcup': '\u22C3', 'xdtri': '\u25BD', 'xfr': '\uD835\uDD35', 'Xfr': '\uD835\uDD1B', 'xharr': '\u27F7', 'xhArr': '\u27FA', 'xi': '\u03BE', 'Xi': '\u039E', 'xlarr': '\u27F5', 'xlArr': '\u27F8', 'xmap': '\u27FC', 'xnis': '\u22FB', 'xodot': '\u2A00', 'xopf': '\uD835\uDD69', 'Xopf': '\uD835\uDD4F', 'xoplus': '\u2A01', 'xotime': '\u2A02', 'xrarr': '\u27F6', 'xrArr': '\u27F9', 'xscr': '\uD835\uDCCD', 'Xscr': '\uD835\uDCB3', 'xsqcup': '\u2A06', 'xuplus': '\u2A04', 'xutri': '\u25B3', 'xvee': '\u22C1', 'xwedge': '\u22C0', 'yacute': '\xFD', 'Yacute': '\xDD', 'yacy': '\u044F', 'YAcy': '\u042F', 'ycirc': '\u0177', 'Ycirc': '\u0176', 'ycy': '\u044B', 'Ycy': '\u042B', 'yen': '\xA5', 'yfr': '\uD835\uDD36', 'Yfr': '\uD835\uDD1C', 'yicy': '\u0457', 'YIcy': '\u0407', 'yopf': '\uD835\uDD6A', 'Yopf': '\uD835\uDD50', 'yscr': '\uD835\uDCCE', 'Yscr': '\uD835\uDCB4', 'yucy': '\u044E', 'YUcy': '\u042E', 'yuml': '\xFF', 'Yuml': '\u0178', 'zacute': '\u017A', 'Zacute': '\u0179', 'zcaron': '\u017E', 'Zcaron': '\u017D', 'zcy': '\u0437', 'Zcy': '\u0417', 'zdot': '\u017C', 'Zdot': '\u017B', 'zeetrf': '\u2128', 'ZeroWidthSpace': '\u200B', 'zeta': '\u03B6', 'Zeta': '\u0396', 'zfr': '\uD835\uDD37', 'Zfr': '\u2128', 'zhcy': '\u0436', 'ZHcy': '\u0416', 'zigrarr': '\u21DD', 'zopf': '\uD835\uDD6B', 'Zopf': '\u2124', 'zscr': '\uD835\uDCCF', 'Zscr': '\uD835\uDCB5', 'zwj': '\u200D', 'zwnj': '\u200C' }
      var decodeMapLegacy = { 'aacute': '\xE1', 'Aacute': '\xC1', 'acirc': '\xE2', 'Acirc': '\xC2', 'acute': '\xB4', 'aelig': '\xE6', 'AElig': '\xC6', 'agrave': '\xE0', 'Agrave': '\xC0', 'amp': '&', 'AMP': '&', 'aring': '\xE5', 'Aring': '\xC5', 'atilde': '\xE3', 'Atilde': '\xC3', 'auml': '\xE4', 'Auml': '\xC4', 'brvbar': '\xA6', 'ccedil': '\xE7', 'Ccedil': '\xC7', 'cedil': '\xB8', 'cent': '\xA2', 'copy': '\xA9', 'COPY': '\xA9', 'curren': '\xA4', 'deg': '\xB0', 'divide': '\xF7', 'eacute': '\xE9', 'Eacute': '\xC9', 'ecirc': '\xEA', 'Ecirc': '\xCA', 'egrave': '\xE8', 'Egrave': '\xC8', 'eth': '\xF0', 'ETH': '\xD0', 'euml': '\xEB', 'Euml': '\xCB', 'frac12': '\xBD', 'frac14': '\xBC', 'frac34': '\xBE', 'gt': '>', 'GT': '>', 'iacute': '\xED', 'Iacute': '\xCD', 'icirc': '\xEE', 'Icirc': '\xCE', 'iexcl': '\xA1', 'igrave': '\xEC', 'Igrave': '\xCC', 'iquest': '\xBF', 'iuml': '\xEF', 'Iuml': '\xCF', 'laquo': '\xAB', 'lt': '<', 'LT': '<', 'macr': '\xAF', 'micro': '\xB5', 'middot': '\xB7', 'nbsp': '\xA0', 'not': '\xAC', 'ntilde': '\xF1', 'Ntilde': '\xD1', 'oacute': '\xF3', 'Oacute': '\xD3', 'ocirc': '\xF4', 'Ocirc': '\xD4', 'ograve': '\xF2', 'Ograve': '\xD2', 'ordf': '\xAA', 'ordm': '\xBA', 'oslash': '\xF8', 'Oslash': '\xD8', 'otilde': '\xF5', 'Otilde': '\xD5', 'ouml': '\xF6', 'Ouml': '\xD6', 'para': '\xB6', 'plusmn': '\xB1', 'pound': '\xA3', 'quot': '"', 'QUOT': '"', 'raquo': '\xBB', 'reg': '\xAE', 'REG': '\xAE', 'sect': '\xA7', 'shy': '\xAD', 'sup1': '\xB9', 'sup2': '\xB2', 'sup3': '\xB3', 'szlig': '\xDF', 'thorn': '\xFE', 'THORN': '\xDE', 'times': '\xD7', 'uacute': '\xFA', 'Uacute': '\xDA', 'ucirc': '\xFB', 'Ucirc': '\xDB', 'ugrave': '\xF9', 'Ugrave': '\xD9', 'uml': '\xA8', 'uuml': '\xFC', 'Uuml': '\xDC', 'yacute': '\xFD', 'Yacute': '\xDD', 'yen': '\xA5', 'yuml': '\xFF' }
      var decodeMapNumeric = { '0': '\uFFFD', '128': '\u20AC', '130': '\u201A', '131': '\u0192', '132': '\u201E', '133': '\u2026', '134': '\u2020', '135': '\u2021', '136': '\u02C6', '137': '\u2030', '138': '\u0160', '139': '\u2039', '140': '\u0152', '142': '\u017D', '145': '\u2018', '146': '\u2019', '147': '\u201C', '148': '\u201D', '149': '\u2022', '150': '\u2013', '151': '\u2014', '152': '\u02DC', '153': '\u2122', '154': '\u0161', '155': '\u203A', '156': '\u0153', '158': '\u017E', '159': '\u0178' }
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]

	/* --------------------------------------------------------------------------*/

      var stringFromCharCode = String.fromCharCode

      var object = {}
      var hasOwnProperty = object.hasOwnProperty
      var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName)
      }

      var contains = function (array, value) {
        var index = -1
        var length = array.length
        while (++index < length) {
          if (array[index] == value) {
            return true
          }
        }
        return false
      }

      var merge = function (options, defaults) {
        if (!options) {
          return defaults
        }
        var result = {}
        var key
        for (key in defaults) {
			// A `hasOwnProperty` check is not needed here, since only recognized
			// option names are used anyway. Any others are ignored.
          result[key] = has(options, key) ? options[key] : defaults[key]
        }
        return result
      }

	// Modified version of `ucs2encode`; see https://mths.be/punycode.
      var codePointToSymbol = function (codePoint, strict) {
        var output = ''
        if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
			// See issue #4:
			// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
			// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
			// REPLACEMENT CHARACTER.
          if (strict) {
            parseError('character reference outside the permissible Unicode range')
          }
          return '\uFFFD'
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError('disallowed character reference')
          }
          return decodeMapNumeric[codePoint]
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError('disallowed character reference')
        }
        if (codePoint > 0xFFFF) {
          codePoint -= 0x10000
          output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
        output += stringFromCharCode(codePoint)
        return output
      }

      var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';'
      }

      var decEscape = function (codePoint) {
        return '&#' + codePoint + ';'
      }

      var parseError = function (message) {
        throw Error('Parse error: ' + message)
      }

	/* --------------------------------------------------------------------------*/

      var encode = function (string, options) {
        options = merge(options, encode.options)
        var strict = options.strict
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError('forbidden code point')
        }
        var encodeEverything = options.encodeEverything
        var useNamedReferences = options.useNamedReferences
        var allowUnsafeSymbols = options.allowUnsafeSymbols
        var escapeCodePoint = options.decimal ? decEscape : hexEscape

        var escapeBmpSymbol = function (symbol) {
          return escapeCodePoint(symbol.charCodeAt(0))
        }

        if (encodeEverything) {
			// Encode ASCII symbols.
          string = string.replace(regexAsciiWhitelist, function (symbol) {
				// Use named references if requested & possible.
            if (useNamedReferences && has(encodeMap, symbol)) {
              return '&' + encodeMap[symbol] + ';'
            }
            return escapeBmpSymbol(symbol)
          })
			// Shorten a few escapes that represent two symbols, of which at least one
			// is within the ASCII range.
          if (useNamedReferences) {
            string = string
					.replace(/&gt;\u20D2/g, '&nvgt;')
					.replace(/&lt;\u20D2/g, '&nvlt;')
					.replace(/&#x66;&#x6A;/g, '&fjlig;')
          }
			// Encode non-ASCII symbols.
          if (useNamedReferences) {
				// Encode non-ASCII symbols that can be replaced with a named reference.
            string = string.replace(regexEncodeNonAscii, function (string) {
					// Note: there is no need to check `has(encodeMap, string)` here.
              return '&' + encodeMap[string] + ';'
            })
          }
			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
        } else if (useNamedReferences) {
			// Apply named character references.
			// Encode `<>"'&` using named character references.
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function (string) {
              return '&' + encodeMap[string] + ';' // no need to check `has()` here
            })
          }
			// Shorten escapes that represent two symbols, of which at least one is
			// `<>"'&`.
          string = string
				.replace(/&gt;\u20D2/g, '&nvgt;')
				.replace(/&lt;\u20D2/g, '&nvlt;')
			// Encode non-ASCII symbols that can be replaced with a named reference.
          string = string.replace(regexEncodeNonAscii, function (string) {
				// Note: there is no need to check `has(encodeMap, string)` here.
            return '&' + encodeMap[string] + ';'
          })
        } else if (!allowUnsafeSymbols) {
			// Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
			// using named character references.
          string = string.replace(regexEscape, escapeBmpSymbol)
        }
        return string
			// Encode astral symbols.
			.replace(regexAstralSymbols, function ($0) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  var high = $0.charCodeAt(0)
  var low = $0.charCodeAt(1)
  var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000
  return escapeCodePoint(codePoint)
})
			// Encode any remaining BMP symbols that are not printable ASCII symbols
			// using a hexadecimal escape.
			.replace(regexBmpWhitelist, escapeBmpSymbol)
      }
	// Expose default options (so they can be overridden globally).
      encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
      }

      var decode = function (html, options) {
        options = merge(options, decode.options)
        var strict = options.strict
        if (strict && regexInvalidEntity.test(html)) {
          parseError('malformed character reference')
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
          var codePoint
          var semicolon
          var decDigits
          var hexDigits
          var reference
          var next
          if ($1) {
				// Decode decimal escapes, e.g. `&#119558;`.
            decDigits = $1
            semicolon = $2
            if (strict && !semicolon) {
              parseError('character reference was not terminated by a semicolon')
            }
            codePoint = parseInt(decDigits, 10)
            return codePointToSymbol(codePoint, strict)
          }
          if ($3) {
				// Decode hexadecimal escapes, e.g. `&#x1D306;`.
            hexDigits = $3
            semicolon = $4
            if (strict && !semicolon) {
              parseError('character reference was not terminated by a semicolon')
            }
            codePoint = parseInt(hexDigits, 16)
            return codePointToSymbol(codePoint, strict)
          }
          if ($5) {
				// Decode named character references with trailing `;`, e.g. `&copy;`.
            reference = $5
            if (has(decodeMap, reference)) {
              return decodeMap[reference]
            } else {
					// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands
              if (strict) {
                parseError(
							'named character reference was not terminated by a semicolon'
						)
              }
              return $0
            }
          }
			// If were still here, its a legacy reference for sure. No need for an
			// extra `if` check.
			// Decode named character references without trailing `;`, e.g. `&amp`
			// This is only a parse error if it gets converted to `&`, or if it is
			// followed by `=` in an attribute context.
          reference = $6
          next = $7
          if (next && options.isAttributeValue) {
            if (strict && next == '=') {
              parseError('`&` did not start a character reference')
            }
            return $0
          } else {
            if (strict) {
              parseError(
						'named character reference was not terminated by a semicolon'
					)
            }
				// Note: there is no need to check `has(decodeMapLegacy, reference)`.
            return decodeMapLegacy[reference] + (next || '')
          }
        })
      }
	// Expose default options (so they can be overridden globally).
      decode.options = {
        'isAttributeValue': false,
        'strict': false
      }

      var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
			// Note: there is no need to check `has(escapeMap, $0)` here.
          return escapeMap[$0]
        })
      }

	/* --------------------------------------------------------------------------*/

      var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
      }

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
      if (
		false
	) {
        define(function () {
          return he
        })
      }	else if (freeExports && !freeExports.nodeType) {
        if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
          freeModule.exports = he
        } else { // in Narwhal or RingoJS v0.7.0-
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key])
          }
        }
      } else { // in Rhino or a web browser
        root.he = he
      }
    }(this))
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, {}], 65: [function (require, module, exports) {
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m
    var eLen = nBytes * 8 - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var nBits = -7
    var i = isLE ? (nBytes - 1) : 0
    var d = isLE ? -1 : 1
    var s = buffer[offset + i]

    i += d

    e = s & ((1 << (-nBits)) - 1)
    s >>= (-nBits)
    nBits += eLen
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1)
    e >>= (-nBits)
    nBits += mLen
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen)
      e = e - eBias
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c
    var eLen = nBytes * 8 - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
    var i = isLE ? 0 : (nBytes - 1)
    var d = isLE ? 1 : -1
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

    value = Math.abs(value)

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0
      e = eMax
    } else {
      e = Math.floor(Math.log(value) / Math.LN2)
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--
        c *= 2
      }
      if (e + eBias >= 1) {
        value += rt / c
      } else {
        value += rt * Math.pow(2, 1 - eBias)
      }
      if (value * c >= 2) {
        e++
        c /= 2
      }

      if (e + eBias >= eMax) {
        m = 0
        e = eMax
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen)
        e = e + eBias
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
        e = 0
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m
    eLen += mLen
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128
  }
}, {}], 66: [function (require, module, exports) {
  if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
    module.exports = function inherits (ctor, superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  } else {
  // old school shim for old browsers
    module.exports = function inherits (ctor, superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}, {}], 67: [function (require, module, exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
  module.exports = function (obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
  }

  function isBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

// For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
  }
}, {}], 68: [function (require, module, exports) {
  var toString = {}.toString

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]'
  }
}, {}], 69: [function (require, module, exports) {
  (function (global) {
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
    ;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
      var isLoader = false

  // A set of types used to distinguish objects from primitives.
      var objectTypes = {
        'function': true,
        'object': true
      }

  // Detect the `exports` object exposed by CommonJS implementations.
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
      var root = objectTypes[typeof window] && window || this,
        freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global === 'object' && global

      if (freeGlobal && (freeGlobal['global'] === freeGlobal || freeGlobal['window'] === freeGlobal || freeGlobal['self'] === freeGlobal)) {
        root = freeGlobal
      }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
      function runInContext (context, exports) {
        context || (context = root['Object']())
        exports || (exports = root['Object']())

    // Native constructor aliases.
        var Number = context['Number'] || root['Number'],
          String = context['String'] || root['String'],
          Object = context['Object'] || root['Object'],
          Date = context['Date'] || root['Date'],
          SyntaxError = context['SyntaxError'] || root['SyntaxError'],
          TypeError = context['TypeError'] || root['TypeError'],
          Math = context['Math'] || root['Math'],
          nativeJSON = context['JSON'] || root['JSON']

    // Delegate to the native `stringify` and `parse` implementations.
        if (typeof nativeJSON === 'object' && nativeJSON) {
          exports.stringify = nativeJSON.stringify
          exports.parse = nativeJSON.parse
        }

    // Convenience aliases.
        var objectProto = Object.prototype,
          getClass = objectProto.toString,
          isProperty, forEach, undef

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
        var isExtended = new Date(-3509827334573292)
        try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
          isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708
        } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
        function has (name) {
          if (has[name] !== undef) {
        // Return cached feature test result.
            return has[name]
          }
          var isSupported
          if (name == 'bug-string-char-index') {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
            isSupported = 'a'[0] != 'a'
          } else if (name == 'json') {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
            isSupported = has('json-stringify') && has('json-parse')
          } else {
            var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}'
        // Test `JSON.stringify`.
            if (name == 'json-stringify') {
              var stringify = exports.stringify, stringifySupported = typeof stringify === 'function' && isExtended
              if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
                (value = function () {
                  return 1
                }).toJSON = value
                try {
                  stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === '0' &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === '0' &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === '1' &&
                stringify([value]) == '[1]' &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == '[null]' &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == 'null' &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == '[null,null,null]' &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ 'a': [value, true, false, null, '\x00\b\n\f\r\t'] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === '1' &&
                stringify([1, 2], null, 1) == '[\n 1,\n 2\n]' &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"'
                } catch (exception) {
                  stringifySupported = false
                }
              }
              isSupported = stringifySupported
            }
        // Test `JSON.parse`.
            if (name == 'json-parse') {
              var parse = exports.parse
              if (typeof parse === 'function') {
                try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
                  if (parse('0') === 0 && !parse(false)) {
                // Simple parsing test.
                    value = parse(serialized)
                    var parseSupported = value['a'].length == 5 && value['a'][0] === 1
                    if (parseSupported) {
                      try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                        parseSupported = !parse('"\t"')
                      } catch (exception) {}
                      if (parseSupported) {
                        try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                          parseSupported = parse('01') !== 1
                        } catch (exception) {}
                      }
                      if (parseSupported) {
                        try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                          parseSupported = parse('1.') !== 1
                        } catch (exception) {}
                      }
                    }
                  }
                } catch (exception) {
                  parseSupported = false
                }
              }
              isSupported = parseSupported
            }
          }
          return has[name] = !!isSupported
        }

        if (!has('json')) {
      // Common `[[Class]]` name aliases.
          var functionClass = '[object Function]',
            dateClass = '[object Date]',
            numberClass = '[object Number]',
            stringClass = '[object String]',
            arrayClass = '[object Array]',
            booleanClass = '[object Boolean]'

      // Detect incomplete support for accessing string characters by index.
          var charIndexBuggy = has('bug-string-char-index')

      // Define additional utility methods if the `Date` methods are buggy.
          if (!isExtended) {
            var floor = Math.floor
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
            var getDay = function (year, month) {
              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400)
            }
          }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
          if (!(isProperty = objectProto.hasOwnProperty)) {
            isProperty = function (property) {
              var members = {}, constructor
              if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
                'toString': 1
              }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
                isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
                  var original = this.__proto__, result = property in (this.__proto__ = null, this)
              // Restore the original prototype chain.
                  this.__proto__ = original
                  return result
                }
              } else {
            // Capture a reference to the top-level `Object` constructor.
                constructor = members.constructor
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
                isProperty = function (property) {
                  var parent = (this.constructor || constructor).prototype
                  return property in this && !(property in parent && this[property] === parent[property])
                }
              }
              members = null
              return isProperty.call(this, property)
            }
          }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
          forEach = function (object, callback) {
            var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
            (Properties = function () {
              this.valueOf = 0
            }).prototype.valueOf = 0

        // Iterate over a new instance of the `Properties` class.
            members = new Properties()
            for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
              if (isProperty.call(members, property)) {
                size++
              }
            }
            Properties = members = null

        // Normalize the iteration algorithm.
            if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
              members = ['valueOf', 'toString', 'toLocaleString', 'propertyIsEnumerable', 'isPrototypeOf', 'hasOwnProperty', 'constructor']
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, length
                var hasProperty = !isFunction && typeof object.constructor !== 'function' && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty
                for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
                  if (!(isFunction && property == 'prototype') && hasProperty.call(object, property)) {
                    callback(property)
                  }
                }
            // Manually invoke the callback for each non-enumerable property.
                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
              }
            } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
              forEach = function (object, callback) {
            // Create a set of iterated properties.
                var members = {}, isFunction = getClass.call(object) == functionClass, property
                for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
                  if (!(isFunction && property == 'prototype') && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                    callback(property)
                  }
                }
              }
            } else {
          // No bugs detected; use the standard `for...in` algorithm.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, isConstructor
                for (property in object) {
                  if (!(isFunction && property == 'prototype') && isProperty.call(object, property) && !(isConstructor = property === 'constructor')) {
                    callback(property)
                  }
                }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
                if (isConstructor || isProperty.call(object, (property = 'constructor'))) {
                  callback(property)
                }
              }
            }
            return forEach(object, callback)
          }

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
          if (!has('json-stringify')) {
        // Internal: A map of control characters and their escaped equivalents.
            var Escapes = {
              92: '\\\\',
              34: '\\"',
              8: '\\b',
              12: '\\f',
              10: '\\n',
              13: '\\r',
              9: '\\t'
            }

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
            var leadingZeroes = '000000'
            var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
              return (leadingZeroes + (value || 0)).slice(-width)
            }

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
            var unicodePrefix = '\\u00'
            var quote = function (value) {
              var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10
              var symbols = useCharIndex && (charIndexBuggy ? value.split('') : value)
              for (; index < length; index++) {
                var charCode = value.charCodeAt(index)
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
                switch (charCode) {
                  case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                    result += Escapes[charCode]
                    break
                  default:
                    if (charCode < 32) {
                      result += unicodePrefix + toPaddedString(2, charCode.toString(16))
                      break
                    }
                    result += useCharIndex ? symbols[index] : value.charAt(index)
                }
              }
              return result + '"'
            }

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
            var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
              var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result
              try {
            // Necessary for host object support.
                value = object[property]
              } catch (exception) {}
              if (typeof value === 'object' && value) {
                className = getClass.call(value)
                if (className == dateClass && !isProperty.call(value, 'toJSON')) {
                  if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                    if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                      date = floor(value / 864e5)
                      for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                      date = 1 + date - getDay(year, month)
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                      time = (value % 864e5 + 864e5) % 864e5
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                      hours = floor(time / 36e5) % 24
                      minutes = floor(time / 6e4) % 60
                      seconds = floor(time / 1e3) % 60
                      milliseconds = time % 1e3
                    } else {
                      year = value.getUTCFullYear()
                      month = value.getUTCMonth()
                      date = value.getUTCDate()
                      hours = value.getUTCHours()
                      minutes = value.getUTCMinutes()
                      seconds = value.getUTCSeconds()
                      milliseconds = value.getUTCMilliseconds()
                    }
                // Serialize extended years correctly.
                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? '-' : '+') + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  '-' + toPaddedString(2, month + 1) + '-' + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  'T' + toPaddedString(2, hours) + ':' + toPaddedString(2, minutes) + ':' + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  '.' + toPaddedString(3, milliseconds) + 'Z'
                  } else {
                    value = null
                  }
                } else if (typeof value.toJSON === 'function' && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, 'toJSON'))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
                  value = value.toJSON(property)
                }
              }
              if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
                value = callback.call(object, property, value)
              }
              if (value === null) {
                return 'null'
              }
              className = getClass.call(value)
              if (className == booleanClass) {
            // Booleans are represented literally.
                return '' + value
              } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
                return value > -1 / 0 && value < 1 / 0 ? '' + value : 'null'
              } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
                return quote('' + value)
              }
          // Recursively serialize objects and arrays.
              if (typeof value === 'object') {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
                for (length = stack.length; length--;) {
                  if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                    throw TypeError()
                  }
                }
            // Add the object to the stack of traversed objects.
                stack.push(value)
                results = []
            // Save the current indentation level and indent one additional level.
                prefix = indentation
                indentation += whitespace
                if (className == arrayClass) {
              // Recursively serialize array elements.
                  for (index = 0, length = value.length; index < length; index++) {
                    element = serialize(index, value, callback, properties, whitespace, indentation, stack)
                    results.push(element === undef ? 'null' : element)
                  }
                  result = results.length ? (whitespace ? '[\n' + indentation + results.join(',\n' + indentation) + '\n' + prefix + ']' : ('[' + results.join(',') + ']')) : '[]'
                } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
                  forEach(properties || value, function (property) {
                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack)
                    if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                      results.push(quote(property) + ':' + (whitespace ? ' ' : '') + element)
                    }
                  })
                  result = results.length ? (whitespace ? '{\n' + indentation + results.join(',\n' + indentation) + '\n' + prefix + '}' : ('{' + results.join(',') + '}')) : '{}'
                }
            // Remove the object from the traversed object stack.
                stack.pop()
                return result
              }
            }

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
            exports.stringify = function (source, filter, width) {
              var whitespace, callback, properties, className
              if (objectTypes[typeof filter] && filter) {
                if ((className = getClass.call(filter)) == functionClass) {
                  callback = filter
                } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
                  properties = {}
                  for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
                }
              }
              if (width) {
                if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
                  if ((width -= width % 1) > 0) {
                    for (whitespace = '', width > 10 && (width = 10); whitespace.length < width; whitespace += ' ');
                  }
                } else if (className == stringClass) {
                  whitespace = width.length <= 10 ? width : width.slice(0, 10)
                }
              }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
              return serialize('', (value = {}, value[''] = source, value), callback, properties, whitespace, '', [])
            }
          }

      // Public: Parses a JSON source string.
          if (!has('json-parse')) {
            var fromCharCode = String.fromCharCode

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
            var Unescapes = {
              92: '\\',
              34: '"',
              47: '/',
              98: '\b',
              116: '\t',
              110: '\n',
              102: '\f',
              114: '\r'
            }

        // Internal: Stores the parser state.
            var Index, Source

        // Internal: Resets the parser state and throws a `SyntaxError`.
            var abort = function () {
              Index = Source = null
              throw SyntaxError()
            }

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
            var lex = function () {
              var source = Source, length = source.length, value, begin, position, isSigned, charCode
              while (Index < length) {
                charCode = source.charCodeAt(Index)
                switch (charCode) {
                  case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                    Index++
                    break
                  case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                    value = charIndexBuggy ? source.charAt(Index) : source[Index]
                    Index++
                    return value
                  case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                    for (value = '@', Index++; Index < length;) {
                      charCode = source.charCodeAt(Index)
                      if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                        abort()
                      } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                        charCode = source.charCodeAt(++Index)
                        switch (charCode) {
                          case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                            value += Unescapes[charCode]
                            Index++
                            break
                          case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                            begin = ++Index
                            for (position = Index + 4; Index < position; Index++) {
                              charCode = source.charCodeAt(Index)
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                              if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                                abort()
                              }
                            }
                        // Revive the escaped character.
                            value += fromCharCode('0x' + source.slice(begin, Index))
                            break
                          default:
                        // Invalid escape sequence.
                            abort()
                        }
                      } else {
                        if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                          break
                        }
                        charCode = source.charCodeAt(Index)
                        begin = Index
                    // Optimize for the common case where a string is valid.
                        while (charCode >= 32 && charCode != 92 && charCode != 34) {
                          charCode = source.charCodeAt(++Index)
                        }
                    // Append the string as-is.
                        value += source.slice(begin, Index)
                      }
                    }
                    if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                      Index++
                      return value
                    }
                // Unterminated string.
                    abort()
                  default:
                // Parse numbers and literals.
                    begin = Index
                // Advance past the negative sign, if one is specified.
                    if (charCode == 45) {
                      isSigned = true
                      charCode = source.charCodeAt(++Index)
                    }
                // Parse an integer or floating-point value.
                    if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                      if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                        abort()
                      }
                      isSigned = false
                  // Parse the integer component.
                      for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                      if (source.charCodeAt(Index) == 46) {
                        position = ++Index
                    // Parse the decimal component.
                        for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                        if (position == Index) {
                      // Illegal trailing decimal.
                          abort()
                        }
                        Index = position
                      }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                      charCode = source.charCodeAt(Index)
                      if (charCode == 101 || charCode == 69) {
                        charCode = source.charCodeAt(++Index)
                    // Skip past the sign following the exponent, if one is
                    // specified.
                        if (charCode == 43 || charCode == 45) {
                          Index++
                        }
                    // Parse the exponential component.
                        for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                        if (position == Index) {
                      // Illegal empty exponent.
                          abort()
                        }
                        Index = position
                      }
                  // Coerce the parsed value to a JavaScript number.
                      return +source.slice(begin, Index)
                    }
                // A negative sign may only precede numbers.
                    if (isSigned) {
                      abort()
                    }
                // `true`, `false`, and `null` literals.
                    if (source.slice(Index, Index + 4) == 'true') {
                      Index += 4
                      return true
                    } else if (source.slice(Index, Index + 5) == 'false') {
                      Index += 5
                      return false
                    } else if (source.slice(Index, Index + 4) == 'null') {
                      Index += 4
                      return null
                    }
                // Unrecognized token.
                    abort()
                }
              }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
              return '$'
            }

        // Internal: Parses a JSON `value` token.
            var get = function (value) {
              var results, hasMembers
              if (value == '$') {
            // Unexpected end of input.
                abort()
              }
              if (typeof value === 'string') {
                if ((charIndexBuggy ? value.charAt(0) : value[0]) == '@') {
              // Remove the sentinel `@` character.
                  return value.slice(1)
                }
            // Parse object and array literals.
                if (value == '[') {
              // Parses a JSON array, returning a new JavaScript array.
                  results = []
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex()
                // A closing square bracket marks the end of the array literal.
                    if (value == ']') {
                      break
                    }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                    if (hasMembers) {
                      if (value == ',') {
                        value = lex()
                        if (value == ']') {
                      // Unexpected trailing `,` in array literal.
                          abort()
                        }
                      } else {
                    // A `,` must separate each array element.
                        abort()
                      }
                    }
                // Elisions and leading commas are not permitted.
                    if (value == ',') {
                      abort()
                    }
                    results.push(get(value))
                  }
                  return results
                } else if (value == '{') {
              // Parses a JSON object, returning a new JavaScript object.
                  results = {}
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex()
                // A closing curly brace marks the end of the object literal.
                    if (value == '}') {
                      break
                    }
                // If the object literal contains members, the current token
                // should be a comma separator.
                    if (hasMembers) {
                      if (value == ',') {
                        value = lex()
                        if (value == '}') {
                      // Unexpected trailing `,` in object literal.
                          abort()
                        }
                      } else {
                    // A `,` must separate each object member.
                        abort()
                      }
                    }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                    if (value == ',' || typeof value !== 'string' || (charIndexBuggy ? value.charAt(0) : value[0]) != '@' || lex() != ':') {
                      abort()
                    }
                    results[value.slice(1)] = get(lex())
                  }
                  return results
                }
            // Unexpected token encountered.
                abort()
              }
              return value
            }

        // Internal: Updates a traversed object member.
            var update = function (source, property, callback) {
              var element = walk(source, property, callback)
              if (element === undef) {
                delete source[property]
              } else {
                source[property] = element
              }
            }

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
            var walk = function (source, property, callback) {
              var value = source[property], length
              if (typeof value === 'object' && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                if (getClass.call(value) == arrayClass) {
                  for (length = value.length; length--;) {
                    update(value, length, callback)
                  }
                } else {
                  forEach(value, function (property) {
                    update(value, property, callback)
                  })
                }
              }
              return callback.call(source, property, value)
            }

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
            exports.parse = function (source, callback) {
              var result, value
              Index = 0
              Source = '' + source
              result = get(lex())
          // If a JSON string contains multiple tokens, it is invalid.
              if (lex() != '$') {
                abort()
              }
          // Reset the parser state.
              Index = Source = null
              return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[''] = result, value), '', callback) : result
            }
          }
        }

        exports['runInContext'] = runInContext
        return exports
      }

      if (freeExports && !isLoader) {
    // Export for CommonJS environments.
        runInContext(root, freeExports)
      } else {
    // Export for web browsers and JavaScript engines.
        var nativeJSON = root.JSON,
          previousJSON = root['JSON3'],
          isRestored = false

        var JSON3 = runInContext(root, (root['JSON3'] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
          'noConflict': function () {
            if (!isRestored) {
              isRestored = true
              root.JSON = nativeJSON
              root['JSON3'] = previousJSON
              nativeJSON = previousJSON = null
            }
            return JSON3
          }
        }))

        root.JSON = {
          'parse': JSON3.parse,
          'stringify': JSON3.stringify
        }
      }

  // Export for asynchronous module loaders.
      if (isLoader) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return JSON3
        }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
      }
    }).call(this)
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, {}], 70: [function (require, module, exports) {
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
  var baseCopy = require('lodash._basecopy'),
    keys = require('lodash.keys')

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
  function baseAssign (object, source) {
    return source == null
    ? object
    : baseCopy(source, keys(source), object)
  }

  module.exports = baseAssign
}, { 'lodash._basecopy': 71, 'lodash.keys': 78 }], 71: [function (require, module, exports) {
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
  function baseCopy (source, props, object) {
    object || (object = {})

    var index = -1,
      length = props.length

    while (++index < length) {
      var key = props[index]
      object[key] = source[key]
    }
    return object
  }

  module.exports = baseCopy
}, {}], 72: [function (require, module, exports) {
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
  var baseCreate = (function () {
    function object () {}
    return function (prototype) {
      if (isObject(prototype)) {
        object.prototype = prototype
        var result = new object()
        object.prototype = undefined
      }
      return result || {}
    }
  }())

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
  function isObject (value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value
    return !!value && (type == 'object' || type == 'function')
  }

  module.exports = baseCreate
}, {}], 73: [function (require, module, exports) {
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
  var funcTag = '[object Function]'

/** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
  function isObjectLike (value) {
    return !!value && typeof value === 'object'
  }

/** Used for native method references. */
  var objectProto = Object.prototype

/** Used to resolve the decompiled source of functions. */
  var fnToString = Function.prototype.toString

/** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
  var objToString = objectProto.toString

/** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
)

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
  function getNative (object, key) {
    var value = object == null ? undefined : object[key]
    return isNative(value) ? value : undefined
  }

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
  function isFunction (value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
    return isObject(value) && objToString.call(value) == funcTag
  }

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
  function isObject (value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value
    return !!value && (type == 'object' || type == 'function')
  }

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
  function isNative (value) {
    if (value == null) {
      return false
    }
    if (isFunction(value)) {
      return reIsNative.test(fnToString.call(value))
    }
    return isObjectLike(value) && reIsHostCtor.test(value)
  }

  module.exports = getNative
}, {}], 74: [function (require, module, exports) {
/**
 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
  var MAX_SAFE_INTEGER = 9007199254740991

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
  function baseProperty (key) {
    return function (object) {
      return object == null ? undefined : object[key]
    }
  }

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
  var getLength = baseProperty('length')

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
  function isArrayLike (value) {
    return value != null && isLength(getLength(value))
  }

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
  function isIndex (value, length) {
    value = (typeof value === 'number' || reIsUint.test(value)) ? +value : -1
    length = length == null ? MAX_SAFE_INTEGER : length
    return value > -1 && value % 1 == 0 && value < length
  }

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
  function isIterateeCall (value, index, object) {
    if (!isObject(object)) {
      return false
    }
    var type = typeof index
    if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
      var other = object[index]
      return value === value ? (value === other) : (other !== other)
    }
    return false
  }

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
  function isLength (value) {
    return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
  }

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
  function isObject (value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value
    return !!value && (type == 'object' || type == 'function')
  }

  module.exports = isIterateeCall
}, {}], 75: [function (require, module, exports) {
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
  var baseAssign = require('lodash._baseassign'),
    baseCreate = require('lodash._basecreate'),
    isIterateeCall = require('lodash._isiterateecall')

/**
 * Creates an object that inherits from the given `prototype` object. If a
 * `properties` object is provided its own enumerable properties are assigned
 * to the created object.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
  function create (prototype, properties, guard) {
    var result = baseCreate(prototype)
    if (guard && isIterateeCall(prototype, properties, guard)) {
      properties = undefined
    }
    return properties ? baseAssign(result, properties) : result
  }

  module.exports = create
}, { 'lodash._baseassign': 70, 'lodash._basecreate': 72, 'lodash._isiterateecall': 74 }], 76: [function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991

/** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]'

/** Used for built-in method references. */
  var objectProto = Object.prototype

/** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
  var objectToString = objectProto.toString

/** Built-in value references. */
  var propertyIsEnumerable = objectProto.propertyIsEnumerable

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
  function isArguments (value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag)
  }

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
  function isArrayLike (value) {
    return value != null && isLength(value.length) && !isFunction(value)
  }

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
  function isArrayLikeObject (value) {
    return isObjectLike(value) && isArrayLike(value)
  }

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
  function isFunction (value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : ''
    return tag == funcTag || tag == genTag
  }

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
  function isLength (value) {
    return typeof value === 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
  }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
  function isObject (value) {
    var type = typeof value
    return !!value && (type == 'object' || type == 'function')
  }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
  function isObjectLike (value) {
    return !!value && typeof value === 'object'
  }

  module.exports = isArguments
}, {}], 77: [function (require, module, exports) {
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
  var arrayTag = '[object Array]',
    funcTag = '[object Function]'

/** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
  function isObjectLike (value) {
    return !!value && typeof value === 'object'
  }

/** Used for native method references. */
  var objectProto = Object.prototype

/** Used to resolve the decompiled source of functions. */
  var fnToString = Function.prototype.toString

/** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
  var objToString = objectProto.toString

/** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
)

/* Native method references for those with the same name as other `lodash` methods. */
  var nativeIsArray = getNative(Array, 'isArray')

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
  var MAX_SAFE_INTEGER = 9007199254740991

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
  function getNative (object, key) {
    var value = object == null ? undefined : object[key]
    return isNative(value) ? value : undefined
  }

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
  function isLength (value) {
    return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
  }

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
  var isArray = nativeIsArray || function (value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag
  }

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
  function isFunction (value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
    return isObject(value) && objToString.call(value) == funcTag
  }

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
  function isObject (value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value
    return !!value && (type == 'object' || type == 'function')
  }

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
  function isNative (value) {
    if (value == null) {
      return false
    }
    if (isFunction(value)) {
      return reIsNative.test(fnToString.call(value))
    }
    return isObjectLike(value) && reIsHostCtor.test(value)
  }

  module.exports = isArray
}, {}], 78: [function (require, module, exports) {
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
  var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray')

/** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/

/** Used for native method references. */
  var objectProto = Object.prototype

/** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty

/* Native method references for those with the same name as other `lodash` methods. */
  var nativeKeys = getNative(Object, 'keys')

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
  var MAX_SAFE_INTEGER = 9007199254740991

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
  function baseProperty (key) {
    return function (object) {
      return object == null ? undefined : object[key]
    }
  }

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
  var getLength = baseProperty('length')

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
  function isArrayLike (value) {
    return value != null && isLength(getLength(value))
  }

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
  function isIndex (value, length) {
    value = (typeof value === 'number' || reIsUint.test(value)) ? +value : -1
    length = length == null ? MAX_SAFE_INTEGER : length
    return value > -1 && value % 1 == 0 && value < length
  }

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
  function isLength (value) {
    return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
  }

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
  function shimKeys (object) {
    var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length

    var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object))

    var index = -1,
      result = []

    while (++index < propsLength) {
      var key = props[index]
      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
        result.push(key)
      }
    }
    return result
  }

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
  function isObject (value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value
    return !!value && (type == 'object' || type == 'function')
  }

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
  var keys = !nativeKeys ? shimKeys : function (object) {
    var Ctor = object == null ? undefined : object.constructor
    if ((typeof Ctor === 'function' && Ctor.prototype === object) ||
      (typeof object !== 'function' && isArrayLike(object))) {
      return shimKeys(object)
    }
    return isObject(object) ? nativeKeys(object) : []
  }

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
  function keysIn (object) {
    if (object == null) {
      return []
    }
    if (!isObject(object)) {
      object = Object(object)
    }
    var length = object.length
    length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0

    var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor === 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0

    while (++index < length) {
      result[index] = (index + '')
    }
    for (var key in object) {
      if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key)
      }
    }
    return result
  }

  module.exports = keys
}, { 'lodash._getnative': 73, 'lodash.isarguments': 76, 'lodash.isarray': 77 }], 79: [function (require, module, exports) {
  (function (process) {
    var path = require('path')
    var fs = require('fs')
    var _0777 = parseInt('0777', 8)

    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP

    function mkdirP (p, opts, f, made) {
      if (typeof opts === 'function') {
        f = opts
        opts = {}
      } else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts }
      }

      var mode = opts.mode
      var xfs = opts.fs || fs

      if (mode === undefined) {
        mode = _0777 & (~process.umask())
      }
      if (!made) made = null

      var cb = f || function () {}
      p = path.resolve(p)

      xfs.mkdir(p, mode, function (er) {
        if (!er) {
          made = made || p
          return cb(null, made)
        }
        switch (er.code) {
          case 'ENOENT':
            mkdirP(path.dirname(p), opts, function (er, made) {
              if (er) cb(er, made)
              else mkdirP(p, opts, cb, made)
            })
            break

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
          default:
            xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
              if (er2 || !stat.isDirectory()) cb(er, made)
              else cb(null, made)
            })
            break
        }
      })
    }

    mkdirP.sync = function sync (p, opts, made) {
      if (!opts || typeof opts !== 'object') {
        opts = { mode: opts }
      }

      var mode = opts.mode
      var xfs = opts.fs || fs

      if (mode === undefined) {
        mode = _0777 & (~process.umask())
      }
      if (!made) made = null

      p = path.resolve(p)

      try {
        xfs.mkdirSync(p, mode)
        made = made || p
      } catch (err0) {
        switch (err0.code) {
          case 'ENOENT' :
            made = sync(path.dirname(p), opts, made)
            sync(p, opts, made)
            break

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
          default:
            var stat
            try {
              stat = xfs.statSync(p)
            } catch (err1) {
              throw err0
            }
            if (!stat.isDirectory()) throw err0
            break
        }
      }

      return made
    }
  }).call(this, require('_process'))
}, { '_process': 82, 'fs': 42, 'path': 42 }], 80: [function (require, module, exports) {
  exports.endianness = function () { return 'LE' }

  exports.hostname = function () {
    if (typeof location !== 'undefined') {
      return location.hostname
    } else return ''
  }

  exports.loadavg = function () { return [] }

  exports.uptime = function () { return 0 }

  exports.freemem = function () {
    return Number.MAX_VALUE
  }

  exports.totalmem = function () {
    return Number.MAX_VALUE
  }

  exports.cpus = function () { return [] }

  exports.type = function () { return 'Browser' }

  exports.release = function () {
    if (typeof navigator !== 'undefined') {
      return navigator.appVersion
    }
    return ''
  }

  exports.networkInterfaces =
exports.getNetworkInterfaces =
function () { return {} }

  exports.arch = function () { return 'javascript' }

  exports.platform = function () { return 'browser' }

  exports.tmpdir = exports.tmpDir = function () {
    return '/tmp'
  }

  exports.EOL = '\n'
}, {}], 81: [function (require, module, exports) {
  (function (process) {
    'use strict'

    if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
      module.exports = nextTick
    } else {
      module.exports = process.nextTick
    }

    function nextTick (fn, arg1, arg2, arg3) {
      if (typeof fn !== 'function') {
        throw new TypeError('"callback" argument must be a function')
      }
      var len = arguments.length
      var args, i
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn)
        case 2:
          return process.nextTick(function afterTickOne () {
            fn.call(null, arg1)
          })
        case 3:
          return process.nextTick(function afterTickTwo () {
            fn.call(null, arg1, arg2)
          })
        case 4:
          return process.nextTick(function afterTickThree () {
            fn.call(null, arg1, arg2, arg3)
          })
        default:
          args = new Array(len - 1)
          i = 0
          while (i < args.length) {
            args[i++] = arguments[i]
          }
          return process.nextTick(function afterTick () {
            fn.apply(null, args)
          })
      }
    }
  }).call(this, require('_process'))
}, { '_process': 82 }], 82: [function (require, module, exports) {
// shim for using process in browser
  var process = module.exports = {}

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

  var cachedSetTimeout
  var cachedClearTimeout

  function defaultSetTimout () {
    throw new Error('setTimeout has not been defined')
  }
  function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined')
  }
  (function () {
    try {
      if (typeof setTimeout === 'function') {
        cachedSetTimeout = setTimeout
      } else {
        cachedSetTimeout = defaultSetTimout
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout
    }
    try {
      if (typeof clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout
      } else {
        cachedClearTimeout = defaultClearTimeout
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout
    }
  }())
  function runTimeout (fun) {
    if (cachedSetTimeout === setTimeout) {
        // normal enviroments in sane situations
      return setTimeout(fun, 0)
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout
      return setTimeout(fun, 0)
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout(fun, 0)
    } catch (e) {
      try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout.call(null, fun, 0)
      } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout.call(this, fun, 0)
      }
    }
  }
  function runClearTimeout (marker) {
    if (cachedClearTimeout === clearTimeout) {
        // normal enviroments in sane situations
      return clearTimeout(marker)
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout
      return clearTimeout(marker)
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout(marker)
    } catch (e) {
      try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout.call(null, marker)
      } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout.call(this, marker)
      }
    }
  }
  var queue = []
  var draining = false
  var currentQueue
  var queueIndex = -1

  function cleanUpNextTick () {
    if (!draining || !currentQueue) {
      return
    }
    draining = false
    if (currentQueue.length) {
      queue = currentQueue.concat(queue)
    } else {
      queueIndex = -1
    }
    if (queue.length) {
      drainQueue()
    }
  }

  function drainQueue () {
    if (draining) {
      return
    }
    var timeout = runTimeout(cleanUpNextTick)
    draining = true

    var len = queue.length
    while (len) {
      currentQueue = queue
      queue = []
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run()
        }
      }
      queueIndex = -1
      len = queue.length
    }
    currentQueue = null
    draining = false
    runClearTimeout(timeout)
  }

  process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1)
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i]
      }
    }
    queue.push(new Item(fun, args))
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue)
    }
  }

// v8 likes predictible objects
  function Item (fun, array) {
    this.fun = fun
    this.array = array
  }
  Item.prototype.run = function () {
    this.fun.apply(null, this.array)
  }
  process.title = 'browser'
  process.browser = true
  process.env = {}
  process.argv = []
  process.version = '' // empty string to avoid regexp issues
  process.versions = {}

  function noop () {}

  process.on = noop
  process.addListener = noop
  process.once = noop
  process.off = noop
  process.removeListener = noop
  process.removeAllListeners = noop
  process.emit = noop
  process.prependListener = noop
  process.prependOnceListener = noop

  process.listeners = function (name) { return [] }

  process.binding = function (name) {
    throw new Error('process.binding is not supported')
  }

  process.cwd = function () { return '/' }
  process.chdir = function (dir) {
    throw new Error('process.chdir is not supported')
  }
  process.umask = function () { return 0 }
}, {}], 83: [function (require, module, exports) {
  module.exports = require('./lib/_stream_duplex.js')
}, { './lib/_stream_duplex.js': 84 }], 84: [function (require, module, exports) {
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

  'use strict'

/* <replacement>*/

  var objectKeys = Object.keys || function (obj) {
    var keys = []
    for (var key in obj) {
      keys.push(key)
    } return keys
  }
/* </replacement>*/

  module.exports = Duplex

/* <replacement>*/
  var processNextTick = require('process-nextick-args')
/* </replacement>*/

/* <replacement>*/
  var util = require('core-util-is')
  util.inherits = require('inherits')
/* </replacement>*/

  var Readable = require('./_stream_readable')
  var Writable = require('./_stream_writable')

  util.inherits(Duplex, Readable)

  var keys = objectKeys(Writable.prototype)
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v]
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
  }

  function Duplex (options) {
    if (!(this instanceof Duplex)) return new Duplex(options)

    Readable.call(this, options)
    Writable.call(this, options)

    if (options && options.readable === false) this.readable = false

    if (options && options.writable === false) this.writable = false

    this.allowHalfOpen = true
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false

    this.once('end', onend)
  }

// the no-half-open enforcer
  function onend () {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return

  // no more data can be written.
  // But allow more writes to happen in this tick.
    processNextTick(onEndNT, this)
  }

  function onEndNT (self) {
    self.end()
  }

  function forEach (xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i)
    }
  }
}, { './_stream_readable': 86, './_stream_writable': 88, 'core-util-is': 44, 'inherits': 66, 'process-nextick-args': 81 }], 85: [function (require, module, exports) {
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

  'use strict'

  module.exports = PassThrough

  var Transform = require('./_stream_transform')

/* <replacement>*/
  var util = require('core-util-is')
  util.inherits = require('inherits')
/* </replacement>*/

  util.inherits(PassThrough, Transform)

  function PassThrough (options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options)

    Transform.call(this, options)
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk)
  }
}, { './_stream_transform': 87, 'core-util-is': 44, 'inherits': 66 }], 86: [function (require, module, exports) {
  (function (process) {
    'use strict'

    module.exports = Readable

/* <replacement>*/
    var processNextTick = require('process-nextick-args')
/* </replacement>*/

/* <replacement>*/
    var isArray = require('isarray')
/* </replacement>*/

/* <replacement>*/
    var Duplex
/* </replacement>*/

    Readable.ReadableState = ReadableState

/* <replacement>*/
    var EE = require('events').EventEmitter

    var EElistenerCount = function (emitter, type) {
      return emitter.listeners(type).length
    }
/* </replacement>*/

/* <replacement>*/
    var Stream = require('./internal/streams/stream')
/* </replacement>*/

/* <replacement>*/
    var Buffer = require('safe-buffer').Buffer
/* </replacement>*/

/* <replacement>*/
    var util = require('core-util-is')
    util.inherits = require('inherits')
/* </replacement>*/

/* <replacement>*/
    var debugUtil = require('util')
    var debug = void 0
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog('stream')
    } else {
      debug = function () {}
    }
/* </replacement>*/

    var BufferList = require('./internal/streams/BufferList')
    var StringDecoder

    util.inherits(Readable, Stream)

    var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume']

    function prependListener (emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn)
      } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]]
      }
    }

    function ReadableState (options, stream) {
      Duplex = Duplex || require('./_stream_duplex')

      options = options || {}

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark
      var defaultHwm = this.objectMode ? 16 : 16 * 1024
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm

  // cast to ints.
      this.highWaterMark = ~~this.highWaterMark

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
      this.buffer = new BufferList()
      this.length = 0
      this.pipes = null
      this.pipesCount = 0
      this.flowing = null
      this.ended = false
      this.endEmitted = false
      this.reading = false

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
      this.sync = true

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
      this.needReadable = false
      this.emittedReadable = false
      this.readableListening = false
      this.resumeScheduled = false

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8'

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false

  // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0

  // if true, a maybeReadMore has been scheduled
      this.readingMore = false

      this.decoder = null
      this.encoding = null
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder
        this.decoder = new StringDecoder(options.encoding)
        this.encoding = options.encoding
      }
    }

    function Readable (options) {
      Duplex = Duplex || require('./_stream_duplex')

      if (!(this instanceof Readable)) return new Readable(options)

      this._readableState = new ReadableState(options, this)

  // legacy
      this.readable = true

      if (options && typeof options.read === 'function') this._read = options.read

      Stream.call(this)
    }

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState

      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding)
          encoding = ''
        }
      }

      return readableAddChunk(this, state, chunk, encoding, false)
    }

// Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState
      return readableAddChunk(this, state, chunk, '', true)
    }

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false
    }

    function readableAddChunk (stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk)
      if (er) {
        stream.emit('error', er)
      } else if (chunk === null) {
        state.reading = false
        onEofChunk(stream, state)
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF')
          stream.emit('error', e)
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event')
          stream.emit('error', _e)
        } else {
          var skipAdd
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk)
            skipAdd = !state.objectMode && chunk.length === 0
          }

          if (!addToFront) state.reading = false

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
          if (!skipAdd) {
        // if we want the data now, just emit it.
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk)
              stream.read(0)
            } else {
          // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length
              if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk)

              if (state.needReadable) emitReadable(stream)
            }
          }

          maybeReadMore(stream, state)
        }
      } else if (!addToFront) {
        state.reading = false
      }

      return needMoreData(state)
    }

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
    function needMoreData (state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0)
    }

// backwards compatibility.
    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder
      this._readableState.decoder = new StringDecoder(enc)
      this._readableState.encoding = enc
      return this
    }

// Don't raise the hwm > 8MB
    var MAX_HWM = 0x800000
    function computeNewHighWaterMark (n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM
      } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
        n--
        n |= n >>> 1
        n |= n >>> 2
        n |= n >>> 4
        n |= n >>> 8
        n |= n >>> 16
        n++
      }
      return n
    }

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
    function howMuchToRead (n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0
      if (state.objectMode) return 1
      if (n !== n) {
    // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length
      }
  // If we're asking for more than the current hwm, then raise the hwm.
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)
      if (n <= state.length) return n
  // Don't have enough
      if (!state.ended) {
        state.needReadable = true
        return 0
      }
      return state.length
    }

// you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function (n) {
      debug('read', n)
      n = parseInt(n, 10)
      var state = this._readableState
      var nOrig = n

      if (n !== 0) state.emittedReadable = false

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended)
        if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this)
        return null
      }

      n = howMuchToRead(n, state)

  // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this)
        return null
      }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable
      debug('need readable', doRead)

  // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true
        debug('length less than watermark', doRead)
      }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false
        debug('reading or ended', doRead)
      } else if (doRead) {
        debug('do read')
        state.reading = true
        state.sync = true
    // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true
    // call internal read method
        this._read(state.highWaterMark)
        state.sync = false
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state)
      }

      var ret
      if (n > 0) ret = fromList(n, state); else ret = null

      if (ret === null) {
        state.needReadable = true
        n = 0
      } else {
        state.length -= n
      }

      if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true

    // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this)
      }

      if (ret !== null) this.emit('data', ret)

      return ret
    }

    function chunkInvalid (state, chunk) {
      var er = null
      if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk')
      }
      return er
    }

    function onEofChunk (stream, state) {
      if (state.ended) return
      if (state.decoder) {
        var chunk = state.decoder.end()
        if (chunk && chunk.length) {
          state.buffer.push(chunk)
          state.length += state.objectMode ? 1 : chunk.length
        }
      }
      state.ended = true

  // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream)
    }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
    function emitReadable (stream) {
      var state = stream._readableState
      state.needReadable = false
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing)
        state.emittedReadable = true
        if (state.sync) processNextTick(emitReadable_, stream); else emitReadable_(stream)
      }
    }

    function emitReadable_ (stream) {
      debug('emit readable')
      stream.emit('readable')
      flow(stream)
    }

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
    function maybeReadMore (stream, state) {
      if (!state.readingMore) {
        state.readingMore = true
        processNextTick(maybeReadMore_, stream, state)
      }
    }

    function maybeReadMore_ (stream, state) {
      var len = state.length
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0')
        stream.read(0)
        if (len === state.length)
      // didn't get any data, stop spinning.
      { break } else len = state.length
      }
      state.readingMore = false
    }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('_read() is not implemented'))
    }

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this
      var state = this._readableState

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest
          break
        case 1:
          state.pipes = [state.pipes, dest]
          break
        default:
          state.pipes.push(dest)
          break
      }
      state.pipesCount += 1
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts)

      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr

      var endFn = doEnd ? onend : unpipe
      if (state.endEmitted) processNextTick(endFn); else src.once('end', endFn)

      dest.on('unpipe', onunpipe)
      function onunpipe (readable) {
        debug('onunpipe')
        if (readable === src) {
          cleanup()
        }
      }

      function onend () {
        debug('onend')
        dest.end()
      }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
      var ondrain = pipeOnDrain(src)
      dest.on('drain', ondrain)

      var cleanedUp = false
      function cleanup () {
        debug('cleanup')
    // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose)
        dest.removeListener('finish', onfinish)
        dest.removeListener('drain', ondrain)
        dest.removeListener('error', onerror)
        dest.removeListener('unpipe', onunpipe)
        src.removeListener('end', onend)
        src.removeListener('end', unpipe)
        src.removeListener('data', ondata)

        cleanedUp = true

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain()
      }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
      var increasedAwaitDrain = false
      src.on('data', ondata)
      function ondata (chunk) {
        debug('ondata')
        increasedAwaitDrain = false
        var ret = dest.write(chunk)
        if (ret === false && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug('false write response, pause', src._readableState.awaitDrain)
            src._readableState.awaitDrain++
            increasedAwaitDrain = true
          }
          src.pause()
        }
      }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
      function onerror (er) {
        debug('onerror', er)
        unpipe()
        dest.removeListener('error', onerror)
        if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er)
      }

  // Make sure our error handler is attached before userland ones.
      prependListener(dest, 'error', onerror)

  // Both close and finish should trigger unpipe, but only once.
      function onclose () {
        dest.removeListener('finish', onfinish)
        unpipe()
      }
      dest.once('close', onclose)
      function onfinish () {
        debug('onfinish')
        dest.removeListener('close', onclose)
        unpipe()
      }
      dest.once('finish', onfinish)

      function unpipe () {
        debug('unpipe')
        src.unpipe(dest)
      }

  // tell the dest that it's being piped to
      dest.emit('pipe', src)

  // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume')
        src.resume()
      }

      return dest
    }

    function pipeOnDrain (src) {
      return function () {
        var state = src._readableState
        debug('pipeOnDrain', state.awaitDrain)
        if (state.awaitDrain) state.awaitDrain--
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
          state.flowing = true
          flow(src)
        }
      }
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState

  // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0) return this

  // just one destination.  most common case.
      if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this

        if (!dest) dest = state.pipes

    // got a match.
        state.pipes = null
        state.pipesCount = 0
        state.flowing = false
        if (dest) dest.emit('unpipe', this)
        return this
      }

  // slow case. multiple pipe destinations.

      if (!dest) {
    // remove all.
        var dests = state.pipes
        var len = state.pipesCount
        state.pipes = null
        state.pipesCount = 0
        state.flowing = false

        for (var i = 0; i < len; i++) {
          dests[i].emit('unpipe', this)
        } return this
      }

  // try to find the right one.
      var index = indexOf(state.pipes, dest)
      if (index === -1) return this

      state.pipes.splice(index, 1)
      state.pipesCount -= 1
      if (state.pipesCount === 1) state.pipes = state.pipes[0]

      dest.emit('unpipe', this)

      return this
    }

// set up data events if they are asked for
// Ensure readable listeners eventually get something
    Readable.prototype.on = function (ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn)

      if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume()
      } else if (ev === 'readable') {
        var state = this._readableState
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true
          state.emittedReadable = false
          if (!state.reading) {
            processNextTick(nReadingNextTick, this)
          } else if (state.length) {
            emitReadable(this, state)
          }
        }
      }

      return res
    }
    Readable.prototype.addListener = Readable.prototype.on

    function nReadingNextTick (self) {
      debug('readable nexttick read 0')
      self.read(0)
    }

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
    Readable.prototype.resume = function () {
      var state = this._readableState
      if (!state.flowing) {
        debug('resume')
        state.flowing = true
        resume(this, state)
      }
      return this
    }

    function resume (stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true
        processNextTick(resume_, stream, state)
      }
    }

    function resume_ (stream, state) {
      if (!state.reading) {
        debug('resume read 0')
        stream.read(0)
      }

      state.resumeScheduled = false
      state.awaitDrain = 0
      stream.emit('resume')
      flow(stream)
      if (state.flowing && !state.reading) stream.read(0)
    }

    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing)
      if (this._readableState.flowing !== false) {
        debug('pause')
        this._readableState.flowing = false
        this.emit('pause')
      }
      return this
    }

    function flow (stream) {
      var state = stream._readableState
      debug('flow', state.flowing)
      while (state.flowing && stream.read() !== null) {}
    }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState
      var paused = false

      var self = this
      stream.on('end', function () {
        debug('wrapped end')
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end()
          if (chunk && chunk.length) self.push(chunk)
        }

        self.push(null)
      })

      stream.on('data', function (chunk) {
        debug('wrapped data')
        if (state.decoder) chunk = state.decoder.write(chunk)

    // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return

        var ret = self.push(chunk)
        if (!ret) {
          paused = true
          stream.pause()
        }
      })

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = (function (method) {
            return function () {
              return stream[method].apply(stream, arguments)
            }
          }(i))
        }
      }

  // proxy certain important events.
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]))
      }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
      self._read = function (n) {
        debug('wrapped _read', n)
        if (paused) {
          paused = false
          stream.resume()
        }
      }

      return self
    }

// exposed for testing purposes only.
    Readable._fromList = fromList

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
    function fromList (n, state) {
  // nothing buffered
      if (state.length === 0) return null

      var ret
      if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
    // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length)
        state.buffer.clear()
      } else {
    // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder)
      }

      return ret
    }

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
    function fromListPartial (n, list, hasStrings) {
      var ret
      if (n < list.head.data.length) {
    // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n)
        list.head.data = list.head.data.slice(n)
      } else if (n === list.head.data.length) {
    // first chunk is a perfect match
        ret = list.shift()
      } else {
    // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list)
      }
      return ret
    }

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
    function copyFromBufferString (n, list) {
      var p = list.head
      var c = 1
      var ret = p.data
      n -= ret.length
      while (p = p.next) {
        var str = p.data
        var nb = n > str.length ? str.length : n
        if (nb === str.length) ret += str; else ret += str.slice(0, n)
        n -= nb
        if (n === 0) {
          if (nb === str.length) {
            ++c
            if (p.next) list.head = p.next; else list.head = list.tail = null
          } else {
            list.head = p
            p.data = str.slice(nb)
          }
          break
        }
        ++c
      }
      list.length -= c
      return ret
    }

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
    function copyFromBuffer (n, list) {
      var ret = Buffer.allocUnsafe(n)
      var p = list.head
      var c = 1
      p.data.copy(ret)
      n -= p.data.length
      while (p = p.next) {
        var buf = p.data
        var nb = n > buf.length ? buf.length : n
        buf.copy(ret, ret.length - n, 0, nb)
        n -= nb
        if (n === 0) {
          if (nb === buf.length) {
            ++c
            if (p.next) list.head = p.next; else list.head = list.tail = null
          } else {
            list.head = p
            p.data = buf.slice(nb)
          }
          break
        }
        ++c
      }
      list.length -= c
      return ret
    }

    function endReadable (stream) {
      var state = stream._readableState

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream')

      if (!state.endEmitted) {
        state.ended = true
        processNextTick(endReadableNT, state, stream)
      }
    }

    function endReadableNT (state, stream) {
  // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true
        stream.readable = false
        stream.emit('end')
      }
    }

    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i)
      }
    }

    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i
      }
      return -1
    }
  }).call(this, require('_process'))
}, { './_stream_duplex': 84, './internal/streams/BufferList': 89, './internal/streams/stream': 90, '_process': 82, 'core-util-is': 44, 'events': 62, 'inherits': 66, 'isarray': 68, 'process-nextick-args': 81, 'safe-buffer': 95, 'string_decoder/': 97, 'util': 40 }], 87: [function (require, module, exports) {
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

  'use strict'

  module.exports = Transform

  var Duplex = require('./_stream_duplex')

/* <replacement>*/
  var util = require('core-util-is')
  util.inherits = require('inherits')
/* </replacement>*/

  util.inherits(Transform, Duplex)

  function TransformState (stream) {
    this.afterTransform = function (er, data) {
      return afterTransform(stream, er, data)
    }

    this.needTransform = false
    this.transforming = false
    this.writecb = null
    this.writechunk = null
    this.writeencoding = null
  }

  function afterTransform (stream, er, data) {
    var ts = stream._transformState
    ts.transforming = false

    var cb = ts.writecb

    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'))

    ts.writechunk = null
    ts.writecb = null

    if (data !== null && data !== undefined) stream.push(data)

    cb(er)

    var rs = stream._readableState
    rs.reading = false
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark)
    }
  }

  function Transform (options) {
    if (!(this instanceof Transform)) return new Transform(options)

    Duplex.call(this, options)

    this._transformState = new TransformState(this)

    var stream = this

  // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
    this._readableState.sync = false

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform

      if (typeof options.flush === 'function') this._flush = options.flush
    }

  // When the writable side finishes, then flush out anything remaining.
    this.once('prefinish', function () {
      if (typeof this._flush === 'function') {
        this._flush(function (er, data) {
          done(stream, er, data)
        })
      } else done(stream)
    })
  }

  Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false
    return Duplex.prototype.push.call(this, chunk, encoding)
  }

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
  Transform.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('_transform() is not implemented')
  }

  Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState
    ts.writecb = cb
    ts.writechunk = chunk
    ts.writeencoding = encoding
    if (!ts.transforming) {
      var rs = this._readableState
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark)
    }
  }

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
  Transform.prototype._read = function (n) {
    var ts = this._transformState

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
    } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
      ts.needTransform = true
    }
  }

  function done (stream, er, data) {
    if (er) return stream.emit('error', er)

    if (data !== null && data !== undefined) stream.push(data)

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
    var ws = stream._writableState
    var ts = stream._transformState

    if (ws.length) throw new Error('Calling transform done when ws.length != 0')

    if (ts.transforming) throw new Error('Calling transform done when still transforming')

    return stream.push(null)
  }
}, { './_stream_duplex': 84, 'core-util-is': 44, 'inherits': 66 }], 88: [function (require, module, exports) {
  (function (process) {
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

    'use strict'

    module.exports = Writable

/* <replacement>*/
    var processNextTick = require('process-nextick-args')
/* </replacement>*/

/* <replacement>*/
    var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick
/* </replacement>*/

/* <replacement>*/
    var Duplex
/* </replacement>*/

    Writable.WritableState = WritableState

/* <replacement>*/
    var util = require('core-util-is')
    util.inherits = require('inherits')
/* </replacement>*/

/* <replacement>*/
    var internalUtil = {
      deprecate: require('util-deprecate')
    }
/* </replacement>*/

/* <replacement>*/
    var Stream = require('./internal/streams/stream')
/* </replacement>*/

/* <replacement>*/
    var Buffer = require('safe-buffer').Buffer
/* </replacement>*/

    util.inherits(Writable, Stream)

    function nop () {}

    function WriteReq (chunk, encoding, cb) {
      this.chunk = chunk
      this.encoding = encoding
      this.callback = cb
      this.next = null
    }

    function WritableState (options, stream) {
      Duplex = Duplex || require('./_stream_duplex')

      options = options || {}

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
      this.objectMode = !!options.objectMode

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark
      var defaultHwm = this.objectMode ? 16 : 16 * 1024
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm

  // cast to ints.
      this.highWaterMark = ~~this.highWaterMark

  // drain event flag.
      this.needDrain = false
  // at the start of calling end()
      this.ending = false
  // when end() has been called, and returned
      this.ended = false
  // when 'finish' is emitted
      this.finished = false

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
      var noDecode = options.decodeStrings === false
      this.decodeStrings = !noDecode

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8'

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
      this.length = 0

  // a flag to see when we're in the middle of a write.
      this.writing = false

  // when true all writes will be buffered until .uncork() call
      this.corked = 0

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
      this.sync = true

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
      this.bufferProcessing = false

  // the callback that's passed to _write(chunk,cb)
      this.onwrite = function (er) {
        onwrite(stream, er)
      }

  // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null

  // the amount that is being written when _write is called.
      this.writelen = 0

      this.bufferedRequest = null
      this.lastBufferedRequest = null

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
      this.prefinished = false

  // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false

  // count buffered requests
      this.bufferedRequestCount = 0

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
      this.corkedRequestsFree = new CorkedRequest(this)
    }

    WritableState.prototype.getBuffer = function getBuffer () {
      var current = this.bufferedRequest
      var out = []
      while (current) {
        out.push(current)
        current = current.next
      }
      return out
    };

    (function () {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
          get: internalUtil.deprecate(function () {
            return this.getBuffer()
          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
        })
      } catch (_) {}
    })()

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
    var realHasInstance
    if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
      realHasInstance = Function.prototype[Symbol.hasInstance]
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function (object) {
          if (realHasInstance.call(this, object)) return true

          return object && object._writableState instanceof WritableState
        }
      })
    } else {
      realHasInstance = function (object) {
        return object instanceof this
      }
    }

    function Writable (options) {
      Duplex = Duplex || require('./_stream_duplex')

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options)
      }

      this._writableState = new WritableState(options, this)

  // legacy.
      this.writable = true

      if (options) {
        if (typeof options.write === 'function') this._write = options.write

        if (typeof options.writev === 'function') this._writev = options.writev
      }

      Stream.call(this)
    }

// Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'))
    }

    function writeAfterEnd (stream, cb) {
      var er = new Error('write after end')
  // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er)
      processNextTick(cb, er)
    }

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
    function validChunk (stream, state, chunk, cb) {
      var valid = true
      var er = false

      if (chunk === null) {
        er = new TypeError('May not write null values to stream')
      } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk')
      }
      if (er) {
        stream.emit('error', er)
        processNextTick(cb, er)
        valid = false
      }
      return valid
    }

    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState
      var ret = false
      var isBuf = Buffer.isBuffer(chunk)

      if (typeof encoding === 'function') {
        cb = encoding
        encoding = null
      }

      if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding

      if (typeof cb !== 'function') cb = nop

      if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
      }

      return ret
    }

    Writable.prototype.cork = function () {
      var state = this._writableState

      state.corked++
    }

    Writable.prototype.uncork = function () {
      var state = this._writableState

      if (state.corked) {
        state.corked--

        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state)
      }
    }

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding (encoding) {
  // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase()
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding)
      this._writableState.defaultEncoding = encoding
      return this
    }

    function decodeChunk (state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding)
      }
      return chunk
    }

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer (stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        chunk = decodeChunk(state, chunk, encoding)
        if (Buffer.isBuffer(chunk)) encoding = 'buffer'
      }
      var len = state.objectMode ? 1 : chunk.length

      state.length += len

      var ret = state.length < state.highWaterMark
  // we must ensure that previous needDrain will not be reset to false.
      if (!ret) state.needDrain = true

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb)
        if (last) {
          last.next = state.lastBufferedRequest
        } else {
          state.bufferedRequest = state.lastBufferedRequest
        }
        state.bufferedRequestCount += 1
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb)
      }

      return ret
    }

    function doWrite (stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len
      state.writecb = cb
      state.writing = true
      state.sync = true
      if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite)
      state.sync = false
    }

    function onwriteError (stream, state, sync, er, cb) {
      --state.pendingcb
      if (sync) processNextTick(cb, er); else cb(er)

      stream._writableState.errorEmitted = true
      stream.emit('error', er)
    }

    function onwriteStateUpdate (state) {
      state.writing = false
      state.writecb = null
      state.length -= state.writelen
      state.writelen = 0
    }

    function onwrite (stream, er) {
      var state = stream._writableState
      var sync = state.sync
      var cb = state.writecb

      onwriteStateUpdate(state)

      if (er) onwriteError(stream, state, sync, er, cb); else {
    // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state)

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state)
        }

        if (sync) {
      /* <replacement>*/
          asyncWrite(afterWrite, stream, state, finished, cb)
      /* </replacement>*/
        } else {
          afterWrite(stream, state, finished, cb)
        }
      }
    }

    function afterWrite (stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state)
      state.pendingcb--
      cb()
      finishMaybe(stream, state)
    }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
    function onwriteDrain (stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false
        stream.emit('drain')
      }
    }

// if there's something in the buffer waiting, then process it
    function clearBuffer (stream, state) {
      state.bufferProcessing = true
      var entry = state.bufferedRequest

      if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount
        var buffer = new Array(l)
        var holder = state.corkedRequestsFree
        holder.entry = entry

        var count = 0
        while (entry) {
          buffer[count] = entry
          entry = entry.next
          count += 1
        }

        doWrite(stream, state, true, state.length, buffer, '', holder.finish)

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
        state.pendingcb++
        state.lastBufferedRequest = null
        if (holder.next) {
          state.corkedRequestsFree = holder.next
          holder.next = null
        } else {
          state.corkedRequestsFree = new CorkedRequest(state)
        }
      } else {
    // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk
          var encoding = entry.encoding
          var cb = entry.callback
          var len = state.objectMode ? 1 : chunk.length

          doWrite(stream, state, false, len, chunk, encoding, cb)
          entry = entry.next
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
          if (state.writing) {
            break
          }
        }

        if (entry === null) state.lastBufferedRequest = null
      }

      state.bufferedRequestCount = 0
      state.bufferedRequest = entry
      state.bufferProcessing = false
    }

    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('_write() is not implemented'))
    }

    Writable.prototype._writev = null

    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState

      if (typeof chunk === 'function') {
        cb = chunk
        chunk = null
        encoding = null
      } else if (typeof encoding === 'function') {
        cb = encoding
        encoding = null
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding)

  // .end() fully uncorks
      if (state.corked) {
        state.corked = 1
        this.uncork()
      }

  // ignore unnecessary end() calls.
      if (!state.ending && !state.finished) endWritable(this, state, cb)
    }

    function needFinish (state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing
    }

    function prefinish (stream, state) {
      if (!state.prefinished) {
        state.prefinished = true
        stream.emit('prefinish')
      }
    }

    function finishMaybe (stream, state) {
      var need = needFinish(state)
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state)
          state.finished = true
          stream.emit('finish')
        } else {
          prefinish(stream, state)
        }
      }
      return need
    }

    function endWritable (stream, state, cb) {
      state.ending = true
      finishMaybe(stream, state)
      if (cb) {
        if (state.finished) processNextTick(cb); else stream.once('finish', cb)
      }
      state.ended = true
      stream.writable = false
    }

// It seems a linked list but it is not
// there will be only 2 of these for each stream
    function CorkedRequest (state) {
      var _this = this

      this.next = null
      this.entry = null
      this.finish = function (err) {
        var entry = _this.entry
        _this.entry = null
        while (entry) {
          var cb = entry.callback
          state.pendingcb--
          cb(err)
          entry = entry.next
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this
        } else {
          state.corkedRequestsFree = _this
        }
      }
    }
  }).call(this, require('_process'))
}, { './_stream_duplex': 84, './internal/streams/stream': 90, '_process': 82, 'core-util-is': 44, 'inherits': 66, 'process-nextick-args': 81, 'safe-buffer': 95, 'util-deprecate': 99 }], 89: [function (require, module, exports) {
  'use strict'

/* <replacement>*/

  var Buffer = require('safe-buffer').Buffer
/* </replacement>*/

  module.exports = BufferList

  function BufferList () {
    this.head = null
    this.tail = null
    this.length = 0
  }

  BufferList.prototype.push = function (v) {
    var entry = { data: v, next: null }
    if (this.length > 0) this.tail.next = entry; else this.head = entry
    this.tail = entry
    ++this.length
  }

  BufferList.prototype.unshift = function (v) {
    var entry = { data: v, next: this.head }
    if (this.length === 0) this.tail = entry
    this.head = entry
    ++this.length
  }

  BufferList.prototype.shift = function () {
    if (this.length === 0) return
    var ret = this.head.data
    if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next
    --this.length
    return ret
  }

  BufferList.prototype.clear = function () {
    this.head = this.tail = null
    this.length = 0
  }

  BufferList.prototype.join = function (s) {
    if (this.length === 0) return ''
    var p = this.head
    var ret = '' + p.data
    while (p = p.next) {
      ret += s + p.data
    } return ret
  }

  BufferList.prototype.concat = function (n) {
    if (this.length === 0) return Buffer.alloc(0)
    if (this.length === 1) return this.head.data
    var ret = Buffer.allocUnsafe(n >>> 0)
    var p = this.head
    var i = 0
    while (p) {
      p.data.copy(ret, i)
      i += p.data.length
      p = p.next
    }
    return ret
  }
}, { 'safe-buffer': 95 }], 90: [function (require, module, exports) {
  module.exports = require('events').EventEmitter
}, { 'events': 62 }], 91: [function (require, module, exports) {
  module.exports = require('./readable').PassThrough
}, { './readable': 92 }], 92: [function (require, module, exports) {
  exports = module.exports = require('./lib/_stream_readable.js')
  exports.Stream = exports
  exports.Readable = exports
  exports.Writable = require('./lib/_stream_writable.js')
  exports.Duplex = require('./lib/_stream_duplex.js')
  exports.Transform = require('./lib/_stream_transform.js')
  exports.PassThrough = require('./lib/_stream_passthrough.js')
}, { './lib/_stream_duplex.js': 84, './lib/_stream_passthrough.js': 85, './lib/_stream_readable.js': 86, './lib/_stream_transform.js': 87, './lib/_stream_writable.js': 88 }], 93: [function (require, module, exports) {
  module.exports = require('./readable').Transform
}, { './readable': 92 }], 94: [function (require, module, exports) {
  module.exports = require('./lib/_stream_writable.js')
}, { './lib/_stream_writable.js': 88 }], 95: [function (require, module, exports) {
  module.exports = require('buffer')
}, { 'buffer': 43 }], 96: [function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

  module.exports = Stream

  var EE = require('events').EventEmitter
  var inherits = require('inherits')

  inherits(Stream, EE)
  Stream.Readable = require('readable-stream/readable.js')
  Stream.Writable = require('readable-stream/writable.js')
  Stream.Duplex = require('readable-stream/duplex.js')
  Stream.Transform = require('readable-stream/transform.js')
  Stream.PassThrough = require('readable-stream/passthrough.js')

// Backwards-compat with node 0.4.x
  Stream.Stream = Stream

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

  function Stream () {
    EE.call(this)
  }

  Stream.prototype.pipe = function (dest, options) {
    var source = this

    function ondata (chunk) {
      if (dest.writable) {
        if (dest.write(chunk) === false && source.pause) {
          source.pause()
        }
      }
    }

    source.on('data', ondata)

    function ondrain () {
      if (source.readable && source.resume) {
        source.resume()
      }
    }

    dest.on('drain', ondrain)

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend)
      source.on('close', onclose)
    }

    var didOnEnd = false
    function onend () {
      if (didOnEnd) return
      didOnEnd = true

      dest.end()
    }

    function onclose () {
      if (didOnEnd) return
      didOnEnd = true

      if (typeof dest.destroy === 'function') dest.destroy()
    }

  // don't leave dangling pipes when there are errors.
    function onerror (er) {
      cleanup()
      if (EE.listenerCount(this, 'error') === 0) {
        throw er // Unhandled stream error in pipe.
      }
    }

    source.on('error', onerror)
    dest.on('error', onerror)

  // remove all the event listeners that were added.
    function cleanup () {
      source.removeListener('data', ondata)
      dest.removeListener('drain', ondrain)

      source.removeListener('end', onend)
      source.removeListener('close', onclose)

      source.removeListener('error', onerror)
      dest.removeListener('error', onerror)

      source.removeListener('end', cleanup)
      source.removeListener('close', cleanup)

      dest.removeListener('close', cleanup)
    }

    source.on('end', cleanup)
    source.on('close', cleanup)

    dest.on('close', cleanup)

    dest.emit('pipe', source)

  // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest
  }
}, { 'events': 62, 'inherits': 66, 'readable-stream/duplex.js': 83, 'readable-stream/passthrough.js': 91, 'readable-stream/readable.js': 92, 'readable-stream/transform.js': 93, 'readable-stream/writable.js': 94 }], 97: [function (require, module, exports) {
  'use strict'

  var Buffer = require('safe-buffer').Buffer

  var isEncoding = Buffer.isEncoding || function (encoding) {
    encoding = '' + encoding
    switch (encoding && encoding.toLowerCase()) {
      case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
        return true
      default:
        return false
    }
  }

  function _normalizeEncoding (enc) {
    if (!enc) return 'utf8'
    var retried
    while (true) {
      switch (enc) {
        case 'utf8':
        case 'utf-8':
          return 'utf8'
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 'utf16le'
        case 'latin1':
        case 'binary':
          return 'latin1'
        case 'base64':
        case 'ascii':
        case 'hex':
          return enc
        default:
          if (retried) return // undefined
          enc = ('' + enc).toLowerCase()
          retried = true
      }
    }
  };

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
  function normalizeEncoding (enc) {
    var nenc = _normalizeEncoding(enc)
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc)
    return nenc || enc
  }

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
  exports.StringDecoder = StringDecoder
  function StringDecoder (encoding) {
    this.encoding = normalizeEncoding(encoding)
    var nb
    switch (this.encoding) {
      case 'utf16le':
        this.text = utf16Text
        this.end = utf16End
        nb = 4
        break
      case 'utf8':
        this.fillLast = utf8FillLast
        nb = 4
        break
      case 'base64':
        this.text = base64Text
        this.end = base64End
        nb = 3
        break
      default:
        this.write = simpleWrite
        this.end = simpleEnd
        return
    }
    this.lastNeed = 0
    this.lastTotal = 0
    this.lastChar = Buffer.allocUnsafe(nb)
  }

  StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0) return ''
    var r
    var i
    if (this.lastNeed) {
      r = this.fillLast(buf)
      if (r === undefined) return ''
      i = this.lastNeed
      this.lastNeed = 0
    } else {
      i = 0
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i)
    return r || ''
  }

  StringDecoder.prototype.end = utf8End

// Returns only complete characters in a Buffer
  StringDecoder.prototype.text = utf8Text

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed)
      return this.lastChar.toString(this.encoding, 0, this.lastTotal)
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length)
    this.lastNeed -= buf.length
  }

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
  function utf8CheckByte (byte) {
    if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4
    return -1
  }

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
  function utf8CheckIncomplete (self, buf, i) {
    var j = buf.length - 1
    if (j < i) return 0
    var nb = utf8CheckByte(buf[j])
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 1
      return nb
    }
    if (--j < i) return 0
    nb = utf8CheckByte(buf[j])
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 2
      return nb
    }
    if (--j < i) return 0
    nb = utf8CheckByte(buf[j])
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0; else self.lastNeed = nb - 3
      }
      return nb
    }
    return 0
  }

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
  function utf8CheckExtraBytes (self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
      self.lastNeed = 0
      return '\ufffd'.repeat(p)
    }
    if (self.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 0xC0) !== 0x80) {
        self.lastNeed = 1
        return '\ufffd'.repeat(p + 1)
      }
      if (self.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 0xC0) !== 0x80) {
          self.lastNeed = 2
          return '\ufffd'.repeat(p + 2)
        }
      }
    }
  }

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
  function utf8FillLast (buf) {
    var p = this.lastTotal - this.lastNeed
    var r = utf8CheckExtraBytes(this, buf, p)
    if (r !== undefined) return r
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed)
      return this.lastChar.toString(this.encoding, 0, this.lastTotal)
    }
    buf.copy(this.lastChar, p, 0, buf.length)
    this.lastNeed -= buf.length
  }

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
  function utf8Text (buf, i) {
    var total = utf8CheckIncomplete(this, buf, i)
    if (!this.lastNeed) return buf.toString('utf8', i)
    this.lastTotal = total
    var end = buf.length - (total - this.lastNeed)
    buf.copy(this.lastChar, 0, end)
    return buf.toString('utf8', i, end)
  }

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
  function utf8End (buf) {
    var r = buf && buf.length ? this.write(buf) : ''
    if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed)
    return r
  }

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
  function utf16Text (buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString('utf16le', i)
      if (r) {
        var c = r.charCodeAt(r.length - 1)
        if (c >= 0xD800 && c <= 0xDBFF) {
          this.lastNeed = 2
          this.lastTotal = 4
          this.lastChar[0] = buf[buf.length - 2]
          this.lastChar[1] = buf[buf.length - 1]
          return r.slice(0, -1)
        }
      }
      return r
    }
    this.lastNeed = 1
    this.lastTotal = 2
    this.lastChar[0] = buf[buf.length - 1]
    return buf.toString('utf16le', i, buf.length - 1)
  }

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
  function utf16End (buf) {
    var r = buf && buf.length ? this.write(buf) : ''
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed
      return r + this.lastChar.toString('utf16le', 0, end)
    }
    return r
  }

  function base64Text (buf, i) {
    var n = (buf.length - i) % 3
    if (n === 0) return buf.toString('base64', i)
    this.lastNeed = 3 - n
    this.lastTotal = 3
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1]
    } else {
      this.lastChar[0] = buf[buf.length - 2]
      this.lastChar[1] = buf[buf.length - 1]
    }
    return buf.toString('base64', i, buf.length - n)
  }

  function base64End (buf) {
    var r = buf && buf.length ? this.write(buf) : ''
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed)
    return r
  }

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
  function simpleWrite (buf) {
    return buf.toString(this.encoding)
  }

  function simpleEnd (buf) {
    return buf && buf.length ? this.write(buf) : ''
  }
}, { 'safe-buffer': 98 }], 98: [function (require, module, exports) {
/* eslint-disable node/no-deprecated-api */
  var buffer = require('buffer')
  var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key]
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer
  } else {
  // Copy properties from require('buffer')
    copyProps(buffer, exports)
    exports.Buffer = SafeBuffer
  }

  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }

// Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer)

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  }

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size)
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding)
      } else {
        buf.fill(fill)
      }
    } else {
      buf.fill(0)
    }
    return buf
  }

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  }

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer.SlowBuffer(size)
  }
}, { 'buffer': 43 }], 99: [function (require, module, exports) {
  (function (global) {
/**
 * Module exports.
 */

    module.exports = deprecate

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

    function deprecate (fn, msg) {
      if (config('noDeprecation')) {
        return fn
      }

      var warned = false
      function deprecated () {
        if (!warned) {
          if (config('throwDeprecation')) {
            throw new Error(msg)
          } else if (config('traceDeprecation')) {
            console.trace(msg)
          } else {
            console.warn(msg)
          }
          warned = true
        }
        return fn.apply(this, arguments)
      }

      return deprecated
    }

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

    function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
      try {
        if (!global.localStorage) return false
      } catch (_) {
        return false
      }
      var val = global.localStorage[name]
      if (val == null) return false
      return String(val).toLowerCase() === 'true'
    }
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, {}], 100: [function (require, module, exports) {
  arguments[4][66][0].apply(exports, arguments)
}, { 'dup': 66 }], 101: [function (require, module, exports) {
  module.exports = function isBuffer (arg) {
    return arg && typeof arg === 'object' &&
    typeof arg.copy === 'function' &&
    typeof arg.fill === 'function' &&
    typeof arg.readUInt8 === 'function'
  }
}, {}], 102: [function (require, module, exports) {
  (function (process, global) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    var formatRegExp = /%[sdj%]/g
    exports.format = function (f) {
      if (!isString(f)) {
        var objects = []
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]))
        }
        return objects.join(' ')
      }

      var i = 1
      var args = arguments
      var len = args.length
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%'
        if (i >= len) return x
        switch (x) {
          case '%s': return String(args[i++])
          case '%d': return Number(args[i++])
          case '%j':
            try {
              return JSON.stringify(args[i++])
            } catch (_) {
              return '[Circular]'
            }
          default:
            return x
        }
      })
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x
        } else {
          str += ' ' + inspect(x)
        }
      }
      return str
    }

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
    exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
      if (isUndefined(global.process)) {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments)
        }
      }

      if (process.noDeprecation === true) {
        return fn
      }

      var warned = false
      function deprecated () {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg)
          } else if (process.traceDeprecation) {
            console.trace(msg)
          } else {
            console.error(msg)
          }
          warned = true
        }
        return fn.apply(this, arguments)
      }

      return deprecated
    }

    var debugs = {}
    var debugEnviron
    exports.debuglog = function (set) {
      if (isUndefined(debugEnviron)) { debugEnviron = process.env.NODE_DEBUG || '' }
      set = set.toUpperCase()
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid
          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments)
            console.error('%s %d: %s', set, pid, msg)
          }
        } else {
          debugs[set] = function () {}
        }
      }
      return debugs[set]
    }

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
    function inspect (obj, opts) {
  // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      }
  // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2]
      if (arguments.length >= 4) ctx.colors = arguments[3]
      if (isBoolean(opts)) {
    // legacy...
        ctx.showHidden = opts
      } else if (opts) {
    // got an "options" object
        exports._extend(ctx, opts)
      }
  // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false
      if (isUndefined(ctx.depth)) ctx.depth = 2
      if (isUndefined(ctx.colors)) ctx.colors = false
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true
      if (ctx.colors) ctx.stylize = stylizeWithColor
      return formatValue(ctx, obj, ctx.depth)
    }
    exports.inspect = inspect

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    }

// Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
  // "name": intentionally not styling
      'regexp': 'red'
    }

    function stylizeWithColor (str, styleType) {
      var style = inspect.styles[styleType]

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm'
      } else {
        return str
      }
    }

    function stylizeNoColor (str, styleType) {
      return str
    }

    function arrayToHash (array) {
      var hash = {}

      array.forEach(function (val, idx) {
        hash[val] = true
      })

      return hash
    }

    function formatValue (ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx)
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes)
        }
        return ret
      }

  // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value)
      if (primitive) {
        return primitive
      }

  // Look up the keys of the object.
      var keys = Object.keys(value)
      var visibleKeys = arrayToHash(keys)

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value)
      }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value) &&
      (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value)
      }

  // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : ''
          return ctx.stylize('[Function' + name + ']', 'special')
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp')
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date')
        }
        if (isError(value)) {
          return formatError(value)
        }
      }

      var base = '', array = false, braces = ['{', '}']

  // Make Array say that they are Array
      if (isArray(value)) {
        array = true
        braces = ['[', ']']
      }

  // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : ''
        base = ' [Function' + n + ']'
      }

  // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value)
      }

  // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value)
      }

  // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value)
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1]
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp')
        } else {
          return ctx.stylize('[Object]', 'special')
        }
      }

      ctx.seen.push(value)

      var output
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
        })
      }

      ctx.seen.pop()

      return reduceToSingleString(output, base, braces)
    }

    function formatPrimitive (ctx, value) {
      if (isUndefined(value)) { return ctx.stylize('undefined', 'undefined') }
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\''
        return ctx.stylize(simple, 'string')
      }
      if (isNumber(value)) { return ctx.stylize('' + value, 'number') }
      if (isBoolean(value)) { return ctx.stylize('' + value, 'boolean') }
  // For some reason typeof null is "object", so special case here.
      if (isNull(value)) { return ctx.stylize('null', 'null') }
    }

    function formatError (value) {
      return '[' + Error.prototype.toString.call(value) + ']'
    }

    function formatArray (ctx, value, recurseTimes, visibleKeys, keys) {
      var output = []
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true))
        } else {
          output.push('')
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true))
        }
      })
      return output
    }

    function formatProperty (ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special')
        } else {
          str = ctx.stylize('[Getter]', 'special')
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special')
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']'
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null)
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1)
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line
              }).join('\n').substr(2)
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line
              }).join('\n')
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special')
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str
        }
        name = JSON.stringify('' + key)
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2)
          name = ctx.stylize(name, 'name')
        } else {
          name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'")
          name = ctx.stylize(name, 'string')
        }
      }

      return name + ': ' + str
    }

    function reduceToSingleString (output, base, braces) {
      var numLinesEst = 0
      var length = output.reduce(function (prev, cur) {
        numLinesEst++
        if (cur.indexOf('\n') >= 0) numLinesEst++
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1
      }, 0)

      if (length > 60) {
        return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1]
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
    }

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
    function isArray (ar) {
      return Array.isArray(ar)
    }
    exports.isArray = isArray

    function isBoolean (arg) {
      return typeof arg === 'boolean'
    }
    exports.isBoolean = isBoolean

    function isNull (arg) {
      return arg === null
    }
    exports.isNull = isNull

    function isNullOrUndefined (arg) {
      return arg == null
    }
    exports.isNullOrUndefined = isNullOrUndefined

    function isNumber (arg) {
      return typeof arg === 'number'
    }
    exports.isNumber = isNumber

    function isString (arg) {
      return typeof arg === 'string'
    }
    exports.isString = isString

    function isSymbol (arg) {
      return typeof arg === 'symbol'
    }
    exports.isSymbol = isSymbol

    function isUndefined (arg) {
      return arg === void 0
    }
    exports.isUndefined = isUndefined

    function isRegExp (re) {
      return isObject(re) && objectToString(re) === '[object RegExp]'
    }
    exports.isRegExp = isRegExp

    function isObject (arg) {
      return typeof arg === 'object' && arg !== null
    }
    exports.isObject = isObject

    function isDate (d) {
      return isObject(d) && objectToString(d) === '[object Date]'
    }
    exports.isDate = isDate

    function isError (e) {
      return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error)
    }
    exports.isError = isError

    function isFunction (arg) {
      return typeof arg === 'function'
    }
    exports.isFunction = isFunction

    function isPrimitive (arg) {
      return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined'
    }
    exports.isPrimitive = isPrimitive

    exports.isBuffer = require('./support/isBuffer')

    function objectToString (o) {
      return Object.prototype.toString.call(o)
    }

    function pad (n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10)
    }

    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
      'Oct', 'Nov', 'Dec']

// 26 Feb 16:19:34
    function timestamp () {
      var d = new Date()
      var time = [pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())].join(':')
      return [d.getDate(), months[d.getMonth()], time].join(' ')
    }

// log is just a thin wrapper to console.log that prepends a timestamp
    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments))
    }

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
    exports.inherits = require('inherits')

    exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin

      var keys = Object.keys(add)
      var i = keys.length
      while (i--) {
        origin[keys[i]] = add[keys[i]]
      }
      return origin
    }

    function hasOwnProperty (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop)
    }
  }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})
}, { './support/isBuffer': 101, '_process': 82, 'inherits': 100 }] }, {}, [1])
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6), __webpack_require__(170).setImmediate))
  /** */ },
/* 179 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) {
      var transportList = __webpack_require__(442)

      module.exports = __webpack_require__(440)(transportList)

// TODO can't get rid of this until all servers do
      if ('_sockjs_onload' in global) {
        setTimeout(global._sockjs_onload, 1)
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 180 */
  /** */ function (module, exports, __webpack_require__) {
// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
    var content = __webpack_require__(416)
    if (typeof content === 'string') content = [[module.i, content, '']]
// Prepare cssTransformation
    var transform

    var options = {}
    options.transform = transform
// add the styles to the DOM
    var update = __webpack_require__(112)(content, options)
    if (content.locals) module.exports = content.locals
// Hot Module Replacement
    if (false) {
	// When the styles change, update the <style> tags
      if (!content.locals) {
        module.hot.accept('!!../css-loader/index.js!./mocha.css', function () {
          var newContent = require('!!../css-loader/index.js!./mocha.css')
          if (typeof newContent === 'string') newContent = [[module.id, newContent, '']]
          update(newContent)
        })
      }
	// When the module is disposed, remove the <style> tags
      module.hot.dispose(function () { update() })
    }
  /** */ },
/* 181 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    var punycode = __webpack_require__(427)
    var util = __webpack_require__(461)

    exports.parse = urlParse
    exports.resolve = urlResolve
    exports.resolveObject = urlResolveObject
    exports.format = urlFormat

    exports.Url = Url

    function Url () {
      this.protocol = null
      this.slashes = null
      this.auth = null
      this.host = null
      this.port = null
      this.hostname = null
      this.hash = null
      this.search = null
      this.query = null
      this.pathname = null
      this.path = null
      this.href = null
    }

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true
      },
    // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
    // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      },
      querystring = __webpack_require__(430)

    function urlParse (url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url

      var u = new Url()
      u.parse(url, parseQueryString, slashesDenoteHost)
      return u
    }

    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url)
      }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
        splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g
      uSplit[0] = uSplit[0].replace(slashRegex, '/')
      url = uSplit.join(splitter)

      var rest = url

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim()

      if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest)
        if (simplePath) {
          this.path = rest
          this.href = rest
          this.pathname = simplePath[1]
          if (simplePath[2]) {
            this.search = simplePath[2]
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1))
            } else {
              this.query = this.search.substr(1)
            }
          } else if (parseQueryString) {
            this.search = ''
            this.query = {}
          }
          return this
        }
      }

      var proto = protocolPattern.exec(rest)
      if (proto) {
        proto = proto[0]
        var lowerProto = proto.toLowerCase()
        this.protocol = lowerProto
        rest = rest.substr(proto.length)
      }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//'
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2)
          this.slashes = true
        }
      }

      if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
        var hostEnd = -1
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i])
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec }
        }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign
        if (hostEnd === -1) {
      // atSign can be anywhere.
          atSign = rest.lastIndexOf('@')
        } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd)
        }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign)
          rest = rest.slice(atSign + 1)
          this.auth = decodeURIComponent(auth)
        }

    // the host is the remaining to the left of the first non-host char
        hostEnd = -1
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i])
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec }
        }
    // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) { hostEnd = rest.length }

        this.host = rest.slice(0, hostEnd)
        rest = rest.slice(hostEnd)

    // pull out port.
        this.parseHost()

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
        this.hostname = this.hostname || ''

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']'

    // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./)
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i]
            if (!part) continue
            if (!part.match(hostnamePartPattern)) {
              var newpart = ''
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
                  newpart += 'x'
                } else {
                  newpart += part[j]
                }
              }
          // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i)
                var notHost = hostparts.slice(i + 1)
                var bit = part.match(hostnamePartStart)
                if (bit) {
                  validParts.push(bit[1])
                  notHost.unshift(bit[2])
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest
                }
                this.hostname = validParts.join('.')
                break
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = ''
        } else {
      // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase()
        }

        if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname)
        }

        var p = this.port ? ':' + this.port : ''
        var h = this.hostname || ''
        this.host = h + p
        this.href += this.host

    // strip [ and ] from the hostname
    // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2)
          if (rest[0] !== '/') {
            rest = '/' + rest
          }
        }
      }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i]
          if (rest.indexOf(ae) === -1) { continue }
          var esc = encodeURIComponent(ae)
          if (esc === ae) {
            esc = escape(ae)
          }
          rest = rest.split(ae).join(esc)
        }
      }

  // chop off from the tail first.
      var hash = rest.indexOf('#')
      if (hash !== -1) {
    // got a fragment string.
        this.hash = rest.substr(hash)
        rest = rest.slice(0, hash)
      }
      var qm = rest.indexOf('?')
      if (qm !== -1) {
        this.search = rest.substr(qm)
        this.query = rest.substr(qm + 1)
        if (parseQueryString) {
          this.query = querystring.parse(this.query)
        }
        rest = rest.slice(0, qm)
      } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
        this.search = ''
        this.query = {}
      }
      if (rest) this.pathname = rest
      if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
        this.pathname = '/'
      }

  // to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || ''
        var s = this.search || ''
        this.path = p + s
      }

  // finally, reconstruct the href based on what has been validated.
      this.href = this.format()
      return this
    }

// format a parsed object into a url string
    function urlFormat (obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
      if (util.isString(obj)) obj = urlParse(obj)
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj)
      return obj.format()
    }

    Url.prototype.format = function () {
      var auth = this.auth || ''
      if (auth) {
        auth = encodeURIComponent(auth)
        auth = auth.replace(/%3A/i, ':')
        auth += '@'
      }

      var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = ''

      if (this.host) {
        host = auth + this.host
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1
        ? this.hostname
        : '[' + this.hostname + ']')
        if (this.port) {
          host += ':' + this.port
        }
      }

      if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
        query = querystring.stringify(this.query)
      }

      var search = this.search || (query && ('?' + query)) || ''

      if (protocol && protocol.substr(-1) !== ':') protocol += ':'

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
      if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '')
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname
      } else if (!host) {
        host = ''
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash
      if (search && search.charAt(0) !== '?') search = '?' + search

      pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match)
      })
      search = search.replace('#', '%23')

      return protocol + host + pathname + search + hash
    }

    function urlResolve (source, relative) {
      return urlParse(source, false, true).resolve(relative)
    }

    Url.prototype.resolve = function (relative) {
      return this.resolveObject(urlParse(relative, false, true)).format()
    }

    function urlResolveObject (source, relative) {
      if (!source) return relative
      return urlParse(source, false, true).resolveObject(relative)
    }

    Url.prototype.resolveObject = function (relative) {
      if (util.isString(relative)) {
        var rel = new Url()
        rel.parse(relative, false, true)
        relative = rel
      }

      var result = new Url()
      var tkeys = Object.keys(this)
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk]
        result[tkey] = this[tkey]
      }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
      result.hash = relative.hash

  // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format()
        return result
      }

  // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
        var rkeys = Object.keys(relative)
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk]
          if (rkey !== 'protocol') { result[rkey] = relative[rkey] }
        }

    // urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
          result.path = result.pathname = '/'
        }

        result.href = result.format()
        return result
      }

      if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative)
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v]
            result[k] = relative[k]
          }
          result.href = result.format()
          return result
        }

        result.protocol = relative.protocol
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/')
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = ''
          if (!relative.hostname) relative.hostname = ''
          if (relPath[0] !== '') relPath.unshift('')
          if (relPath.length < 2) relPath.unshift('')
          result.pathname = relPath.join('/')
        } else {
          result.pathname = relative.pathname
        }
        result.search = relative.search
        result.query = relative.query
        result.host = relative.host || ''
        result.auth = relative.auth
        result.hostname = relative.hostname || relative.host
        result.port = relative.port
    // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || ''
          var s = result.search || ''
          result.path = p + s
        }
        result.slashes = result.slashes || relative.slashes
        result.href = result.format()
        return result
      }

      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
        isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
        mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol]

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = ''
        result.port = null
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host
          else srcPath.unshift(result.host)
        }
        result.host = ''
        if (relative.protocol) {
          relative.hostname = null
          relative.port = null
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host
            else relPath.unshift(relative.host)
          }
          relative.host = null
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '')
      }

      if (isRelAbs) {
    // it's absolute.
        result.host = (relative.host || relative.host === '')
                  ? relative.host : result.host
        result.hostname = (relative.hostname || relative.hostname === '')
                      ? relative.hostname : result.hostname
        result.search = relative.search
        result.query = relative.query
        srcPath = relPath
    // fall through to the dot-handling below.
      } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = []
        srcPath.pop()
        srcPath = srcPath.concat(relPath)
        result.search = relative.search
        result.query = relative.query
      } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift()
      // occationaly the auth can get stuck only in host
      // this especially happens in cases like
      // url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0
                       ? result.host.split('@') : false
          if (authInHost) {
            result.auth = authInHost.shift()
            result.host = result.hostname = authInHost.shift()
          }
        }
        result.search = relative.search
        result.query = relative.query
    // to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '')
        }
        result.href = result.format()
        return result
      }

      if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
        result.pathname = null
    // to support http.request
        if (result.search) {
          result.path = '/' + result.search
        } else {
          result.path = null
        }
        result.href = result.format()
        return result
      }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0]
      var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '')

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
      var up = 0
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i]
        if (last === '.') {
          srcPath.splice(i, 1)
        } else if (last === '..') {
          srcPath.splice(i, 1)
          up++
        } else if (up) {
          srcPath.splice(i, 1)
          up--
        }
      }

  // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..')
        }
      }

      if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('')
      }

      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('')
      }

      var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/')

  // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? ''
                                    : srcPath.length ? srcPath.shift() : ''
    // occationaly the auth can get stuck only in host
    // this especially happens in cases like
    // url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0
                     ? result.host.split('@') : false
        if (authInHost) {
          result.auth = authInHost.shift()
          result.host = result.hostname = authInHost.shift()
        }
      }

      mustEndAbs = mustEndAbs || (result.host && srcPath.length)

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('')
      }

      if (!srcPath.length) {
        result.pathname = null
        result.path = null
      } else {
        result.pathname = srcPath.join('/')
      }

  // to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '')
      }
      result.auth = relative.auth || result.auth
      result.slashes = result.slashes || relative.slashes
      result.href = result.format()
      return result
    }

    Url.prototype.parseHost = function () {
      var host = this.host
      var port = portPattern.exec(host)
      if (port) {
        port = port[0]
        if (port !== ':') {
          this.port = port.substr(1)
        }
        host = host.substr(0, host.length - port.length)
      }
      if (host) this.hostname = host
    }
  /** */ },
/* 182 */
  /** */ function (module, exports, __webpack_require__) {
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

    var hasDocument = typeof document !== 'undefined'

    if (typeof DEBUG !== 'undefined' && DEBUG) {
      if (!hasDocument) {
        throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  )
      }
    }

    var listToStyles = __webpack_require__(462)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

    var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
    */}

    var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
    var singletonElement = null
    var singletonCounter = 0
    var isProduction = false
    var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

    module.exports = function (parentId, list, _isProduction) {
      isProduction = _isProduction

      var styles = listToStyles(parentId, list)
      addStylesToDom(styles)

      return function update (newList) {
        var mayRemove = []
        for (var i = 0; i < styles.length; i++) {
          var item = styles[i]
          var domStyle = stylesInDom[item.id]
          domStyle.refs--
          mayRemove.push(domStyle)
        }
        if (newList) {
          styles = listToStyles(parentId, newList)
          addStylesToDom(styles)
        } else {
          styles = []
        }
        for (var i = 0; i < mayRemove.length; i++) {
          var domStyle = mayRemove[i]
          if (domStyle.refs === 0) {
            for (var j = 0; j < domStyle.parts.length; j++) {
              domStyle.parts[j]()
            }
            delete stylesInDom[domStyle.id]
          }
        }
      }
    }

    function addStylesToDom (styles /* Array<StyleObject> */) {
      for (var i = 0; i < styles.length; i++) {
        var item = styles[i]
        var domStyle = stylesInDom[item.id]
        if (domStyle) {
          domStyle.refs++
          for (var j = 0; j < domStyle.parts.length; j++) {
            domStyle.parts[j](item.parts[j])
          }
          for (; j < item.parts.length; j++) {
            domStyle.parts.push(addStyle(item.parts[j]))
          }
          if (domStyle.parts.length > item.parts.length) {
            domStyle.parts.length = item.parts.length
          }
        } else {
          var parts = []
          for (var j = 0; j < item.parts.length; j++) {
            parts.push(addStyle(item.parts[j]))
          }
          stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
        }
      }
    }

    function createStyleElement () {
      var styleElement = document.createElement('style')
      styleElement.type = 'text/css'
      head.appendChild(styleElement)
      return styleElement
    }

    function addStyle (obj /* StyleObjectPart */) {
      var update, remove
      var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

      if (styleElement) {
        if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
          return noop
        } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
          styleElement.parentNode.removeChild(styleElement)
        }
      }

      if (isOldIE) {
    // use singleton mode for IE9.
        var styleIndex = singletonCounter++
        styleElement = singletonElement || (singletonElement = createStyleElement())
        update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
        remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
      } else {
    // use multi-style-tag mode in all other cases
        styleElement = createStyleElement()
        update = applyToTag.bind(null, styleElement)
        remove = function () {
          styleElement.parentNode.removeChild(styleElement)
        }
      }

      update(obj)

      return function updateStyle (newObj /* StyleObjectPart */) {
        if (newObj) {
          if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
            return
          }
          update(obj = newObj)
        } else {
          remove()
        }
      }
    }

    var replaceText = (function () {
      var textStore = []

      return function (index, replacement) {
        textStore[index] = replacement
        return textStore.filter(Boolean).join('\n')
      }
    })()

    function applyToSingletonTag (styleElement, index, remove, obj) {
      var css = remove ? '' : obj.css

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = replaceText(index, css)
      } else {
        var cssNode = document.createTextNode(css)
        var childNodes = styleElement.childNodes
        if (childNodes[index]) styleElement.removeChild(childNodes[index])
        if (childNodes.length) {
          styleElement.insertBefore(cssNode, childNodes[index])
        } else {
          styleElement.appendChild(cssNode)
        }
      }
    }

    function applyToTag (styleElement, obj) {
      var css = obj.css
      var media = obj.media
      var sourceMap = obj.sourceMap

      if (media) {
        styleElement.setAttribute('media', media)
      }

      if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
        css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
        css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
      }

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = css
      } else {
        while (styleElement.firstChild) {
          styleElement.removeChild(styleElement.firstChild)
        }
        styleElement.appendChild(document.createTextNode(css))
      }
    }
  /** */ },
/* 183 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (global, setImmediate) { /*!
 * Vue.js v2.5.9
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
      (function (global, factory) {
	 true ? module.exports = factory()
	: typeof define === 'function' && define.amd ? define(factory)
	: (global.Vue = factory())
      }(this, function () {
        'use strict'

/*  */

        var emptyObject = Object.freeze({})

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
        function isUndef (v) {
          return v === undefined || v === null
        }

        function isDef (v) {
          return v !== undefined && v !== null
        }

        function isTrue (v) {
          return v === true
        }

        function isFalse (v) {
          return v === false
        }

/**
 * Check if value is primitive
 */
        function isPrimitive (value) {
          return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
          )
        }

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
        function isObject (obj) {
          return obj !== null && typeof obj === 'object'
        }

/**
 * Get the raw type string of a value e.g. [object Object]
 */
        var _toString = Object.prototype.toString

        function toRawType (value) {
          return _toString.call(value).slice(8, -1)
        }

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
        function isPlainObject (obj) {
          return _toString.call(obj) === '[object Object]'
        }

        function isRegExp (v) {
          return _toString.call(v) === '[object RegExp]'
        }

/**
 * Check if val is a valid array index.
 */
        function isValidArrayIndex (val) {
          var n = parseFloat(String(val))
          return n >= 0 && Math.floor(n) === n && isFinite(val)
        }

/**
 * Convert a value to a string that is actually rendered.
 */
        function toString (val) {
          return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
        }

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
        function toNumber (val) {
          var n = parseFloat(val)
          return isNaN(n) ? val : n
        }

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
        function makeMap (
  str,
  expectsLowerCase
) {
          var map = Object.create(null)
          var list = str.split(',')
          for (var i = 0; i < list.length; i++) {
            map[list[i]] = true
          }
          return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()] }
    : function (val) { return map[val] }
        }

/**
 * Check if a tag is a built-in tag.
 */
        var isBuiltInTag = makeMap('slot,component', true)

/**
 * Check if a attribute is a reserved attribute.
 */
        var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is')

/**
 * Remove an item from an array
 */
        function remove (arr, item) {
          if (arr.length) {
            var index = arr.indexOf(item)
            if (index > -1) {
              return arr.splice(index, 1)
            }
          }
        }

/**
 * Check whether the object has the property.
 */
        var hasOwnProperty = Object.prototype.hasOwnProperty
        function hasOwn (obj, key) {
          return hasOwnProperty.call(obj, key)
        }

/**
 * Create a cached version of a pure function.
 */
        function cached (fn) {
          var cache = Object.create(null)
          return function cachedFn (str) {
            var hit = cache[str]
            return hit || (cache[str] = fn(str))
          }
        }

/**
 * Camelize a hyphen-delimited string.
 */
        var camelizeRE = /-(\w)/g
        var camelize = cached(function (str) {
          return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : '' })
        })

/**
 * Capitalize a string.
 */
        var capitalize = cached(function (str) {
          return str.charAt(0).toUpperCase() + str.slice(1)
        })

/**
 * Hyphenate a camelCase string.
 */
        var hyphenateRE = /\B([A-Z])/g
        var hyphenate = cached(function (str) {
          return str.replace(hyphenateRE, '-$1').toLowerCase()
        })

/**
 * Simple bind, faster than native
 */
        function bind (fn, ctx) {
          function boundFn (a) {
            var l = arguments.length
            return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
          }
  // record original fn length
          boundFn._length = fn.length
          return boundFn
        }

/**
 * Convert an Array-like object to a real Array.
 */
        function toArray (list, start) {
          start = start || 0
          var i = list.length - start
          var ret = new Array(i)
          while (i--) {
            ret[i] = list[i + start]
          }
          return ret
        }

/**
 * Mix properties into target object.
 */
        function extend (to, _from) {
          for (var key in _from) {
            to[key] = _from[key]
          }
          return to
        }

/**
 * Merge an Array of Objects into a single Object.
 */
        function toObject (arr) {
          var res = {}
          for (var i = 0; i < arr.length; i++) {
            if (arr[i]) {
              extend(res, arr[i])
            }
          }
          return res
        }

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
        function noop (a, b, c) {}

/**
 * Always return false.
 */
        var no = function (a, b, c) { return false }

/**
 * Return same value
 */
        var identity = function (_) { return _ }

/**
 * Generate a static keys string from compiler modules.
 */
        function genStaticKeys (modules) {
          return modules.reduce(function (keys, m) {
            return keys.concat(m.staticKeys || [])
          }, []).join(',')
        }

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
        function looseEqual (a, b) {
          if (a === b) { return true }
          var isObjectA = isObject(a)
          var isObjectB = isObject(b)
          if (isObjectA && isObjectB) {
            try {
              var isArrayA = Array.isArray(a)
              var isArrayB = Array.isArray(b)
              if (isArrayA && isArrayB) {
                return a.length === b.length && a.every(function (e, i) {
                  return looseEqual(e, b[i])
                })
              } else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a)
                var keysB = Object.keys(b)
                return keysA.length === keysB.length && keysA.every(function (key) {
                  return looseEqual(a[key], b[key])
                })
              } else {
        /* istanbul ignore next */
                return false
              }
            } catch (e) {
      /* istanbul ignore next */
              return false
            }
          } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b)
          } else {
            return false
          }
        }

        function looseIndexOf (arr, val) {
          for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) { return i }
          }
          return -1
        }

/**
 * Ensure a function is called only once.
 */
        function once (fn) {
          var called = false
          return function () {
            if (!called) {
              called = true
              fn.apply(this, arguments)
            }
          }
        }

        var SSR_ATTR = 'data-server-rendered'

        var ASSET_TYPES = [
          'component',
          'directive',
          'filter'
        ]

        var LIFECYCLE_HOOKS = [
          'beforeCreate',
          'created',
          'beforeMount',
          'mounted',
          'beforeUpdate',
          'updated',
          'beforeDestroy',
          'destroyed',
          'activated',
          'deactivated',
          'errorCaptured'
        ]

/*  */

        var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
          optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
          silent: false,

  /**
   * Show production mode tip message on boot?
   */
          productionTip: 'development' !== 'production',

  /**
   * Whether to enable devtools
   */
          devtools: 'development' !== 'production',

  /**
   * Whether to record perf
   */
          performance: false,

  /**
   * Error handler for watcher errors
   */
          errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
          warnHandler: null,

  /**
   * Ignore certain custom elements
   */
          ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
          keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
          isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
          isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
          isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
          getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
          parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
          mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
          _lifecycleHooks: LIFECYCLE_HOOKS
        })

/*  */

/**
 * Check if a string starts with $ or _
 */
        function isReserved (str) {
          var c = (str + '').charCodeAt(0)
          return c === 0x24 || c === 0x5F
        }

/**
 * Define a property.
 */
        function def (obj, key, val, enumerable) {
          Object.defineProperty(obj, key, {
            value: val,
            enumerable: !!enumerable,
            writable: true,
            configurable: true
          })
        }

/**
 * Parse simple path.
 */
        var bailRE = /[^\w.$]/
        function parsePath (path) {
          if (bailRE.test(path)) {
            return
          }
          var segments = path.split('.')
          return function (obj) {
            for (var i = 0; i < segments.length; i++) {
              if (!obj) { return }
              obj = obj[segments[i]]
            }
            return obj
          }
        }

/*  */

// can we use __proto__?
        var hasProto = '__proto__' in {}

// Browser environment sniffing
        var inBrowser = typeof window !== 'undefined'
        var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase()
        var UA = inBrowser && window.navigator.userAgent.toLowerCase()
        var isIE = UA && /msie|trident/.test(UA)
        var isIE9 = UA && UA.indexOf('msie 9.0') > 0
        var isEdge = UA && UA.indexOf('edge/') > 0
        var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android')
        var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios')
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge

// Firefox has a "watch" function on Object.prototype...
        var nativeWatch = ({}).watch

        var supportsPassive = false
        if (inBrowser) {
          try {
            var opts = {}
            Object.defineProperty(opts, 'passive', ({
              get: function get () {
        /* istanbul ignore next */
                supportsPassive = true
              }
            })) // https://github.com/facebook/flow/issues/285
            window.addEventListener('test-passive', null, opts)
          } catch (e) {}
        }

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
        var _isServer
        var isServerRendering = function () {
          if (_isServer === undefined) {
    /* istanbul ignore if */
            if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
              _isServer = global['process'].env.VUE_ENV === 'server'
            } else {
              _isServer = false
            }
          }
          return _isServer
        }

// detect devtools
        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__

/* istanbul ignore next */
        function isNative (Ctor) {
          return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
        }

        var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys)

        var _Set
/* istanbul ignore if */ // $flow-disable-line
        if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
          _Set = Set
        } else {
  // a non-standard Set polyfill that only works with primitive keys.
          _Set = (function () {
            function Set () {
              this.set = Object.create(null)
            }
            Set.prototype.has = function has (key) {
              return this.set[key] === true
            }
            Set.prototype.add = function add (key) {
              this.set[key] = true
            }
            Set.prototype.clear = function clear () {
              this.set = Object.create(null)
            }

            return Set
          }())
        }

/*  */

        var warn = noop
        var tip = noop
        var generateComponentTrace = (noop) // work around flow check
        var formatComponentName = (noop)

        {
          var hasConsole = typeof console !== 'undefined'
          var classifyRE = /(?:^|[-_])(\w)/g
          var classify = function (str) {
            return str
    .replace(classifyRE, function (c) { return c.toUpperCase() })
    .replace(/[-_]/g, '')
          }

          warn = function (msg, vm) {
            var trace = vm ? generateComponentTrace(vm) : ''

            if (config.warnHandler) {
              config.warnHandler.call(null, msg, vm, trace)
            } else if (hasConsole && (!config.silent)) {
              console.error(('[Vue warn]: ' + msg + trace))
            }
          }

          tip = function (msg, vm) {
            if (hasConsole && (!config.silent)) {
              console.warn('[Vue tip]: ' + msg + (
        vm ? generateComponentTrace(vm) : ''
      ))
            }
          }

          formatComponentName = function (vm, includeFile) {
            if (vm.$root === vm) {
              return '<Root>'
            }
            var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {}
            var name = options.name || options._componentTag
            var file = options.__file
            if (!name && file) {
              var match = file.match(/([^/\\]+)\.vue$/)
              name = match && match[1]
            }

            return (
      (name ? ('<' + (classify(name)) + '>') : '<Anonymous>') +
      (file && includeFile !== false ? (' at ' + file) : '')
            )
          }

          var repeat = function (str, n) {
            var res = ''
            while (n) {
              if (n % 2 === 1) { res += str }
              if (n > 1) { str += str }
              n >>= 1
            }
            return res
          }

          generateComponentTrace = function (vm) {
            if (vm._isVue && vm.$parent) {
              var tree = []
              var currentRecursiveSequence = 0
              while (vm) {
                if (tree.length > 0) {
                  var last = tree[tree.length - 1]
                  if (last.constructor === vm.constructor) {
                    currentRecursiveSequence++
                    vm = vm.$parent
                    continue
                  } else if (currentRecursiveSequence > 0) {
                    tree[tree.length - 1] = [last, currentRecursiveSequence]
                    currentRecursiveSequence = 0
                  }
                }
                tree.push(vm)
                vm = vm.$parent
              }
              return '\n\nfound in\n\n' + tree
        .map(function (vm, i) {
          return ('' + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + '... (' + (vm[1]) + ' recursive calls)')
            : formatComponentName(vm)))
        })
        .join('\n')
            } else {
              return ('\n\n(found in ' + (formatComponentName(vm)) + ')')
            }
          }
        }

/*  */

        var uid = 0

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
        var Dep = function Dep () {
          this.id = uid++
          this.subs = []
        }

        Dep.prototype.addSub = function addSub (sub) {
          this.subs.push(sub)
        }

        Dep.prototype.removeSub = function removeSub (sub) {
          remove(this.subs, sub)
        }

        Dep.prototype.depend = function depend () {
          if (Dep.target) {
            Dep.target.addDep(this)
          }
        }

        Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
          var subs = this.subs.slice()
          for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update()
          }
        }

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
        Dep.target = null
        var targetStack = []

        function pushTarget (_target) {
          if (Dep.target) { targetStack.push(Dep.target) }
          Dep.target = _target
        }

        function popTarget () {
          Dep.target = targetStack.pop()
        }

/*  */

        var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
          this.tag = tag
          this.data = data
          this.children = children
          this.text = text
          this.elm = elm
          this.ns = undefined
          this.context = context
          this.fnContext = undefined
          this.fnOptions = undefined
          this.fnScopeId = undefined
          this.key = data && data.key
          this.componentOptions = componentOptions
          this.componentInstance = undefined
          this.parent = undefined
          this.raw = false
          this.isStatic = false
          this.isRootInsert = true
          this.isComment = false
          this.isCloned = false
          this.isOnce = false
          this.asyncFactory = asyncFactory
          this.asyncMeta = undefined
          this.isAsyncPlaceholder = false
        }

        var prototypeAccessors = { child: { configurable: true }}

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
        prototypeAccessors.child.get = function () {
          return this.componentInstance
        }

        Object.defineProperties(VNode.prototype, prototypeAccessors)

        var createEmptyVNode = function (text) {
          if (text === void 0) text = ''

          var node = new VNode()
          node.text = text
          node.isComment = true
          return node
        }

        function createTextVNode (val) {
          return new VNode(undefined, undefined, undefined, String(val))
        }

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
        function cloneVNode (vnode, deep) {
          var componentOptions = vnode.componentOptions
          var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    componentOptions,
    vnode.asyncFactory
  )
          cloned.ns = vnode.ns
          cloned.isStatic = vnode.isStatic
          cloned.key = vnode.key
          cloned.isComment = vnode.isComment
          cloned.fnContext = vnode.fnContext
          cloned.fnOptions = vnode.fnOptions
          cloned.fnScopeId = vnode.fnScopeId
          cloned.isCloned = true
          if (deep) {
            if (vnode.children) {
              cloned.children = cloneVNodes(vnode.children, true)
            }
            if (componentOptions && componentOptions.children) {
              componentOptions.children = cloneVNodes(componentOptions.children, true)
            }
          }
          return cloned
        }

        function cloneVNodes (vnodes, deep) {
          var len = vnodes.length
          var res = new Array(len)
          for (var i = 0; i < len; i++) {
            res[i] = cloneVNode(vnodes[i], deep)
          }
          return res
        }

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

        var arrayProto = Array.prototype
        var arrayMethods = Object.create(arrayProto); [
          'push',
          'pop',
          'shift',
          'unshift',
          'splice',
          'sort',
          'reverse'
        ]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length
    while (len--) args[ len ] = arguments[ len ]

    var result = original.apply(this, args)
    var ob = this.__ob__
    var inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) { ob.observeArray(inserted) }
    // notify change
    ob.dep.notify()
    return result
  })
})

/*  */

        var arrayKeys = Object.getOwnPropertyNames(arrayMethods)

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
        var observerState = {
          shouldConvert: true
        }

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
        var Observer = function Observer (value) {
          this.value = value
          this.dep = new Dep()
          this.vmCount = 0
          def(value, '__ob__', this)
          if (Array.isArray(value)) {
            var augment = hasProto
      ? protoAugment
      : copyAugment
            augment(value, arrayMethods, arrayKeys)
            this.observeArray(value)
          } else {
            this.walk(value)
          }
        }

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
        Observer.prototype.walk = function walk (obj) {
          var keys = Object.keys(obj)
          for (var i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]])
          }
        }

/**
 * Observe a list of Array items.
 */
        Observer.prototype.observeArray = function observeArray (items) {
          for (var i = 0, l = items.length; i < l; i++) {
            observe(items[i])
          }
        }

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
        function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
          target.__proto__ = src
  /* eslint-enable no-proto */
        }

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
        function copyAugment (target, src, keys) {
          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i]
            def(target, key, src[key])
          }
        }

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
        function observe (value, asRootData) {
          if (!isObject(value) || value instanceof VNode) {
            return
          }
          var ob
          if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
            ob = value.__ob__
          } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
            ob = new Observer(value)
          }
          if (asRootData && ob) {
            ob.vmCount++
          }
          return ob
        }

/**
 * Define a reactive property on an Object.
 */
        function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
          var dep = new Dep()

          var property = Object.getOwnPropertyDescriptor(obj, key)
          if (property && property.configurable === false) {
            return
          }

  // cater for pre-defined getter/setters
          var getter = property && property.get
          var setter = property && property.set

          var childOb = !shallow && observe(val)
          Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter () {
              var value = getter ? getter.call(obj) : val
              if (Dep.target) {
                dep.depend()
                if (childOb) {
                  childOb.dep.depend()
                  if (Array.isArray(value)) {
                    dependArray(value)
                  }
                }
              }
              return value
            },
            set: function reactiveSetter (newVal) {
              var value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
              if (newVal === value || (newVal !== newVal && value !== value)) {
                return
              }
      /* eslint-enable no-self-compare */
              if ('development' !== 'production' && customSetter) {
                customSetter()
              }
              if (setter) {
                setter.call(obj, newVal)
              } else {
                val = newVal
              }
              childOb = !shallow && observe(newVal)
              dep.notify()
            }
          })
        }

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
        function set (target, key, val) {
          if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.length = Math.max(target.length, key)
            target.splice(key, 1, val)
            return val
          }
          if (key in target && !(key in Object.prototype)) {
            target[key] = val
            return val
          }
          var ob = (target).__ob__
          if (target._isVue || (ob && ob.vmCount)) {
            'development' !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
            return val
          }
          if (!ob) {
            target[key] = val
            return val
          }
          defineReactive(ob.value, key, val)
          ob.dep.notify()
          return val
        }

/**
 * Delete a property and trigger change if necessary.
 */
        function del (target, key) {
          if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.splice(key, 1)
            return
          }
          var ob = (target).__ob__
          if (target._isVue || (ob && ob.vmCount)) {
            'development' !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
            return
          }
          if (!hasOwn(target, key)) {
            return
          }
          delete target[key]
          if (!ob) {
            return
          }
          ob.dep.notify()
        }

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
        function dependArray (value) {
          for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
            e = value[i]
            e && e.__ob__ && e.__ob__.dep.depend()
            if (Array.isArray(e)) {
              dependArray(e)
            }
          }
        }

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
        var strats = config.optionMergeStrategies

/**
 * Options with restrictions
 */
        {
          strats.el = strats.propsData = function (parent, child, vm, key) {
            if (!vm) {
              warn(
        'option "' + key + '" can only be used during instance ' +
        'creation with the `new` keyword.'
      )
            }
            return defaultStrat(parent, child)
          }
        }

/**
 * Helper that recursively merges two data objects together.
 */
        function mergeData (to, from) {
          if (!from) { return to }
          var key, toVal, fromVal
          var keys = Object.keys(from)
          for (var i = 0; i < keys.length; i++) {
            key = keys[i]
            toVal = to[key]
            fromVal = from[key]
            if (!hasOwn(to, key)) {
              set(to, key, fromVal)
            } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
              mergeData(toVal, fromVal)
            }
          }
          return to
        }

/**
 * Data
 */
        function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
          if (!vm) {
    // in a Vue.extend merge, both should be functions
            if (!childVal) {
              return parentVal
            }
            if (!parentVal) {
              return childVal
            }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
            return function mergedDataFn () {
              return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this) : parentVal
      )
            }
          } else {
            return function mergedInstanceDataFn () {
      // instance merge
              var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal
              var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : parentVal
              if (instanceData) {
                return mergeData(instanceData, defaultData)
              } else {
                return defaultData
              }
            }
          }
        }

        strats.data = function (
  parentVal,
  childVal,
  vm
) {
          if (!vm) {
            if (childVal && typeof childVal !== 'function') {
              'development' !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      )

              return parentVal
            }
            return mergeDataOrFn(parentVal, childVal)
          }

          return mergeDataOrFn(parentVal, childVal, vm)
        }

/**
 * Hooks and props are merged as arrays.
 */
        function mergeHook (
  parentVal,
  childVal
) {
          return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
        }

        LIFECYCLE_HOOKS.forEach(function (hook) {
          strats[hook] = mergeHook
        })

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
        function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
          var res = Object.create(parentVal || null)
          if (childVal) {
            'development' !== 'production' && assertObjectType(key, childVal, vm)
            return extend(res, childVal)
          } else {
            return res
          }
        }

        ASSET_TYPES.forEach(function (type) {
          strats[type + 's'] = mergeAssets
        })

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
        strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
          if (parentVal === nativeWatch) { parentVal = undefined }
          if (childVal === nativeWatch) { childVal = undefined }
  /* istanbul ignore if */
          if (!childVal) { return Object.create(parentVal || null) }
          {
            assertObjectType(key, childVal, vm)
          }
          if (!parentVal) { return childVal }
          var ret = {}
          extend(ret, parentVal)
          for (var key$1 in childVal) {
            var parent = ret[key$1]
            var child = childVal[key$1]
            if (parent && !Array.isArray(parent)) {
              parent = [parent]
            }
            ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child]
          }
          return ret
        }

/**
 * Other object hashes.
 */
        strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && 'development' !== 'production') {
    assertObjectType(key, childVal, vm)
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null)
  extend(ret, parentVal)
  if (childVal) { extend(ret, childVal) }
  return ret
}
        strats.provide = mergeDataOrFn

/**
 * Default strategy.
 */
        var defaultStrat = function (parentVal, childVal) {
          return childVal === undefined
    ? parentVal
    : childVal
        }

/**
 * Validate component names
 */
        function checkComponents (options) {
          for (var key in options.components) {
            var lower = key.toLowerCase()
            if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
              warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + key
      )
            }
          }
        }

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
        function normalizeProps (options, vm) {
          var props = options.props
          if (!props) { return }
          var res = {}
          var i, val, name
          if (Array.isArray(props)) {
            i = props.length
            while (i--) {
              val = props[i]
              if (typeof val === 'string') {
                name = camelize(val)
                res[name] = { type: null }
              } else {
                warn('props must be strings when using array syntax.')
              }
            }
          } else if (isPlainObject(props)) {
            for (var key in props) {
              val = props[key]
              name = camelize(key)
              res[name] = isPlainObject(val)
        ? val
        : { type: val }
            }
          } else {
            warn(
      'Invalid value for option "props": expected an Array or an Object, ' +
      'but got ' + (toRawType(props)) + '.',
      vm
    )
          }
          options.props = res
        }

/**
 * Normalize all injections into Object-based format
 */
        function normalizeInject (options, vm) {
          var inject = options.inject
          var normalized = options.inject = {}
          if (Array.isArray(inject)) {
            for (var i = 0; i < inject.length; i++) {
              normalized[inject[i]] = { from: inject[i] }
            }
          } else if (isPlainObject(inject)) {
            for (var key in inject) {
              var val = inject[key]
              normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val }
            }
          } else if ('development' !== 'production' && inject) {
            warn(
      'Invalid value for option "inject": expected an Array or an Object, ' +
      'but got ' + (toRawType(inject)) + '.',
      vm
    )
          }
        }

/**
 * Normalize raw function directives into object format.
 */
        function normalizeDirectives (options) {
          var dirs = options.directives
          if (dirs) {
            for (var key in dirs) {
              var def = dirs[key]
              if (typeof def === 'function') {
                dirs[key] = { bind: def, update: def }
              }
            }
          }
        }

        function assertObjectType (name, value, vm) {
          if (!isPlainObject(value)) {
            warn(
      'Invalid value for option "' + name + '": expected an Object, ' +
      'but got ' + (toRawType(value)) + '.',
      vm
    )
          }
        }

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
        function mergeOptions (
  parent,
  child,
  vm
) {
          {
            checkComponents(child)
          }

          if (typeof child === 'function') {
            child = child.options
          }

          normalizeProps(child, vm)
          normalizeInject(child, vm)
          normalizeDirectives(child)
          var extendsFrom = child.extends
          if (extendsFrom) {
            parent = mergeOptions(parent, extendsFrom, vm)
          }
          if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
              parent = mergeOptions(parent, child.mixins[i], vm)
            }
          }
          var options = {}
          var key
          for (key in parent) {
            mergeField(key)
          }
          for (key in child) {
            if (!hasOwn(parent, key)) {
              mergeField(key)
            }
          }
          function mergeField (key) {
            var strat = strats[key] || defaultStrat
            options[key] = strat(parent[key], child[key], vm, key)
          }
          return options
        }

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
        function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
          if (typeof id !== 'string') {
            return
          }
          var assets = options[type]
  // check local registration variations first
          if (hasOwn(assets, id)) { return assets[id] }
          var camelizedId = camelize(id)
          if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
          var PascalCaseId = capitalize(camelizedId)
          if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
          var res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
          if ('development' !== 'production' && warnMissing && !res) {
            warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
          }
          return res
        }

/*  */

        function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
          var prop = propOptions[key]
          var absent = !hasOwn(propsData, key)
          var value = propsData[key]
  // handle boolean props
          if (isType(Boolean, prop.type)) {
            if (absent && !hasOwn(prop, 'default')) {
              value = false
            } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
              value = true
            }
          }
  // check default value
          if (value === undefined) {
            value = getPropDefaultValue(vm, prop, key)
    // since the default value is a fresh copy,
    // make sure to observe it.
            var prevShouldConvert = observerState.shouldConvert
            observerState.shouldConvert = true
            observe(value)
            observerState.shouldConvert = prevShouldConvert
          }
          {
            assertProp(prop, key, value, vm, absent)
          }
          return value
        }

/**
 * Get the default value of a prop.
 */
        function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
          if (!hasOwn(prop, 'default')) {
            return undefined
          }
          var def = prop.default
  // warn against non-factory defaults for Object & Array
          if ('development' !== 'production' && isObject(def)) {
            warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    )
          }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
          if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
            return vm._props[key]
          }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
          return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
        }

/**
 * Assert whether a prop is valid.
 */
        function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
          if (prop.required && absent) {
            warn(
      'Missing required prop: "' + name + '"',
      vm
    )
            return
          }
          if (value == null && !prop.required) {
            return
          }
          var type = prop.type
          var valid = !type || type === true
          var expectedTypes = []
          if (type) {
            if (!Array.isArray(type)) {
              type = [type]
            }
            for (var i = 0; i < type.length && !valid; i++) {
              var assertedType = assertType(value, type[i])
              expectedTypes.push(assertedType.expectedType || '')
              valid = assertedType.valid
            }
          }
          if (!valid) {
            warn(
      'Invalid prop: type check failed for prop "' + name + '".' +
      ' Expected ' + (expectedTypes.map(capitalize).join(', ')) +
      ', got ' + (toRawType(value)) + '.',
      vm
    )
            return
          }
          var validator = prop.validator
          if (validator) {
            if (!validator(value)) {
              warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      )
            }
          }
        }

        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/

        function assertType (value, type) {
          var valid
          var expectedType = getType(type)
          if (simpleCheckRE.test(expectedType)) {
            var t = typeof value
            valid = t === expectedType.toLowerCase()
    // for primitive wrapper objects
            if (!valid && t === 'object') {
              valid = value instanceof type
            }
          } else if (expectedType === 'Object') {
            valid = isPlainObject(value)
          } else if (expectedType === 'Array') {
            valid = Array.isArray(value)
          } else {
            valid = value instanceof type
          }
          return {
            valid: valid,
            expectedType: expectedType
          }
        }

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
        function getType (fn) {
          var match = fn && fn.toString().match(/^\s*function (\w+)/)
          return match ? match[1] : ''
        }

        function isType (type, fn) {
          if (!Array.isArray(fn)) {
            return getType(fn) === getType(type)
          }
          for (var i = 0, len = fn.length; i < len; i++) {
            if (getType(fn[i]) === getType(type)) {
              return true
            }
          }
  /* istanbul ignore next */
          return false
        }

/*  */

        function handleError (err, vm, info) {
          if (vm) {
            var cur = vm
            while ((cur = cur.$parent)) {
              var hooks = cur.$options.errorCaptured
              if (hooks) {
                for (var i = 0; i < hooks.length; i++) {
                  try {
                    var capture = hooks[i].call(cur, err, vm, info) === false
                    if (capture) { return }
                  } catch (e) {
                    globalHandleError(e, cur, 'errorCaptured hook')
                  }
                }
              }
            }
          }
          globalHandleError(err, vm, info)
        }

        function globalHandleError (err, vm, info) {
          if (config.errorHandler) {
            try {
              return config.errorHandler.call(null, err, vm, info)
            } catch (e) {
              logError(e, null, 'config.errorHandler')
            }
          }
          logError(err, vm, info)
        }

        function logError (err, vm, info) {
          {
            warn(('Error in ' + info + ': "' + (err.toString()) + '"'), vm)
          }
  /* istanbul ignore else */
          if ((inBrowser || inWeex) && typeof console !== 'undefined') {
            console.error(err)
          } else {
            throw err
          }
        }

/*  */
/* globals MessageChannel */

        var callbacks = []
        var pending = false

        function flushCallbacks () {
          pending = false
          var copies = callbacks.slice(0)
          callbacks.length = 0
          for (var i = 0; i < copies.length; i++) {
            copies[i]()
          }
        }

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
        var microTimerFunc
        var macroTimerFunc
        var useMacroTask = false

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
        if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
          macroTimerFunc = function () {
            setImmediate(flushCallbacks)
          }
        } else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
          var channel = new MessageChannel()
          var port = channel.port2
          channel.port1.onmessage = flushCallbacks
          macroTimerFunc = function () {
            port.postMessage(1)
          }
        } else {
  /* istanbul ignore next */
          macroTimerFunc = function () {
            setTimeout(flushCallbacks, 0)
          }
        }

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
        if (typeof Promise !== 'undefined' && isNative(Promise)) {
          var p = Promise.resolve()
          microTimerFunc = function () {
            p.then(flushCallbacks)
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
            if (isIOS) { setTimeout(noop) }
          }
        } else {
  // fallback to macro
          microTimerFunc = macroTimerFunc
        }

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
        function withMacroTask (fn) {
          return fn._withTask || (fn._withTask = function () {
            useMacroTask = true
            var res = fn.apply(null, arguments)
            useMacroTask = false
            return res
          })
        }

        function nextTick (cb, ctx) {
          var _resolve
          callbacks.push(function () {
            if (cb) {
              try {
                cb.call(ctx)
              } catch (e) {
                handleError(e, ctx, 'nextTick')
              }
            } else if (_resolve) {
              _resolve(ctx)
            }
          })
          if (!pending) {
            pending = true
            if (useMacroTask) {
              macroTimerFunc()
            } else {
              microTimerFunc()
            }
          }
  // $flow-disable-line
          if (!cb && typeof Promise !== 'undefined') {
            return new Promise(function (resolve) {
              _resolve = resolve
            })
          }
        }

/*  */

        var mark
        var measure

        {
          var perf = inBrowser && window.performance
  /* istanbul ignore if */
          if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
            mark = function (tag) { return perf.mark(tag) }
            measure = function (name, startTag, endTag) {
              perf.measure(name, startTag, endTag)
              perf.clearMarks(startTag)
              perf.clearMarks(endTag)
              perf.clearMeasures(name)
            }
          }
        }

/* not type checking this file because flow doesn't play well with Proxy */

        var initProxy

        {
          var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  )

          var warnNonPresent = function (target, key) {
            warn(
      'Property or method "' + key + '" is not defined on the instance but ' +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    )
          }

          var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/)

          if (hasProxy) {
            var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact')
            config.keyCodes = new Proxy(config.keyCodes, {
              set: function set (target, key, value) {
                if (isBuiltInModifier(key)) {
                  warn(('Avoid overwriting built-in modifier in config.keyCodes: .' + key))
                  return false
                } else {
                  target[key] = value
                  return true
                }
              }
            })
          }

          var hasHandler = {
            has: function has (target, key) {
              var has = key in target
              var isAllowed = allowedGlobals(key) || key.charAt(0) === '_'
              if (!has && !isAllowed) {
                warnNonPresent(target, key)
              }
              return has || !isAllowed
            }
          }

          var getHandler = {
            get: function get (target, key) {
              if (typeof key === 'string' && !(key in target)) {
                warnNonPresent(target, key)
              }
              return target[key]
            }
          }

          initProxy = function initProxy (vm) {
            if (hasProxy) {
      // determine which proxy handler to use
              var options = vm.$options
              var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler
              vm._renderProxy = new Proxy(vm, handlers)
            } else {
              vm._renderProxy = vm
            }
          }
        }

/*  */

        var seenObjects = new _Set()

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
        function traverse (val) {
          _traverse(val, seenObjects)
          seenObjects.clear()
        }

        function _traverse (val, seen) {
          var i, keys
          var isA = Array.isArray(val)
          if ((!isA && !isObject(val)) || Object.isFrozen(val)) {
            return
          }
          if (val.__ob__) {
            var depId = val.__ob__.dep.id
            if (seen.has(depId)) {
              return
            }
            seen.add(depId)
          }
          if (isA) {
            i = val.length
            while (i--) { _traverse(val[i], seen) }
          } else {
            keys = Object.keys(val)
            i = keys.length
            while (i--) { _traverse(val[keys[i]], seen) }
          }
        }

/*  */

        var normalizeEvent = cached(function (name) {
          var passive = name.charAt(0) === '&'
          name = passive ? name.slice(1) : name
          var once$$1 = name.charAt(0) === '~' // Prefixed last, checked first
          name = once$$1 ? name.slice(1) : name
          var capture = name.charAt(0) === '!'
          name = capture ? name.slice(1) : name
          return {
            name: name,
            once: once$$1,
            capture: capture,
            passive: passive
          }
        })

        function createFnInvoker (fns) {
          function invoker () {
            var arguments$1 = arguments

            var fns = invoker.fns
            if (Array.isArray(fns)) {
              var cloned = fns.slice()
              for (var i = 0; i < cloned.length; i++) {
                cloned[i].apply(null, arguments$1)
              }
            } else {
      // return handler return value for single handlers
              return fns.apply(null, arguments)
            }
          }
          invoker.fns = fns
          return invoker
        }

        function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
          var name, cur, old, event
          for (name in on) {
            cur = on[name]
            old = oldOn[name]
            event = normalizeEvent(name)
            if (isUndef(cur)) {
              'development' !== 'production' && warn(
        'Invalid handler for event "' + (event.name) + '": got ' + String(cur),
        vm
      )
            } else if (isUndef(old)) {
              if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur)
              }
              add(event.name, cur, event.once, event.capture, event.passive)
            } else if (cur !== old) {
              old.fns = cur
              on[name] = old
            }
          }
          for (name in oldOn) {
            if (isUndef(on[name])) {
              event = normalizeEvent(name)
              remove$$1(event.name, oldOn[name], event.capture)
            }
          }
        }

/*  */

        function mergeVNodeHook (def, hookKey, hook) {
          if (def instanceof VNode) {
            def = def.data.hook || (def.data.hook = {})
          }
          var invoker
          var oldHook = def[hookKey]

          function wrappedHook () {
            hook.apply(this, arguments)
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
            remove(invoker.fns, wrappedHook)
          }

          if (isUndef(oldHook)) {
    // no existing hook
            invoker = createFnInvoker([wrappedHook])
          } else {
    /* istanbul ignore if */
            if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
              invoker = oldHook
              invoker.fns.push(wrappedHook)
            } else {
      // existing plain hook
              invoker = createFnInvoker([oldHook, wrappedHook])
            }
          }

          invoker.merged = true
          def[hookKey] = invoker
        }

/*  */

        function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
          var propOptions = Ctor.options.props
          if (isUndef(propOptions)) {
            return
          }
          var res = {}
          var attrs = data.attrs
          var props = data.props
          if (isDef(attrs) || isDef(props)) {
            for (var key in propOptions) {
              var altKey = hyphenate(key)
              {
                var keyInLowerCase = key.toLowerCase()
                if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
                  tip(
            'Prop "' + keyInLowerCase + '" is passed to component ' +
            (formatComponentName(tag || Ctor)) + ', but the declared prop name is' +
            ' "' + key + '". ' +
            'Note that HTML attributes are case-insensitive and camelCased ' +
            'props need to use their kebab-case equivalents when using in-DOM ' +
            'templates. You should probably use "' + altKey + '" instead of "' + key + '".'
          )
                }
              }
              checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false)
            }
          }
          return res
        }

        function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
          if (isDef(hash)) {
            if (hasOwn(hash, key)) {
              res[key] = hash[key]
              if (!preserve) {
                delete hash[key]
              }
              return true
            } else if (hasOwn(hash, altKey)) {
              res[key] = hash[altKey]
              if (!preserve) {
                delete hash[altKey]
              }
              return true
            }
          }
          return false
        }

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
        function simpleNormalizeChildren (children) {
          for (var i = 0; i < children.length; i++) {
            if (Array.isArray(children[i])) {
              return Array.prototype.concat.apply([], children)
            }
          }
          return children
        }

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
        function normalizeChildren (children) {
          return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
        }

        function isTextNode (node) {
          return isDef(node) && isDef(node.text) && isFalse(node.isComment)
        }

        function normalizeArrayChildren (children, nestedIndex) {
          var res = []
          var i, c, lastIndex, last
          for (i = 0; i < children.length; i++) {
            c = children[i]
            if (isUndef(c) || typeof c === 'boolean') { continue }
            lastIndex = res.length - 1
            last = res[lastIndex]
    //  nested
            if (Array.isArray(c)) {
              if (c.length > 0) {
                c = normalizeArrayChildren(c, ((nestedIndex || '') + '_' + i))
        // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                  res[lastIndex] = createTextVNode(last.text + (c[0]).text)
                  c.shift()
                }
                res.push.apply(res, c)
              }
            } else if (isPrimitive(c)) {
              if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c)
              } else if (c !== '') {
        // convert primitive to vnode
                res.push(createTextVNode(c))
              }
            } else {
              if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text)
              } else {
        // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
                  c.key = '__vlist' + nestedIndex + '_' + i + '__'
                }
                res.push(c)
              }
            }
          }
          return res
        }

/*  */

        function ensureCtor (comp, base) {
          if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
            comp = comp.default
          }
          return isObject(comp)
    ? base.extend(comp)
    : comp
        }

        function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
          var node = createEmptyVNode()
          node.asyncFactory = factory
          node.asyncMeta = { data: data, context: context, children: children, tag: tag }
          return node
        }

        function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
          if (isTrue(factory.error) && isDef(factory.errorComp)) {
            return factory.errorComp
          }

          if (isDef(factory.resolved)) {
            return factory.resolved
          }

          if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
            return factory.loadingComp
          }

          if (isDef(factory.contexts)) {
    // already pending
            factory.contexts.push(context)
          } else {
            var contexts = factory.contexts = [context]
            var sync = true

            var forceRender = function () {
              for (var i = 0, l = contexts.length; i < l; i++) {
                contexts[i].$forceUpdate()
              }
            }

            var resolve = once(function (res) {
      // cache resolved
              factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
              if (!sync) {
                forceRender()
              }
            })

            var reject = once(function (reason) {
              'development' !== 'production' && warn(
        'Failed to resolve async component: ' + (String(factory)) +
        (reason ? ('\nReason: ' + reason) : '')
      )
              if (isDef(factory.errorComp)) {
                factory.error = true
                forceRender()
              }
            })

            var res = factory(resolve, reject)

            if (isObject(res)) {
              if (typeof res.then === 'function') {
        // () => Promise
                if (isUndef(factory.resolved)) {
                  res.then(resolve, reject)
                }
              } else if (isDef(res.component) && typeof res.component.then === 'function') {
                res.component.then(resolve, reject)

                if (isDef(res.error)) {
                  factory.errorComp = ensureCtor(res.error, baseCtor)
                }

                if (isDef(res.loading)) {
                  factory.loadingComp = ensureCtor(res.loading, baseCtor)
                  if (res.delay === 0) {
                    factory.loading = true
                  } else {
                    setTimeout(function () {
                      if (isUndef(factory.resolved) && isUndef(factory.error)) {
                        factory.loading = true
                        forceRender()
                      }
                    }, res.delay || 200)
                  }
                }

                if (isDef(res.timeout)) {
                  setTimeout(function () {
                    if (isUndef(factory.resolved)) {
                      reject(
                'timeout (' + (res.timeout) + 'ms)'
              )
                    }
                  }, res.timeout)
                }
              }
            }

            sync = false
    // return in case resolved synchronously
            return factory.loading
      ? factory.loadingComp
      : factory.resolved
          }
        }

/*  */

        function isAsyncPlaceholder (node) {
          return node.isComment && node.asyncFactory
        }

/*  */

        function getFirstComponentChild (children) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              var c = children[i]
              if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c
              }
            }
          }
        }

/*  */

/*  */

        function initEvents (vm) {
          vm._events = Object.create(null)
          vm._hasHookEvent = false
  // init parent attached events
          var listeners = vm.$options._parentListeners
          if (listeners) {
            updateComponentListeners(vm, listeners)
          }
        }

        var target

        function add (event, fn, once) {
          if (once) {
            target.$once(event, fn)
          } else {
            target.$on(event, fn)
          }
        }

        function remove$1 (event, fn) {
          target.$off(event, fn)
        }

        function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
          target = vm
          updateListeners(listeners, oldListeners || {}, add, remove$1, vm)
          target = undefined
        }

        function eventsMixin (Vue) {
          var hookRE = /^hook:/
          Vue.prototype.$on = function (event, fn) {
            var this$1 = this

            var vm = this
            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                this$1.$on(event[i], fn)
              }
            } else {
              (vm._events[event] || (vm._events[event] = [])).push(fn)
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
              if (hookRE.test(event)) {
                vm._hasHookEvent = true
              }
            }
            return vm
          }

          Vue.prototype.$once = function (event, fn) {
            var vm = this
            function on () {
              vm.$off(event, on)
              fn.apply(vm, arguments)
            }
            on.fn = fn
            vm.$on(event, on)
            return vm
          }

          Vue.prototype.$off = function (event, fn) {
            var this$1 = this

            var vm = this
    // all
            if (!arguments.length) {
              vm._events = Object.create(null)
              return vm
            }
    // array of events
            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                this$1.$off(event[i], fn)
              }
              return vm
            }
    // specific event
            var cbs = vm._events[event]
            if (!cbs) {
              return vm
            }
            if (!fn) {
              vm._events[event] = null
              return vm
            }
            if (fn) {
      // specific handler
              var cb
              var i$1 = cbs.length
              while (i$1--) {
                cb = cbs[i$1]
                if (cb === fn || cb.fn === fn) {
                  cbs.splice(i$1, 1)
                  break
                }
              }
            }
            return vm
          }

          Vue.prototype.$emit = function (event) {
            var vm = this
            {
              var lowerCaseEvent = event.toLowerCase()
              if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip(
          'Event "' + lowerCaseEvent + '" is emitted in component ' +
          (formatComponentName(vm)) + ' but the handler is registered for "' + event + '". ' +
          'Note that HTML attributes are case-insensitive and you cannot use ' +
          'v-on to listen to camelCase events when using in-DOM templates. ' +
          'You should probably use "' + (hyphenate(event)) + '" instead of "' + event + '".'
        )
              }
            }
            var cbs = vm._events[event]
            if (cbs) {
              cbs = cbs.length > 1 ? toArray(cbs) : cbs
              var args = toArray(arguments, 1)
              for (var i = 0, l = cbs.length; i < l; i++) {
                try {
                  cbs[i].apply(vm, args)
                } catch (e) {
                  handleError(e, vm, ('event handler for "' + event + '"'))
                }
              }
            }
            return vm
          }
        }

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
        function resolveSlots (
  children,
  context
) {
          var slots = {}
          if (!children) {
            return slots
          }
          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i]
            var data = child.data
    // remove slot attribute if the node is resolved as a Vue slot node
            if (data && data.attrs && data.attrs.slot) {
              delete data.attrs.slot
            }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
            if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
              var name = child.data.slot
              var slot = (slots[name] || (slots[name] = []))
              if (child.tag === 'template') {
                slot.push.apply(slot, child.children)
              } else {
                slot.push(child)
              }
            } else {
              (slots.default || (slots.default = [])).push(child)
            }
          }
  // ignore slots that contains only whitespace
          for (var name$1 in slots) {
            if (slots[name$1].every(isWhitespace)) {
              delete slots[name$1]
            }
          }
          return slots
        }

        function isWhitespace (node) {
          return (node.isComment && !node.asyncFactory) || node.text === ' '
        }

        function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
          res = res || {}
          for (var i = 0; i < fns.length; i++) {
            if (Array.isArray(fns[i])) {
              resolveScopedSlots(fns[i], res)
            } else {
              res[fns[i].key] = fns[i].fn
            }
          }
          return res
        }

/*  */

        var activeInstance = null
        var isUpdatingChildComponent = false

        function initLifecycle (vm) {
          var options = vm.$options

  // locate first non-abstract parent
          var parent = options.parent
          if (parent && !options.abstract) {
            while (parent.$options.abstract && parent.$parent) {
              parent = parent.$parent
            }
            parent.$children.push(vm)
          }

          vm.$parent = parent
          vm.$root = parent ? parent.$root : vm

          vm.$children = []
          vm.$refs = {}

          vm._watcher = null
          vm._inactive = null
          vm._directInactive = false
          vm._isMounted = false
          vm._isDestroyed = false
          vm._isBeingDestroyed = false
        }

        function lifecycleMixin (Vue) {
          Vue.prototype._update = function (vnode, hydrating) {
            var vm = this
            if (vm._isMounted) {
              callHook(vm, 'beforeUpdate')
            }
            var prevEl = vm.$el
            var prevVnode = vm._vnode
            var prevActiveInstance = activeInstance
            activeInstance = vm
            vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
            if (!prevVnode) {
      // initial render
              vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      )
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
              vm.$options._parentElm = vm.$options._refElm = null
            } else {
      // updates
              vm.$el = vm.__patch__(prevVnode, vnode)
            }
            activeInstance = prevActiveInstance
    // update __vue__ reference
            if (prevEl) {
              prevEl.__vue__ = null
            }
            if (vm.$el) {
              vm.$el.__vue__ = vm
            }
    // if parent is an HOC, update its $el as well
            if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
              vm.$parent.$el = vm.$el
            }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
          }

          Vue.prototype.$forceUpdate = function () {
            var vm = this
            if (vm._watcher) {
              vm._watcher.update()
            }
          }

          Vue.prototype.$destroy = function () {
            var vm = this
            if (vm._isBeingDestroyed) {
              return
            }
            callHook(vm, 'beforeDestroy')
            vm._isBeingDestroyed = true
    // remove self from parent
            var parent = vm.$parent
            if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
              remove(parent.$children, vm)
            }
    // teardown watchers
            if (vm._watcher) {
              vm._watcher.teardown()
            }
            var i = vm._watchers.length
            while (i--) {
              vm._watchers[i].teardown()
            }
    // remove reference from data ob
    // frozen object may not have observer.
            if (vm._data.__ob__) {
              vm._data.__ob__.vmCount--
            }
    // call the last hook...
            vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
            vm.__patch__(vm._vnode, null)
    // fire destroyed hook
            callHook(vm, 'destroyed')
    // turn off all instance listeners.
            vm.$off()
    // remove __vue__ reference
            if (vm.$el) {
              vm.$el.__vue__ = null
            }
    // release circular reference (#6759)
            if (vm.$vnode) {
              vm.$vnode.parent = null
            }
          }
        }

        function mountComponent (
  vm,
  el,
  hydrating
) {
          vm.$el = el
          if (!vm.$options.render) {
            vm.$options.render = createEmptyVNode
            {
      /* istanbul ignore if */
              if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
                warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
              } else {
                warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
              }
            }
          }
          callHook(vm, 'beforeMount')

          var updateComponent
  /* istanbul ignore if */
          if ('development' !== 'production' && config.performance && mark) {
            updateComponent = function () {
              var name = vm._name
              var id = vm._uid
              var startTag = 'vue-perf-start:' + id
              var endTag = 'vue-perf-end:' + id

              mark(startTag)
              var vnode = vm._render()
              mark(endTag)
              measure(('vue ' + name + ' render'), startTag, endTag)

              mark(startTag)
              vm._update(vnode, hydrating)
              mark(endTag)
              measure(('vue ' + name + ' patch'), startTag, endTag)
            }
          } else {
            updateComponent = function () {
              vm._update(vm._render(), hydrating)
            }
          }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
          new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)
          hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
          if (vm.$vnode == null) {
            vm._isMounted = true
            callHook(vm, 'mounted')
          }
          return vm
        }

        function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
          {
            isUpdatingChildComponent = true
          }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
          var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  )

          vm.$options._parentVnode = parentVnode
          vm.$vnode = parentVnode // update vm's placeholder node without re-render

          if (vm._vnode) { // update child tree's parent
            vm._vnode.parent = parentVnode
          }
          vm.$options._renderChildren = renderChildren

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
          vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject
          vm.$listeners = listeners || emptyObject

  // update props
          if (propsData && vm.$options.props) {
            observerState.shouldConvert = false
            var props = vm._props
            var propKeys = vm.$options._propKeys || []
            for (var i = 0; i < propKeys.length; i++) {
              var key = propKeys[i]
              props[key] = validateProp(key, vm.$options.props, propsData, vm)
            }
            observerState.shouldConvert = true
    // keep a copy of raw propsData
            vm.$options.propsData = propsData
          }

  // update listeners
          if (listeners) {
            var oldListeners = vm.$options._parentListeners
            vm.$options._parentListeners = listeners
            updateComponentListeners(vm, listeners, oldListeners)
          }
  // resolve slots + force update if has children
          if (hasChildren) {
            vm.$slots = resolveSlots(renderChildren, parentVnode.context)
            vm.$forceUpdate()
          }

          {
            isUpdatingChildComponent = false
          }
        }

        function isInInactiveTree (vm) {
          while (vm && (vm = vm.$parent)) {
            if (vm._inactive) { return true }
          }
          return false
        }

        function activateChildComponent (vm, direct) {
          if (direct) {
            vm._directInactive = false
            if (isInInactiveTree(vm)) {
              return
            }
          } else if (vm._directInactive) {
            return
          }
          if (vm._inactive || vm._inactive === null) {
            vm._inactive = false
            for (var i = 0; i < vm.$children.length; i++) {
              activateChildComponent(vm.$children[i])
            }
            callHook(vm, 'activated')
          }
        }

        function deactivateChildComponent (vm, direct) {
          if (direct) {
            vm._directInactive = true
            if (isInInactiveTree(vm)) {
              return
            }
          }
          if (!vm._inactive) {
            vm._inactive = true
            for (var i = 0; i < vm.$children.length; i++) {
              deactivateChildComponent(vm.$children[i])
            }
            callHook(vm, 'deactivated')
          }
        }

        function callHook (vm, hook) {
          var handlers = vm.$options[hook]
          if (handlers) {
            for (var i = 0, j = handlers.length; i < j; i++) {
              try {
                handlers[i].call(vm)
              } catch (e) {
                handleError(e, vm, (hook + ' hook'))
              }
            }
          }
          if (vm._hasHookEvent) {
            vm.$emit('hook:' + hook)
          }
        }

/*  */

        var MAX_UPDATE_COUNT = 100

        var queue = []
        var activatedChildren = []
        var has = {}
        var circular = {}
        var waiting = false
        var flushing = false
        var index = 0

/**
 * Reset the scheduler's state.
 */
        function resetSchedulerState () {
          index = queue.length = activatedChildren.length = 0
          has = {}
          {
            circular = {}
          }
          waiting = flushing = false
        }

/**
 * Flush both queues and run the watchers.
 */
        function flushSchedulerQueue () {
          flushing = true
          var watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
          queue.sort(function (a, b) { return a.id - b.id })

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
          for (index = 0; index < queue.length; index++) {
            watcher = queue[index]
            id = watcher.id
            has[id] = null
            watcher.run()
    // in dev build, check and stop circular updates.
            if ('development' !== 'production' && has[id] != null) {
              circular[id] = (circular[id] || 0) + 1
              if (circular[id] > MAX_UPDATE_COUNT) {
                warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ('in watcher with expression "' + (watcher.expression) + '"')
              : 'in a component render function.'
          ),
          watcher.vm
        )
                break
              }
            }
          }

  // keep copies of post queues before resetting state
          var activatedQueue = activatedChildren.slice()
          var updatedQueue = queue.slice()

          resetSchedulerState()

  // call component updated and activated hooks
          callActivatedHooks(activatedQueue)
          callUpdatedHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
          if (devtools && config.devtools) {
            devtools.emit('flush')
          }
        }

        function callUpdatedHooks (queue) {
          var i = queue.length
          while (i--) {
            var watcher = queue[i]
            var vm = watcher.vm
            if (vm._watcher === watcher && vm._isMounted) {
              callHook(vm, 'updated')
            }
          }
        }

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
        function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
          vm._inactive = false
          activatedChildren.push(vm)
        }

        function callActivatedHooks (queue) {
          for (var i = 0; i < queue.length; i++) {
            queue[i]._inactive = true
            activateChildComponent(queue[i], true /* true */)
          }
        }

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
        function queueWatcher (watcher) {
          var id = watcher.id
          if (has[id] == null) {
            has[id] = true
            if (!flushing) {
              queue.push(watcher)
            } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
              var i = queue.length - 1
              while (i > index && queue[i].id > watcher.id) {
                i--
              }
              queue.splice(i + 1, 0, watcher)
            }
    // queue the flush
            if (!waiting) {
              waiting = true
              nextTick(flushSchedulerQueue)
            }
          }
        }

/*  */

        var uid$2 = 0

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
        var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
          this.vm = vm
          if (isRenderWatcher) {
            vm._watcher = this
          }
          vm._watchers.push(this)
  // options
          if (options) {
            this.deep = !!options.deep
            this.user = !!options.user
            this.lazy = !!options.lazy
            this.sync = !!options.sync
          } else {
            this.deep = this.user = this.lazy = this.sync = false
          }
          this.cb = cb
          this.id = ++uid$2 // uid for batching
          this.active = true
          this.dirty = this.lazy // for lazy watchers
          this.deps = []
          this.newDeps = []
          this.depIds = new _Set()
          this.newDepIds = new _Set()
          this.expression = expOrFn.toString()
  // parse expression for getter
          if (typeof expOrFn === 'function') {
            this.getter = expOrFn
          } else {
            this.getter = parsePath(expOrFn)
            if (!this.getter) {
              this.getter = function () {}
              'development' !== 'production' && warn(
        'Failed watching path: "' + expOrFn + '" ' +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      )
            }
          }
          this.value = this.lazy
    ? undefined
    : this.get()
        }

/**
 * Evaluate the getter, and re-collect dependencies.
 */
        Watcher.prototype.get = function get () {
          pushTarget(this)
          var value
          var vm = this.vm
          try {
            value = this.getter.call(vm, vm)
          } catch (e) {
            if (this.user) {
              handleError(e, vm, ('getter for watcher "' + (this.expression) + '"'))
            } else {
              throw e
            }
          } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
            if (this.deep) {
              traverse(value)
            }
            popTarget()
            this.cleanupDeps()
          }
          return value
        }

/**
 * Add a dependency to this directive.
 */
        Watcher.prototype.addDep = function addDep (dep) {
          var id = dep.id
          if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id)
            this.newDeps.push(dep)
            if (!this.depIds.has(id)) {
              dep.addSub(this)
            }
          }
        }

/**
 * Clean up for dependency collection.
 */
        Watcher.prototype.cleanupDeps = function cleanupDeps () {
          var this$1 = this

          var i = this.deps.length
          while (i--) {
            var dep = this$1.deps[i]
            if (!this$1.newDepIds.has(dep.id)) {
              dep.removeSub(this$1)
            }
          }
          var tmp = this.depIds
          this.depIds = this.newDepIds
          this.newDepIds = tmp
          this.newDepIds.clear()
          tmp = this.deps
          this.deps = this.newDeps
          this.newDeps = tmp
          this.newDeps.length = 0
        }

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
        Watcher.prototype.update = function update () {
  /* istanbul ignore else */
          if (this.lazy) {
            this.dirty = true
          } else if (this.sync) {
            this.run()
          } else {
            queueWatcher(this)
          }
        }

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
        Watcher.prototype.run = function run () {
          if (this.active) {
            var value = this.get()
            if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
              var oldValue = this.value
              this.value = value
              if (this.user) {
                try {
                  this.cb.call(this.vm, value, oldValue)
                } catch (e) {
                  handleError(e, this.vm, ('callback for watcher "' + (this.expression) + '"'))
                }
              } else {
                this.cb.call(this.vm, value, oldValue)
              }
            }
          }
        }

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
        Watcher.prototype.evaluate = function evaluate () {
          this.value = this.get()
          this.dirty = false
        }

/**
 * Depend on all deps collected by this watcher.
 */
        Watcher.prototype.depend = function depend () {
          var this$1 = this

          var i = this.deps.length
          while (i--) {
            this$1.deps[i].depend()
          }
        }

/**
 * Remove self from all dependencies' subscriber list.
 */
        Watcher.prototype.teardown = function teardown () {
          var this$1 = this

          if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
            if (!this.vm._isBeingDestroyed) {
              remove(this.vm._watchers, this)
            }
            var i = this.deps.length
            while (i--) {
              this$1.deps[i].removeSub(this$1)
            }
            this.active = false
          }
        }

/*  */

        var sharedPropertyDefinition = {
          enumerable: true,
          configurable: true,
          get: noop,
          set: noop
        }

        function proxy (target, sourceKey, key) {
          sharedPropertyDefinition.get = function proxyGetter () {
            return this[sourceKey][key]
          }
          sharedPropertyDefinition.set = function proxySetter (val) {
            this[sourceKey][key] = val
          }
          Object.defineProperty(target, key, sharedPropertyDefinition)
        }

        function initState (vm) {
          vm._watchers = []
          var opts = vm.$options
          if (opts.props) { initProps(vm, opts.props) }
          if (opts.methods) { initMethods(vm, opts.methods) }
          if (opts.data) {
            initData(vm)
          } else {
            observe(vm._data = {}, true /* asRootData */)
          }
          if (opts.computed) { initComputed(vm, opts.computed) }
          if (opts.watch && opts.watch !== nativeWatch) {
            initWatch(vm, opts.watch)
          }
        }

        function initProps (vm, propsOptions) {
          var propsData = vm.$options.propsData || {}
          var props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
          var keys = vm.$options._propKeys = []
          var isRoot = !vm.$parent
  // root instance props should be converted
          observerState.shouldConvert = isRoot
          var loop = function (key) {
            keys.push(key)
            var value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
            {
              var hyphenatedKey = hyphenate(key)
              if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
                warn(
          ('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.'),
          vm
        )
              }
              defineReactive(props, key, value, function () {
                if (vm.$parent && !isUpdatingChildComponent) {
                  warn(
            'Avoid mutating a prop directly since the value will be ' +
            'overwritten whenever the parent component re-renders. ' +
            "Instead, use a data or computed property based on the prop's " +
            'value. Prop being mutated: "' + key + '"',
            vm
          )
                }
              })
            }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
            if (!(key in vm)) {
              proxy(vm, '_props', key)
            }
          }

          for (var key in propsOptions) loop(key)
          observerState.shouldConvert = true
        }

        function initData (vm) {
          var data = vm.$options.data
          data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
          if (!isPlainObject(data)) {
            data = {}
            'development' !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
          }
  // proxy data on instance
          var keys = Object.keys(data)
          var props = vm.$options.props
          var methods = vm.$options.methods
          var i = keys.length
          while (i--) {
            var key = keys[i]
            {
              if (methods && hasOwn(methods, key)) {
                warn(
          ('Method "' + key + '" has already been defined as a data property.'),
          vm
        )
              }
            }
            if (props && hasOwn(props, key)) {
              'development' !== 'production' && warn(
        'The data property "' + key + '" is already declared as a prop. ' +
        'Use prop default value instead.',
        vm
      )
            } else if (!isReserved(key)) {
              proxy(vm, '_data', key)
            }
          }
  // observe data
          observe(data, true /* asRootData */)
        }

        function getData (data, vm) {
          try {
            return data.call(vm, vm)
          } catch (e) {
            handleError(e, vm, 'data()')
            return {}
          }
        }

        var computedWatcherOptions = { lazy: true }

        function initComputed (vm, computed) {
          var watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
          var isSSR = isServerRendering()

          for (var key in computed) {
            var userDef = computed[key]
            var getter = typeof userDef === 'function' ? userDef : userDef.get
            if ('development' !== 'production' && getter == null) {
              warn(
        ('Getter is missing for computed property "' + key + '".'),
        vm
      )
            }

            if (!isSSR) {
      // create internal watcher for the computed property.
              watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
            }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
            if (!(key in vm)) {
              defineComputed(vm, key, userDef)
            } else {
              if (key in vm.$data) {
                warn(('The computed property "' + key + '" is already defined in data.'), vm)
              } else if (vm.$options.props && key in vm.$options.props) {
                warn(('The computed property "' + key + '" is already defined as a prop.'), vm)
              }
            }
          }
        }

        function defineComputed (
  target,
  key,
  userDef
) {
          var shouldCache = !isServerRendering()
          if (typeof userDef === 'function') {
            sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef
            sharedPropertyDefinition.set = noop
          } else {
            sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop
            sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop
          }
          if ('development' !== 'production' &&
      sharedPropertyDefinition.set === noop) {
            sharedPropertyDefinition.set = function () {
              warn(
        ('Computed property "' + key + '" was assigned to but it has no setter.'),
        this
      )
            }
          }
          Object.defineProperty(target, key, sharedPropertyDefinition)
        }

        function createComputedGetter (key) {
          return function computedGetter () {
            var watcher = this._computedWatchers && this._computedWatchers[key]
            if (watcher) {
              if (watcher.dirty) {
                watcher.evaluate()
              }
              if (Dep.target) {
                watcher.depend()
              }
              return watcher.value
            }
          }
        }

        function initMethods (vm, methods) {
          var props = vm.$options.props
          for (var key in methods) {
            {
              if (methods[key] == null) {
                warn(
          'Method "' + key + '" has an undefined value in the component definition. ' +
          'Did you reference the function correctly?',
          vm
        )
              }
              if (props && hasOwn(props, key)) {
                warn(
          ('Method "' + key + '" has already been defined as a prop.'),
          vm
        )
              }
              if ((key in vm) && isReserved(key)) {
                warn(
          'Method "' + key + '" conflicts with an existing Vue instance method. ' +
          'Avoid defining component methods that start with _ or $.'
        )
              }
            }
            vm[key] = methods[key] == null ? noop : bind(methods[key], vm)
          }
        }

        function initWatch (vm, watch) {
          for (var key in watch) {
            var handler = watch[key]
            if (Array.isArray(handler)) {
              for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i])
              }
            } else {
              createWatcher(vm, key, handler)
            }
          }
        }

        function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
          if (isPlainObject(handler)) {
            options = handler
            handler = handler.handler
          }
          if (typeof handler === 'string') {
            handler = vm[handler]
          }
          return vm.$watch(keyOrFn, handler, options)
        }

        function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
          var dataDef = {}
          dataDef.get = function () { return this._data }
          var propsDef = {}
          propsDef.get = function () { return this._props }
          {
            dataDef.set = function (newData) {
              warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      )
            }
            propsDef.set = function () {
              warn('$props is readonly.', this)
            }
          }
          Object.defineProperty(Vue.prototype, '$data', dataDef)
          Object.defineProperty(Vue.prototype, '$props', propsDef)

          Vue.prototype.$set = set
          Vue.prototype.$delete = del

          Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
            var vm = this
            if (isPlainObject(cb)) {
              return createWatcher(vm, expOrFn, cb, options)
            }
            options = options || {}
            options.user = true
            var watcher = new Watcher(vm, expOrFn, cb, options)
            if (options.immediate) {
              cb.call(vm, watcher.value)
            }
            return function unwatchFn () {
              watcher.teardown()
            }
          }
        }

/*  */

        function initProvide (vm) {
          var provide = vm.$options.provide
          if (provide) {
            vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide
          }
        }

        function initInjections (vm) {
          var result = resolveInject(vm.$options.inject, vm)
          if (result) {
            observerState.shouldConvert = false
            Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
              {
                defineReactive(vm, key, result[key], function () {
                  warn(
            'Avoid mutating an injected value directly since the changes will be ' +
            'overwritten whenever the provided component re-renders. ' +
            'injection being mutated: "' + key + '"',
            vm
          )
                })
              }
            })
            observerState.shouldConvert = true
          }
        }

        function resolveInject (inject, vm) {
          if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
            var result = Object.create(null)
            var keys = hasSymbol
        ? Reflect.ownKeys(inject).filter(function (key) {
          /* istanbul ignore next */
          return Object.getOwnPropertyDescriptor(inject, key).enumerable
        })
        : Object.keys(inject)

            for (var i = 0; i < keys.length; i++) {
              var key = keys[i]
              var provideKey = inject[key].from
              var source = vm
              while (source) {
                if (source._provided && provideKey in source._provided) {
                  result[key] = source._provided[provideKey]
                  break
                }
                source = source.$parent
              }
              if (!source) {
                if ('default' in inject[key]) {
                  var provideDefault = inject[key].default
                  result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault
                } else {
                  warn(('Injection "' + key + '" not found'), vm)
                }
              }
            }
            return result
          }
        }

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
        function renderList (
  val,
  render
) {
          var ret, i, l, keys, key
          if (Array.isArray(val) || typeof val === 'string') {
            ret = new Array(val.length)
            for (i = 0, l = val.length; i < l; i++) {
              ret[i] = render(val[i], i)
            }
          } else if (typeof val === 'number') {
            ret = new Array(val)
            for (i = 0; i < val; i++) {
              ret[i] = render(i + 1, i)
            }
          } else if (isObject(val)) {
            keys = Object.keys(val)
            ret = new Array(keys.length)
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i]
              ret[i] = render(val[key], key, i)
            }
          }
          if (isDef(ret)) {
            (ret)._isVList = true
          }
          return ret
        }

/*  */

/**
 * Runtime helper for rendering <slot>
 */
        function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
          var scopedSlotFn = this.$scopedSlots[name]
          var nodes
          if (scopedSlotFn) { // scoped slot
            props = props || {}
            if (bindObject) {
              if ('development' !== 'production' && !isObject(bindObject)) {
                warn(
          'slot v-bind without argument expects an Object',
          this
        )
              }
              props = extend(extend({}, bindObject), props)
            }
            nodes = scopedSlotFn(props) || fallback
          } else {
            var slotNodes = this.$slots[name]
    // warn duplicate slot usage
            if (slotNodes) {
              if ('development' !== 'production' && slotNodes._rendered) {
                warn(
          'Duplicate presence of slot "' + name + '" found in the same render tree ' +
          '- this will likely cause render errors.',
          this
        )
              }
              slotNodes._rendered = true
            }
            nodes = slotNodes || fallback
          }

          var target = props && props.slot
          if (target) {
            return this.$createElement('template', { slot: target }, nodes)
          } else {
            return nodes
          }
        }

/*  */

/**
 * Runtime helper for resolving filters
 */
        function resolveFilter (id) {
          return resolveAsset(this.$options, 'filters', id, true) || identity
        }

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
        function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias,
  eventKeyName
) {
          var keyCodes = config.keyCodes[key] || builtInAlias
          if (keyCodes) {
            if (Array.isArray(keyCodes)) {
              return keyCodes.indexOf(eventKeyCode) === -1
            } else {
              return keyCodes !== eventKeyCode
            }
          } else if (eventKeyName) {
            return hyphenate(eventKeyName) !== key
          }
        }

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
        function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
          if (value) {
            if (!isObject(value)) {
              'development' !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      )
            } else {
              if (Array.isArray(value)) {
                value = toObject(value)
              }
              var hash
              var loop = function (key) {
                if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
                  hash = data
                } else {
                  var type = data.attrs && data.attrs.type
                  hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {})
                }
                if (!(key in hash)) {
                  hash[key] = value[key]

                  if (isSync) {
                    var on = data.on || (data.on = {})
                    on[('update:' + key)] = function ($event) {
                      value[key] = $event
                    }
                  }
                }
              }

              for (var key in value) loop(key)
            }
          }
          return data
        }

/*  */

/**
 * Runtime helper for rendering static trees.
 */
        function renderStatic (
  index,
  isInFor,
  isOnce
) {
  // render fns generated by compiler < 2.5.4 does not provide v-once
  // information to runtime so be conservative
          var isOldVersion = arguments.length < 3
  // if a static tree is generated by v-once, it is cached on the instance;
  // otherwise it is purely static and can be cached on the shared options
  // across all instances.
          var renderFns = this.$options.staticRenderFns
          var cached = isOldVersion || isOnce
    ? (this._staticTrees || (this._staticTrees = []))
    : (renderFns.cached || (renderFns.cached = []))
          var tree = cached[index]
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
          if (tree && !isInFor) {
            return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
          }
  // otherwise, render a fresh tree.
          tree = cached[index] = renderFns[index].call(this._renderProxy, null, this)
          markStatic(tree, ('__static__' + index), false)
          return tree
        }

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
        function markOnce (
  tree,
  index,
  key
) {
          markStatic(tree, ('__once__' + index + (key ? ('_' + key) : '')), true)
          return tree
        }

        function markStatic (
  tree,
  key,
  isOnce
) {
          if (Array.isArray(tree)) {
            for (var i = 0; i < tree.length; i++) {
              if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], (key + '_' + i), isOnce)
              }
            }
          } else {
            markStaticNode(tree, key, isOnce)
          }
        }

        function markStaticNode (node, key, isOnce) {
          node.isStatic = true
          node.key = key
          node.isOnce = isOnce
        }

/*  */

        function bindObjectListeners (data, value) {
          if (value) {
            if (!isPlainObject(value)) {
              'development' !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      )
            } else {
              var on = data.on = data.on ? extend({}, data.on) : {}
              for (var key in value) {
                var existing = on[key]
                var ours = value[key]
                on[key] = existing ? [].concat(existing, ours) : ours
              }
            }
          }
          return data
        }

/*  */

        function installRenderHelpers (target) {
          target._o = markOnce
          target._n = toNumber
          target._s = toString
          target._l = renderList
          target._t = renderSlot
          target._q = looseEqual
          target._i = looseIndexOf
          target._m = renderStatic
          target._f = resolveFilter
          target._k = checkKeyCodes
          target._b = bindObjectProps
          target._v = createTextVNode
          target._e = createEmptyVNode
          target._u = resolveScopedSlots
          target._g = bindObjectListeners
        }

/*  */

        function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
          var options = Ctor.options
          this.data = data
          this.props = props
          this.children = children
          this.parent = parent
          this.listeners = data.on || emptyObject
          this.injections = resolveInject(options.inject, parent)
          this.slots = function () { return resolveSlots(children, parent) }

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
          var contextVm = Object.create(parent)
          var isCompiled = isTrue(options._compiled)
          var needNormalization = !isCompiled

  // support for compiled functional template
          if (isCompiled) {
    // exposing $options for renderStatic()
            this.$options = options
    // pre-resolve slots for renderSlot()
            this.$slots = this.slots()
            this.$scopedSlots = data.scopedSlots || emptyObject
          }

          if (options._scopeId) {
            this._c = function (a, b, c, d) {
              var vnode = createElement(contextVm, a, b, c, d, needNormalization)
              if (vnode) {
                vnode.fnScopeId = options._scopeId
                vnode.fnContext = parent
              }
              return vnode
            }
          } else {
            this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization) }
          }
        }

        installRenderHelpers(FunctionalRenderContext.prototype)

        function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
          var options = Ctor.options
          var props = {}
          var propOptions = options.props
          if (isDef(propOptions)) {
            for (var key in propOptions) {
              props[key] = validateProp(key, propOptions, propsData || emptyObject)
            }
          } else {
            if (isDef(data.attrs)) { mergeProps(props, data.attrs) }
            if (isDef(data.props)) { mergeProps(props, data.props) }
          }

          var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  )

          var vnode = options.render.call(null, renderContext._c, renderContext)

          if (vnode instanceof VNode) {
            vnode.fnContext = contextVm
            vnode.fnOptions = options
            if (data.slot) {
              (vnode.data || (vnode.data = {})).slot = data.slot
            }
          }

          return vnode
        }

        function mergeProps (to, from) {
          for (var key in from) {
            to[camelize(key)] = from[key]
          }
        }

/*  */

// hooks to be invoked on component VNodes during patch
        var componentVNodeHooks = {
          init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
            if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
              var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      )
              child.$mount(hydrating ? vnode.elm : undefined, hydrating)
            } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
              var mountedNode = vnode // work around flow
              componentVNodeHooks.prepatch(mountedNode, mountedNode)
            }
          },

          prepatch: function prepatch (oldVnode, vnode) {
            var options = vnode.componentOptions
            var child = vnode.componentInstance = oldVnode.componentInstance
            updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
          },

          insert: function insert (vnode) {
            var context = vnode.context
            var componentInstance = vnode.componentInstance
            if (!componentInstance._isMounted) {
              componentInstance._isMounted = true
              callHook(componentInstance, 'mounted')
            }
            if (vnode.data.keepAlive) {
              if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance)
              } else {
                activateChildComponent(componentInstance, true /* direct */)
              }
            }
          },

          destroy: function destroy (vnode) {
            var componentInstance = vnode.componentInstance
            if (!componentInstance._isDestroyed) {
              if (!vnode.data.keepAlive) {
                componentInstance.$destroy()
              } else {
                deactivateChildComponent(componentInstance, true /* direct */)
              }
            }
          }
        }

        var hooksToMerge = Object.keys(componentVNodeHooks)

        function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
          if (isUndef(Ctor)) {
            return
          }

          var baseCtor = context.$options._base

  // plain options object: turn it into a constructor
          if (isObject(Ctor)) {
            Ctor = baseCtor.extend(Ctor)
          }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
          if (typeof Ctor !== 'function') {
            {
              warn(('Invalid Component definition: ' + (String(Ctor))), context)
            }
            return
          }

  // async component
          var asyncFactory
          if (isUndef(Ctor.cid)) {
            asyncFactory = Ctor
            Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
            if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
              return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
            }
          }

          data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
          resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
          if (isDef(data.model)) {
            transformModel(Ctor.options, data)
          }

  // extract props
          var propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
          if (isTrue(Ctor.options.functional)) {
            return createFunctionalComponent(Ctor, propsData, data, context, children)
          }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
          var listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
          data.on = data.nativeOn

          if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
            var slot = data.slot
            data = {}
            if (slot) {
              data.slot = slot
            }
          }

  // merge component management hooks onto the placeholder node
          mergeHooks(data)

  // return a placeholder vnode
          var name = Ctor.options.name || tag
          var vnode = new VNode(
    ('vue-component-' + (Ctor.cid) + (name ? ('-' + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  )
          return vnode
        }

        function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
          var vnodeComponentOptions = vnode.componentOptions
          var options = {
            _isComponent: true,
            parent: parent,
            propsData: vnodeComponentOptions.propsData,
            _componentTag: vnodeComponentOptions.tag,
            _parentVnode: vnode,
            _parentListeners: vnodeComponentOptions.listeners,
            _renderChildren: vnodeComponentOptions.children,
            _parentElm: parentElm || null,
            _refElm: refElm || null
          }
  // check inline-template render functions
          var inlineTemplate = vnode.data.inlineTemplate
          if (isDef(inlineTemplate)) {
            options.render = inlineTemplate.render
            options.staticRenderFns = inlineTemplate.staticRenderFns
          }
          return new vnodeComponentOptions.Ctor(options)
        }

        function mergeHooks (data) {
          if (!data.hook) {
            data.hook = {}
          }
          for (var i = 0; i < hooksToMerge.length; i++) {
            var key = hooksToMerge[i]
            var fromParent = data.hook[key]
            var ours = componentVNodeHooks[key]
            data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours
          }
        }

        function mergeHook$1 (one, two) {
          return function (a, b, c, d) {
            one(a, b, c, d)
            two(a, b, c, d)
          }
        }

// transform component v-model info (value and callback) into
// prop and event handler respectively.
        function transformModel (options, data) {
          var prop = (options.model && options.model.prop) || 'value'
          var event = (options.model && options.model.event) || 'input'; (data.props || (data.props = {}))[prop] = data.model.value
          var on = data.on || (data.on = {})
          if (isDef(on[event])) {
            on[event] = [data.model.callback].concat(on[event])
          } else {
            on[event] = data.model.callback
          }
        }

/*  */

        var SIMPLE_NORMALIZE = 1
        var ALWAYS_NORMALIZE = 2

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
        function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
          if (Array.isArray(data) || isPrimitive(data)) {
            normalizationType = children
            children = data
            data = undefined
          }
          if (isTrue(alwaysNormalize)) {
            normalizationType = ALWAYS_NORMALIZE
          }
          return _createElement(context, tag, data, children, normalizationType)
        }

        function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
          if (isDef(data) && isDef((data).__ob__)) {
            'development' !== 'production' && warn(
      'Avoid using observed data object as vnode data: ' + (JSON.stringify(data)) + '\n' +
      'Always create fresh vnode data objects in each render!',
      context
    )
            return createEmptyVNode()
          }
  // object syntax in v-bind
          if (isDef(data) && isDef(data.is)) {
            tag = data.is
          }
          if (!tag) {
    // in case of component :is set to falsy value
            return createEmptyVNode()
          }
  // warn against non-primitive key
          if ('development' !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
            warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    )
          }
  // support single function children as default scoped slot
          if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
            data = data || {}
            data.scopedSlots = { default: children[0] }
            children.length = 0
          }
          if (normalizationType === ALWAYS_NORMALIZE) {
            children = normalizeChildren(children)
          } else if (normalizationType === SIMPLE_NORMALIZE) {
            children = simpleNormalizeChildren(children)
          }
          var vnode, ns
          if (typeof tag === 'string') {
            var Ctor
            ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
            if (config.isReservedTag(tag)) {
      // platform built-in elements
              vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
            } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
              vnode = createComponent(Ctor, data, context, children, tag)
            } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
              vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
            }
          } else {
    // direct component options / constructor
            vnode = createComponent(tag, data, context, children)
          }
          if (isDef(vnode)) {
            if (ns) { applyNS(vnode, ns) }
            return vnode
          } else {
            return createEmptyVNode()
          }
        }

        function applyNS (vnode, ns, force) {
          vnode.ns = ns
          if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
            ns = undefined
            force = true
          }
          if (isDef(vnode.children)) {
            for (var i = 0, l = vnode.children.length; i < l; i++) {
              var child = vnode.children[i]
              if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
                applyNS(child, ns, force)
              }
            }
          }
        }

/*  */

        function initRender (vm) {
          vm._vnode = null // the root of the child tree
          vm._staticTrees = null // v-once cached trees
          var options = vm.$options
          var parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
          var renderContext = parentVnode && parentVnode.context
          vm.$slots = resolveSlots(options._renderChildren, renderContext)
          vm.$scopedSlots = emptyObject
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
          vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false) }
  // normalization is always applied for the public version, used in
  // user-written render functions.
          vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true) }

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
          var parentData = parentVnode && parentVnode.data

  /* istanbul ignore else */
          {
            defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
              !isUpdatingChildComponent && warn('$attrs is readonly.', vm)
            }, true)
            defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
              !isUpdatingChildComponent && warn('$listeners is readonly.', vm)
            }, true)
          }
        }

        function renderMixin (Vue) {
  // install runtime convenience helpers
          installRenderHelpers(Vue.prototype)

          Vue.prototype.$nextTick = function (fn) {
            return nextTick(fn, this)
          }

          Vue.prototype._render = function () {
            var vm = this
            var ref = vm.$options
            var render = ref.render
            var _parentVnode = ref._parentVnode

            if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
              for (var key in vm.$slots) {
                var slot = vm.$slots[key]
        // _rendered is a flag added by renderSlot, but may not be present
        // if the slot is passed from manually written render functions
                if (slot._rendered || (slot[0] && slot[0].elm)) {
                  vm.$slots[key] = cloneVNodes(slot, true /* deep */)
                }
              }
            }

            vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
            vm.$vnode = _parentVnode
    // render self
            var vnode
            try {
              vnode = render.call(vm._renderProxy, vm.$createElement)
            } catch (e) {
              handleError(e, vm, 'render')
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
              {
                if (vm.$options.renderError) {
                  try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
                  } catch (e) {
                    handleError(e, vm, 'renderError')
                    vnode = vm._vnode
                  }
                } else {
                  vnode = vm._vnode
                }
              }
            }
    // return empty vnode in case the render function errored out
            if (!(vnode instanceof VNode)) {
              if ('development' !== 'production' && Array.isArray(vnode)) {
                warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
              }
              vnode = createEmptyVNode()
            }
    // set parent
            vnode.parent = _parentVnode
            return vnode
          }
        }

/*  */

        var uid$1 = 0

        function initMixin (Vue) {
          Vue.prototype._init = function (options) {
            var vm = this
    // a uid
            vm._uid = uid$1++

            var startTag, endTag
    /* istanbul ignore if */
            if ('development' !== 'production' && config.performance && mark) {
              startTag = 'vue-perf-start:' + (vm._uid)
              endTag = 'vue-perf-end:' + (vm._uid)
              mark(startTag)
            }

    // a flag to avoid this being observed
            vm._isVue = true
    // merge options
            if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
              initInternalComponent(vm, options)
            } else {
              vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
            }
    /* istanbul ignore else */
            {
              initProxy(vm)
            }
    // expose real self
            vm._self = vm
            initLifecycle(vm)
            initEvents(vm)
            initRender(vm)
            callHook(vm, 'beforeCreate')
            initInjections(vm) // resolve injections before data/props
            initState(vm)
            initProvide(vm) // resolve provide after data/props
            callHook(vm, 'created')

    /* istanbul ignore if */
            if ('development' !== 'production' && config.performance && mark) {
              vm._name = formatComponentName(vm, false)
              mark(endTag)
              measure(('vue ' + (vm._name) + ' init'), startTag, endTag)
            }

            if (vm.$options.el) {
              vm.$mount(vm.$options.el)
            }
          }
        }

        function initInternalComponent (vm, options) {
          var opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
          opts.parent = options.parent
          opts.propsData = options.propsData
          opts._parentVnode = options._parentVnode
          opts._parentListeners = options._parentListeners
          opts._renderChildren = options._renderChildren
          opts._componentTag = options._componentTag
          opts._parentElm = options._parentElm
          opts._refElm = options._refElm
          if (options.render) {
            opts.render = options.render
            opts.staticRenderFns = options.staticRenderFns
          }
        }

        function resolveConstructorOptions (Ctor) {
          var options = Ctor.options
          if (Ctor.super) {
            var superOptions = resolveConstructorOptions(Ctor.super)
            var cachedSuperOptions = Ctor.superOptions
            if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
              Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
              var modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
              if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions)
              }
              options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
              if (options.name) {
                options.components[options.name] = Ctor
              }
            }
          }
          return options
        }

        function resolveModifiedOptions (Ctor) {
          var modified
          var latest = Ctor.options
          var extended = Ctor.extendOptions
          var sealed = Ctor.sealedOptions
          for (var key in latest) {
            if (latest[key] !== sealed[key]) {
              if (!modified) { modified = {} }
              modified[key] = dedupe(latest[key], extended[key], sealed[key])
            }
          }
          return modified
        }

        function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
          if (Array.isArray(latest)) {
            var res = []
            sealed = Array.isArray(sealed) ? sealed : [sealed]
            extended = Array.isArray(extended) ? extended : [extended]
            for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
              if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
                res.push(latest[i])
              }
            }
            return res
          } else {
            return latest
          }
        }

        function Vue$3 (options) {
          if ('development' !== 'production' &&
    !(this instanceof Vue$3)
  ) {
            warn('Vue is a constructor and should be called with the `new` keyword')
          }
          this._init(options)
        }

        initMixin(Vue$3)
        stateMixin(Vue$3)
        eventsMixin(Vue$3)
        lifecycleMixin(Vue$3)
        renderMixin(Vue$3)

/*  */

        function initUse (Vue) {
          Vue.use = function (plugin) {
            var installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
            if (installedPlugins.indexOf(plugin) > -1) {
              return this
            }

    // additional parameters
            var args = toArray(arguments, 1)
            args.unshift(this)
            if (typeof plugin.install === 'function') {
              plugin.install.apply(plugin, args)
            } else if (typeof plugin === 'function') {
              plugin.apply(null, args)
            }
            installedPlugins.push(plugin)
            return this
          }
        }

/*  */

        function initMixin$1 (Vue) {
          Vue.mixin = function (mixin) {
            this.options = mergeOptions(this.options, mixin)
            return this
          }
        }

/*  */

        function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
          Vue.cid = 0
          var cid = 1

  /**
   * Class inheritance
   */
          Vue.extend = function (extendOptions) {
            extendOptions = extendOptions || {}
            var Super = this
            var SuperId = Super.cid
            var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
            if (cachedCtors[SuperId]) {
              return cachedCtors[SuperId]
            }

            var name = extendOptions.name || Super.options.name
            {
              if (!/^[a-zA-Z][\w-]*$/.test(name)) {
                warn(
          'Invalid component name: "' + name + '". Component names ' +
          'can only contain alphanumeric characters and the hyphen, ' +
          'and must start with a letter.'
        )
              }
            }

            var Sub = function VueComponent (options) {
              this._init(options)
            }
            Sub.prototype = Object.create(Super.prototype)
            Sub.prototype.constructor = Sub
            Sub.cid = cid++
            Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
            Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
            if (Sub.options.props) {
              initProps$1(Sub)
            }
            if (Sub.options.computed) {
              initComputed$1(Sub)
            }

    // allow further extension/mixin/plugin usage
            Sub.extend = Super.extend
            Sub.mixin = Super.mixin
            Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
            ASSET_TYPES.forEach(function (type) {
              Sub[type] = Super[type]
            })
    // enable recursive self-lookup
            if (name) {
              Sub.options.components[name] = Sub
            }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
            Sub.superOptions = Super.options
            Sub.extendOptions = extendOptions
            Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
            cachedCtors[SuperId] = Sub
            return Sub
          }
        }

        function initProps$1 (Comp) {
          var props = Comp.options.props
          for (var key in props) {
            proxy(Comp.prototype, '_props', key)
          }
        }

        function initComputed$1 (Comp) {
          var computed = Comp.options.computed
          for (var key in computed) {
            defineComputed(Comp.prototype, key, computed[key])
          }
        }

/*  */

        function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
          ASSET_TYPES.forEach(function (type) {
            Vue[type] = function (
      id,
      definition
    ) {
              if (!definition) {
                return this.options[type + 's'][id]
              } else {
        /* istanbul ignore if */
                {
                  if (type === 'component' && config.isReservedTag(id)) {
                    warn(
              'Do not use built-in or reserved HTML elements as component ' +
              'id: ' + id
            )
                  }
                }
                if (type === 'component' && isPlainObject(definition)) {
                  definition.name = definition.name || id
                  definition = this.options._base.extend(definition)
                }
                if (type === 'directive' && typeof definition === 'function') {
                  definition = { bind: definition, update: definition }
                }
                this.options[type + 's'][id] = definition
                return definition
              }
            }
          })
        }

/*  */

        function getComponentName (opts) {
          return opts && (opts.Ctor.options.name || opts.tag)
        }

        function matches (pattern, name) {
          if (Array.isArray(pattern)) {
            return pattern.indexOf(name) > -1
          } else if (typeof pattern === 'string') {
            return pattern.split(',').indexOf(name) > -1
          } else if (isRegExp(pattern)) {
            return pattern.test(name)
          }
  /* istanbul ignore next */
          return false
        }

        function pruneCache (keepAliveInstance, filter) {
          var cache = keepAliveInstance.cache
          var keys = keepAliveInstance.keys
          var _vnode = keepAliveInstance._vnode
          for (var key in cache) {
            var cachedNode = cache[key]
            if (cachedNode) {
              var name = getComponentName(cachedNode.componentOptions)
              if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode)
              }
            }
          }
        }

        function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
          var cached$$1 = cache[key]
          if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
            cached$$1.componentInstance.$destroy()
          }
          cache[key] = null
          remove(keys, key)
        }

        var patternTypes = [String, RegExp, Array]

        var KeepAlive = {
          name: 'keep-alive',
          abstract: true,

          props: {
            include: patternTypes,
            exclude: patternTypes,
            max: [String, Number]
          },

          created: function created () {
            this.cache = Object.create(null)
            this.keys = []
          },

          destroyed: function destroyed () {
            var this$1 = this

            for (var key in this$1.cache) {
              pruneCacheEntry(this$1.cache, key, this$1.keys)
            }
          },

          watch: {
            include: function include (val) {
              pruneCache(this, function (name) { return matches(val, name) })
            },
            exclude: function exclude (val) {
              pruneCache(this, function (name) { return !matches(val, name) })
            }
          },

          render: function render () {
            var slot = this.$slots.default
            var vnode = getFirstComponentChild(slot)
            var componentOptions = vnode && vnode.componentOptions
            if (componentOptions) {
      // check pattern
              var name = getComponentName(componentOptions)
              var ref = this
              var include = ref.include
              var exclude = ref.exclude
              if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
                return vnode
              }

              var ref$1 = this
              var cache = ref$1.cache
              var keys = ref$1.keys
              var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ('::' + (componentOptions.tag)) : '')
        : vnode.key
              if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance
        // make current key freshest
                remove(keys, key)
                keys.push(key)
              } else {
                cache[key] = vnode
                keys.push(key)
        // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                  pruneCacheEntry(cache, keys[0], keys, this._vnode)
                }
              }

              vnode.data.keepAlive = true
            }
            return vnode || (slot && slot[0])
          }
        }

        var builtInComponents = {
          KeepAlive: KeepAlive
        }

/*  */

        function initGlobalAPI (Vue) {
  // config
          var configDef = {}
          configDef.get = function () { return config }
          {
            configDef.set = function () {
              warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      )
            }
          }
          Object.defineProperty(Vue, 'config', configDef)

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
          Vue.util = {
            warn: warn,
            extend: extend,
            mergeOptions: mergeOptions,
            defineReactive: defineReactive
          }

          Vue.set = set
          Vue.delete = del
          Vue.nextTick = nextTick

          Vue.options = Object.create(null)
          ASSET_TYPES.forEach(function (type) {
            Vue.options[type + 's'] = Object.create(null)
          })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
          Vue.options._base = Vue

          extend(Vue.options.components, builtInComponents)

          initUse(Vue)
          initMixin$1(Vue)
          initExtend(Vue)
          initAssetRegisters(Vue)
        }

        initGlobalAPI(Vue$3)

        Object.defineProperty(Vue$3.prototype, '$isServer', {
          get: isServerRendering
        })

        Object.defineProperty(Vue$3.prototype, '$ssrContext', {
          get: function get () {
    /* istanbul ignore next */
            return this.$vnode && this.$vnode.ssrContext
          }
        })

        Vue$3.version = '2.5.9'

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
        var isReservedAttr = makeMap('style,class')

// attributes that should be using props for binding
        var acceptValue = makeMap('input,textarea,option,select,progress')
        var mustUseProp = function (tag, type, attr) {
          return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
          )
        }

        var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck')

        var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
)

        var xlinkNS = 'http://www.w3.org/1999/xlink'

        var isXlink = function (name) {
          return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
        }

        var getXlinkProp = function (name) {
          return isXlink(name) ? name.slice(6, name.length) : ''
        }

        var isFalsyAttrValue = function (val) {
          return val == null || val === false
        }

/*  */

        function genClassForVnode (vnode) {
          var data = vnode.data
          var parentNode = vnode
          var childNode = vnode
          while (isDef(childNode.componentInstance)) {
            childNode = childNode.componentInstance._vnode
            if (childNode.data) {
              data = mergeClassData(childNode.data, data)
            }
          }
          while (isDef(parentNode = parentNode.parent)) {
            if (parentNode.data) {
              data = mergeClassData(data, parentNode.data)
            }
          }
          return renderClass(data.staticClass, data.class)
        }

        function mergeClassData (child, parent) {
          return {
            staticClass: concat(child.staticClass, parent.staticClass),
            class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
          }
        }

        function renderClass (
  staticClass,
  dynamicClass
) {
          if (isDef(staticClass) || isDef(dynamicClass)) {
            return concat(staticClass, stringifyClass(dynamicClass))
          }
  /* istanbul ignore next */
          return ''
        }

        function concat (a, b) {
          return a ? b ? (a + ' ' + b) : a : (b || '')
        }

        function stringifyClass (value) {
          if (Array.isArray(value)) {
            return stringifyArray(value)
          }
          if (isObject(value)) {
            return stringifyObject(value)
          }
          if (typeof value === 'string') {
            return value
          }
  /* istanbul ignore next */
          return ''
        }

        function stringifyArray (value) {
          var res = ''
          var stringified
          for (var i = 0, l = value.length; i < l; i++) {
            if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
              if (res) { res += ' ' }
              res += stringified
            }
          }
          return res
        }

        function stringifyObject (value) {
          var res = ''
          for (var key in value) {
            if (value[key]) {
              if (res) { res += ' ' }
              res += key
            }
          }
          return res
        }

/*  */

        var namespaceMap = {
          svg: 'http://www.w3.org/2000/svg',
          math: 'http://www.w3.org/1998/Math/MathML'
        }

        var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
)

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
        var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
)

        var isPreTag = function (tag) { return tag === 'pre' }

        var isReservedTag = function (tag) {
          return isHTMLTag(tag) || isSVG(tag)
        }

        function getTagNamespace (tag) {
          if (isSVG(tag)) {
            return 'svg'
          }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
          if (tag === 'math') {
            return 'math'
          }
        }

        var unknownElementCache = Object.create(null)
        function isUnknownElement (tag) {
  /* istanbul ignore if */
          if (!inBrowser) {
            return true
          }
          if (isReservedTag(tag)) {
            return false
          }
          tag = tag.toLowerCase()
  /* istanbul ignore if */
          if (unknownElementCache[tag] != null) {
            return unknownElementCache[tag]
          }
          var el = document.createElement(tag)
          if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
            return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
          } else {
            return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
          }
        }

        var isTextInputType = makeMap('text,number,password,search,email,tel,url')

/*  */

/**
 * Query an element selector if it's not an element already.
 */
        function query (el) {
          if (typeof el === 'string') {
            var selected = document.querySelector(el)
            if (!selected) {
              'development' !== 'production' && warn(
        'Cannot find element: ' + el
      )
              return document.createElement('div')
            }
            return selected
          } else {
            return el
          }
        }

/*  */

        function createElement$1 (tagName, vnode) {
          var elm = document.createElement(tagName)
          if (tagName !== 'select') {
            return elm
          }
  // false or null will remove the attribute but undefined will not
          if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
            elm.setAttribute('multiple', 'multiple')
          }
          return elm
        }

        function createElementNS (namespace, tagName) {
          return document.createElementNS(namespaceMap[namespace], tagName)
        }

        function createTextNode (text) {
          return document.createTextNode(text)
        }

        function createComment (text) {
          return document.createComment(text)
        }

        function insertBefore (parentNode, newNode, referenceNode) {
          parentNode.insertBefore(newNode, referenceNode)
        }

        function removeChild (node, child) {
          node.removeChild(child)
        }

        function appendChild (node, child) {
          node.appendChild(child)
        }

        function parentNode (node) {
          return node.parentNode
        }

        function nextSibling (node) {
          return node.nextSibling
        }

        function tagName (node) {
          return node.tagName
        }

        function setTextContent (node, text) {
          node.textContent = text
        }

        function setAttribute (node, key, val) {
          node.setAttribute(key, val)
        }

        var nodeOps = Object.freeze({
          createElement: createElement$1,
          createElementNS: createElementNS,
          createTextNode: createTextNode,
          createComment: createComment,
          insertBefore: insertBefore,
          removeChild: removeChild,
          appendChild: appendChild,
          parentNode: parentNode,
          nextSibling: nextSibling,
          tagName: tagName,
          setTextContent: setTextContent,
          setAttribute: setAttribute
        })

/*  */

        var ref = {
          create: function create (_, vnode) {
            registerRef(vnode)
          },
          update: function update (oldVnode, vnode) {
            if (oldVnode.data.ref !== vnode.data.ref) {
              registerRef(oldVnode, true)
              registerRef(vnode)
            }
          },
          destroy: function destroy (vnode) {
            registerRef(vnode, true)
          }
        }

        function registerRef (vnode, isRemoval) {
          var key = vnode.data.ref
          if (!key) { return }

          var vm = vnode.context
          var ref = vnode.componentInstance || vnode.elm
          var refs = vm.$refs
          if (isRemoval) {
            if (Array.isArray(refs[key])) {
              remove(refs[key], ref)
            } else if (refs[key] === ref) {
              refs[key] = undefined
            }
          } else {
            if (vnode.data.refInFor) {
              if (!Array.isArray(refs[key])) {
                refs[key] = [ref]
              } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
                refs[key].push(ref)
              }
            } else {
              refs[key] = ref
            }
          }
        }

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

        var emptyNode = new VNode('', {}, [])

        var hooks = ['create', 'activate', 'update', 'remove', 'destroy']

        function sameVnode (a, b) {
          return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
          )
        }

        function sameInputType (a, b) {
          if (a.tag !== 'input') { return true }
          var i
          var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type
          var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type
          return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
        }

        function createKeyToOldIdx (children, beginIdx, endIdx) {
          var i, key
          var map = {}
          for (i = beginIdx; i <= endIdx; ++i) {
            key = children[i].key
            if (isDef(key)) { map[key] = i }
          }
          return map
        }

        function createPatchFunction (backend) {
          var i, j
          var cbs = {}

          var modules = backend.modules
          var nodeOps = backend.nodeOps

          for (i = 0; i < hooks.length; ++i) {
            cbs[hooks[i]] = []
            for (j = 0; j < modules.length; ++j) {
              if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]])
              }
            }
          }

          function emptyNodeAt (elm) {
            return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
          }

          function createRmCb (childElm, listeners) {
            function remove () {
              if (--remove.listeners === 0) {
                removeNode(childElm)
              }
            }
            remove.listeners = listeners
            return remove
          }

          function removeNode (el) {
            var parent = nodeOps.parentNode(el)
    // element may have already been removed due to v-html / v-text
            if (isDef(parent)) {
              nodeOps.removeChild(parent, el)
            }
          }

          function isUnknownElement$$1 (vnode, inVPre) {
            return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
            )
          }

          var creatingElmInVPre = 0
          function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
            vnode.isRootInsert = !nested // for transition enter check
            if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
              return
            }

            var data = vnode.data
            var children = vnode.children
            var tag = vnode.tag
            if (isDef(tag)) {
              {
                if (data && data.pre) {
                  creatingElmInVPre++
                }
                if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                  warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          )
                }
              }
              vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
              setScope(vnode)

      /* istanbul ignore if */
              {
                createChildren(vnode, children, insertedVnodeQueue)
                if (isDef(data)) {
                  invokeCreateHooks(vnode, insertedVnodeQueue)
                }
                insert(parentElm, vnode.elm, refElm)
              }

              if ('development' !== 'production' && data && data.pre) {
                creatingElmInVPre--
              }
            } else if (isTrue(vnode.isComment)) {
              vnode.elm = nodeOps.createComment(vnode.text)
              insert(parentElm, vnode.elm, refElm)
            } else {
              vnode.elm = nodeOps.createTextNode(vnode.text)
              insert(parentElm, vnode.elm, refElm)
            }
          }

          function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
            var i = vnode.data
            if (isDef(i)) {
              var isReactivated = isDef(vnode.componentInstance) && i.keepAlive
              if (isDef(i = i.hook) && isDef(i = i.init)) {
                i(vnode, false /* hydrating */, parentElm, refElm)
              }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
              if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue)
                if (isTrue(isReactivated)) {
                  reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
                }
                return true
              }
            }
          }

          function initComponent (vnode, insertedVnodeQueue) {
            if (isDef(vnode.data.pendingInsert)) {
              insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)
              vnode.data.pendingInsert = null
            }
            vnode.elm = vnode.componentInstance.$el
            if (isPatchable(vnode)) {
              invokeCreateHooks(vnode, insertedVnodeQueue)
              setScope(vnode)
            } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
              registerRef(vnode)
      // make sure to invoke the insert hook
              insertedVnodeQueue.push(vnode)
            }
          }

          function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
            var i
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
            var innerNode = vnode
            while (innerNode.componentInstance) {
              innerNode = innerNode.componentInstance._vnode
              if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                for (i = 0; i < cbs.activate.length; ++i) {
                  cbs.activate[i](emptyNode, innerNode)
                }
                insertedVnodeQueue.push(innerNode)
                break
              }
            }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
            insert(parentElm, vnode.elm, refElm)
          }

          function insert (parent, elm, ref$$1) {
            if (isDef(parent)) {
              if (isDef(ref$$1)) {
                if (ref$$1.parentNode === parent) {
                  nodeOps.insertBefore(parent, elm, ref$$1)
                }
              } else {
                nodeOps.appendChild(parent, elm)
              }
            }
          }

          function createChildren (vnode, children, insertedVnodeQueue) {
            if (Array.isArray(children)) {
              for (var i = 0; i < children.length; ++i) {
                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true)
              }
            } else if (isPrimitive(vnode.text)) {
              nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text))
            }
          }

          function isPatchable (vnode) {
            while (vnode.componentInstance) {
              vnode = vnode.componentInstance._vnode
            }
            return isDef(vnode.tag)
          }

          function invokeCreateHooks (vnode, insertedVnodeQueue) {
            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
              cbs.create[i$1](emptyNode, vnode)
            }
            i = vnode.data.hook // Reuse variable
            if (isDef(i)) {
              if (isDef(i.create)) { i.create(emptyNode, vnode) }
              if (isDef(i.insert)) { insertedVnodeQueue.push(vnode) }
            }
          }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
          function setScope (vnode) {
            var i
            if (isDef(i = vnode.fnScopeId)) {
              nodeOps.setAttribute(vnode.elm, i, '')
            } else {
              var ancestor = vnode
              while (ancestor) {
                if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
                  nodeOps.setAttribute(vnode.elm, i, '')
                }
                ancestor = ancestor.parent
              }
            }
    // for slot content they should also get the scopeId from the host instance.
            if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
              nodeOps.setAttribute(vnode.elm, i, '')
            }
          }

          function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
              createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm)
            }
          }

          function invokeDestroyHook (vnode) {
            var i, j
            var data = vnode.data
            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode) }
              for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode) }
            }
            if (isDef(i = vnode.children)) {
              for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j])
              }
            }
          }

          function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
              var ch = vnodes[startIdx]
              if (isDef(ch)) {
                if (isDef(ch.tag)) {
                  removeAndInvokeRemoveHook(ch)
                  invokeDestroyHook(ch)
                } else { // Text node
                  removeNode(ch.elm)
                }
              }
            }
          }

          function removeAndInvokeRemoveHook (vnode, rm) {
            if (isDef(rm) || isDef(vnode.data)) {
              var i
              var listeners = cbs.remove.length + 1
              if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
                rm.listeners += listeners
              } else {
        // directly removing
                rm = createRmCb(vnode.elm, listeners)
              }
      // recursively invoke hooks on child component root node
              if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
                removeAndInvokeRemoveHook(i, rm)
              }
              for (i = 0; i < cbs.remove.length; ++i) {
                cbs.remove[i](vnode, rm)
              }
              if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                i(vnode, rm)
              } else {
                rm()
              }
            } else {
              removeNode(vnode.elm)
            }
          }

          function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
            var oldStartIdx = 0
            var newStartIdx = 0
            var oldEndIdx = oldCh.length - 1
            var oldStartVnode = oldCh[0]
            var oldEndVnode = oldCh[oldEndIdx]
            var newEndIdx = newCh.length - 1
            var newStartVnode = newCh[0]
            var newEndVnode = newCh[newEndIdx]
            var oldKeyToIdx, idxInOld, vnodeToMove, refElm

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
            var canMove = !removeOnly

            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
              if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
              } else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx]
              } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
                oldStartVnode = oldCh[++oldStartIdx]
                newStartVnode = newCh[++newStartIdx]
              } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
                oldEndVnode = oldCh[--oldEndIdx]
                newEndVnode = newCh[--newEndIdx]
              } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
                canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
                oldStartVnode = oldCh[++oldStartIdx]
                newEndVnode = newCh[--newEndIdx]
              } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
                canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
                oldEndVnode = oldCh[--oldEndIdx]
                newStartVnode = newCh[++newStartIdx]
              } else {
                if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) }
                idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
                if (isUndef(idxInOld)) { // New element
                  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)
                } else {
                  vnodeToMove = oldCh[idxInOld]
          /* istanbul ignore if */
                  if ('development' !== 'production' && !vnodeToMove) {
                    warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            )
                  }
                  if (sameVnode(vnodeToMove, newStartVnode)) {
                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
                    oldCh[idxInOld] = undefined
                    canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
                  } else {
            // same key but different element. treat as new element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)
                  }
                }
                newStartVnode = newCh[++newStartIdx]
              }
            }
            if (oldStartIdx > oldEndIdx) {
              refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
              addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
            } else if (newStartIdx > newEndIdx) {
              removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
            }
          }

          function findIdxInOld (node, oldCh, start, end) {
            for (var i = start; i < end; i++) {
              var c = oldCh[i]
              if (isDef(c) && sameVnode(node, c)) { return i }
            }
          }

          function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
            if (oldVnode === vnode) {
              return
            }

            var elm = vnode.elm = oldVnode.elm

            if (isTrue(oldVnode.isAsyncPlaceholder)) {
              if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
              } else {
                vnode.isAsyncPlaceholder = true
              }
              return
            }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
            if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
              vnode.componentInstance = oldVnode.componentInstance
              return
            }

            var i
            var data = vnode.data
            if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
              i(oldVnode, vnode)
            }

            var oldCh = oldVnode.children
            var ch = vnode.children
            if (isDef(data) && isPatchable(vnode)) {
              for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode) }
              if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode) }
            }
            if (isUndef(vnode.text)) {
              if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) }
              } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, '') }
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
              } else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1)
              } else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '')
              }
            } else if (oldVnode.text !== vnode.text) {
              nodeOps.setTextContent(elm, vnode.text)
            }
            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode) }
            }
          }

          function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
            if (isTrue(initial) && isDef(vnode.parent)) {
              vnode.parent.data.pendingInsert = queue
            } else {
              for (var i = 0; i < queue.length; ++i) {
                queue[i].data.hook.insert(queue[i])
              }
            }
          }

          var hydrationBailed = false
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
          var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key')

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
          function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
            var i
            var tag = vnode.tag
            var data = vnode.data
            var children = vnode.children
            inVPre = inVPre || (data && data.pre)
            vnode.elm = elm

            if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
              vnode.isAsyncPlaceholder = true
              return true
            }
    // assert node match
            {
              if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false
              }
            }
            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */) }
              if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue)
                return true
              }
            }
            if (isDef(tag)) {
              if (isDef(children)) {
        // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                  createChildren(vnode, children, insertedVnodeQueue)
                } else {
          // v-html and domProps: innerHTML
                  if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                    if (i !== elm.innerHTML) {
              /* istanbul ignore if */
                      if ('development' !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                        hydrationBailed = true
                        console.warn('Parent: ', elm)
                        console.warn('server innerHTML: ', i)
                        console.warn('client innerHTML: ', elm.innerHTML)
                      }
                      return false
                    }
                  } else {
            // iterate and compare children lists
                    var childrenMatch = true
                    var childNode = elm.firstChild
                    for (var i$1 = 0; i$1 < children.length; i$1++) {
                      if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                        childrenMatch = false
                        break
                      }
                      childNode = childNode.nextSibling
                    }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
                    if (!childrenMatch || childNode) {
              /* istanbul ignore if */
                      if ('development' !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                        hydrationBailed = true
                        console.warn('Parent: ', elm)
                        console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children)
                      }
                      return false
                    }
                  }
                }
              }
              if (isDef(data)) {
                var fullInvoke = false
                for (var key in data) {
                  if (!isRenderedModule(key)) {
                    fullInvoke = true
                    invokeCreateHooks(vnode, insertedVnodeQueue)
                    break
                  }
                }
                if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
                  traverse(data['class'])
                }
              }
            } else if (elm.data !== vnode.text) {
              elm.data = vnode.text
            }
            return true
          }

          function assertNodeMatch (node, vnode, inVPre) {
            if (isDef(vnode.tag)) {
              return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
            } else {
              return node.nodeType === (vnode.isComment ? 8 : 3)
            }
          }

          return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
            if (isUndef(vnode)) {
              if (isDef(oldVnode)) { invokeDestroyHook(oldVnode) }
              return
            }

            var isInitialPatch = false
            var insertedVnodeQueue = []

            if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
              isInitialPatch = true
              createElm(vnode, insertedVnodeQueue, parentElm, refElm)
            } else {
              var isRealElement = isDef(oldVnode.nodeType)
              if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
              } else {
                if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
                  if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                    oldVnode.removeAttribute(SSR_ATTR)
                    hydrating = true
                  }
                  if (isTrue(hydrating)) {
                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                      invokeInsertHook(vnode, insertedVnodeQueue, true)
                      return oldVnode
                    } else {
                      warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              )
                    }
                  }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
                  oldVnode = emptyNodeAt(oldVnode)
                }

        // replacing existing element
                var oldElm = oldVnode.elm
                var parentElm$1 = nodeOps.parentNode(oldElm)

        // create new node
                createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                  var ancestor = vnode.parent
                  var patchable = isPatchable(vnode)
                  while (ancestor) {
                    for (var i = 0; i < cbs.destroy.length; ++i) {
                      cbs.destroy[i](ancestor)
                    }
                    ancestor.elm = vnode.elm
                    if (patchable) {
                      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                        cbs.create[i$1](emptyNode, ancestor)
                      }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
                      var insert = ancestor.data.hook.insert
                      if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                        for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                          insert.fns[i$2]()
                        }
                      }
                    } else {
                      registerRef(ancestor)
                    }
                    ancestor = ancestor.parent
                  }
                }

        // destroy old node
                if (isDef(parentElm$1)) {
                  removeVnodes(parentElm$1, [oldVnode], 0, 0)
                } else if (isDef(oldVnode.tag)) {
                  invokeDestroyHook(oldVnode)
                }
              }
            }

            invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
            return vnode.elm
          }
        }

/*  */

        var directives = {
          create: updateDirectives,
          update: updateDirectives,
          destroy: function unbindDirectives (vnode) {
            updateDirectives(vnode, emptyNode)
          }
        }

        function updateDirectives (oldVnode, vnode) {
          if (oldVnode.data.directives || vnode.data.directives) {
            _update(oldVnode, vnode)
          }
        }

        function _update (oldVnode, vnode) {
          var isCreate = oldVnode === emptyNode
          var isDestroy = vnode === emptyNode
          var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context)
          var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context)

          var dirsWithInsert = []
          var dirsWithPostpatch = []

          var key, oldDir, dir
          for (key in newDirs) {
            oldDir = oldDirs[key]
            dir = newDirs[key]
            if (!oldDir) {
      // new directive, bind
              callHook$1(dir, 'bind', vnode, oldVnode)
              if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir)
              }
            } else {
      // existing directive, update
              dir.oldValue = oldDir.value
              callHook$1(dir, 'update', vnode, oldVnode)
              if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir)
              }
            }
          }

          if (dirsWithInsert.length) {
            var callInsert = function () {
              for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode)
              }
            }
            if (isCreate) {
              mergeVNodeHook(vnode, 'insert', callInsert)
            } else {
              callInsert()
            }
          }

          if (dirsWithPostpatch.length) {
            mergeVNodeHook(vnode, 'postpatch', function () {
              for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)
              }
            })
          }

          if (!isCreate) {
            for (key in oldDirs) {
              if (!newDirs[key]) {
        // no longer present, unbind
                callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)
              }
            }
          }
        }

        var emptyModifiers = Object.create(null)

        function normalizeDirectives$1 (
  dirs,
  vm
) {
          var res = Object.create(null)
          if (!dirs) {
            return res
          }
          var i, dir
          for (i = 0; i < dirs.length; i++) {
            dir = dirs[i]
            if (!dir.modifiers) {
              dir.modifiers = emptyModifiers
            }
            res[getRawDirName(dir)] = dir
            dir.def = resolveAsset(vm.$options, 'directives', dir.name, true)
          }
          return res
        }

        function getRawDirName (dir) {
          return dir.rawName || ((dir.name) + '.' + (Object.keys(dir.modifiers || {}).join('.')))
        }

        function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
          var fn = dir.def && dir.def[hook]
          if (fn) {
            try {
              fn(vnode.elm, dir, vnode, oldVnode, isDestroy)
            } catch (e) {
              handleError(e, vnode.context, ('directive ' + (dir.name) + ' ' + hook + ' hook'))
            }
          }
        }

        var baseModules = [
          ref,
          directives
        ]

/*  */

        function updateAttrs (oldVnode, vnode) {
          var opts = vnode.componentOptions
          if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
            return
          }
          if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
            return
          }
          var key, cur, old
          var elm = vnode.elm
          var oldAttrs = oldVnode.data.attrs || {}
          var attrs = vnode.data.attrs || {}
  // clone observed objects, as the user probably wants to mutate it
          if (isDef(attrs.__ob__)) {
            attrs = vnode.data.attrs = extend({}, attrs)
          }

          for (key in attrs) {
            cur = attrs[key]
            old = oldAttrs[key]
            if (old !== cur) {
              setAttr(elm, key, cur)
            }
          }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
          if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
            setAttr(elm, 'value', attrs.value)
          }
          for (key in oldAttrs) {
            if (isUndef(attrs[key])) {
              if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key))
              } else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key)
              }
            }
          }
        }

        function setAttr (el, key, value) {
          if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
            if (isFalsyAttrValue(value)) {
              el.removeAttribute(key)
            } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
              value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key
              el.setAttribute(key, value)
            }
          } else if (isEnumeratedAttr(key)) {
            el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true')
          } else if (isXlink(key)) {
            if (isFalsyAttrValue(value)) {
              el.removeAttributeNS(xlinkNS, getXlinkProp(key))
            } else {
              el.setAttributeNS(xlinkNS, key, value)
            }
          } else {
            if (isFalsyAttrValue(value)) {
              el.removeAttribute(key)
            } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
              if (
        isIE && !isIE9 &&
        el.tagName === 'TEXTAREA' &&
        key === 'placeholder' && !el.__ieph
      ) {
                var blocker = function (e) {
                  e.stopImmediatePropagation()
                  el.removeEventListener('input', blocker)
                }
                el.addEventListener('input', blocker)
        // $flow-disable-line
                el.__ieph = true /* IE placeholder patched */
              }
              el.setAttribute(key, value)
            }
          }
        }

        var attrs = {
          create: updateAttrs,
          update: updateAttrs
        }

/*  */

        function updateClass (oldVnode, vnode) {
          var el = vnode.elm
          var data = vnode.data
          var oldData = oldVnode.data
          if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
            return
          }

          var cls = genClassForVnode(vnode)

  // handle transition classes
          var transitionClass = el._transitionClasses
          if (isDef(transitionClass)) {
            cls = concat(cls, stringifyClass(transitionClass))
          }

  // set the class
          if (cls !== el._prevClass) {
            el.setAttribute('class', cls)
            el._prevClass = cls
          }
        }

        var klass = {
          create: updateClass,
          update: updateClass
        }

/*  */

        var validDivisionCharRE = /[\w).+\-_$\]]/

        function parseFilters (exp) {
          var inSingle = false
          var inDouble = false
          var inTemplateString = false
          var inRegex = false
          var curly = 0
          var square = 0
          var paren = 0
          var lastFilterIndex = 0
          var c, prev, i, expression, filters

          for (i = 0; i < exp.length; i++) {
            prev = c
            c = exp.charCodeAt(i)
            if (inSingle) {
              if (c === 0x27 && prev !== 0x5C) { inSingle = false }
            } else if (inDouble) {
              if (c === 0x22 && prev !== 0x5C) { inDouble = false }
            } else if (inTemplateString) {
              if (c === 0x60 && prev !== 0x5C) { inTemplateString = false }
            } else if (inRegex) {
              if (c === 0x2f && prev !== 0x5C) { inRegex = false }
            } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
              if (expression === undefined) {
        // first filter, end of expression
                lastFilterIndex = i + 1
                expression = exp.slice(0, i).trim()
              } else {
                pushFilter()
              }
            } else {
              switch (c) {
                case 0x22: inDouble = true; break         // "
                case 0x27: inSingle = true; break         // '
                case 0x60: inTemplateString = true; break // `
                case 0x28: paren++; break                 // (
                case 0x29: paren--; break                 // )
                case 0x5B: square++; break                // [
                case 0x5D: square--; break                // ]
                case 0x7B: curly++; break                 // {
                case 0x7D: curly--; break                 // }
              }
              if (c === 0x2f) { // /
                var j = i - 1
                var p = (void 0)
        // find first non-whitespace prev char
                for (; j >= 0; j--) {
                  p = exp.charAt(j)
                  if (p !== ' ') { break }
                }
                if (!p || !validDivisionCharRE.test(p)) {
                  inRegex = true
                }
              }
            }
          }

          if (expression === undefined) {
            expression = exp.slice(0, i).trim()
          } else if (lastFilterIndex !== 0) {
            pushFilter()
          }

          function pushFilter () {
            (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
            lastFilterIndex = i + 1
          }

          if (filters) {
            for (i = 0; i < filters.length; i++) {
              expression = wrapFilter(expression, filters[i])
            }
          }

          return expression
        }

        function wrapFilter (exp, filter) {
          var i = filter.indexOf('(')
          if (i < 0) {
    // _f: resolveFilter
            return ('_f("' + filter + '")(' + exp + ')')
          } else {
            var name = filter.slice(0, i)
            var args = filter.slice(i + 1)
            return ('_f("' + name + '")(' + exp + ',' + args)
          }
        }

/*  */

        function baseWarn (msg) {
          console.error(('[Vue compiler]: ' + msg))
        }

        function pluckModuleFunction (
  modules,
  key
) {
          return modules
    ? modules.map(function (m) { return m[key] }).filter(function (_) { return _ })
    : []
        }

        function addProp (el, name, value) {
          (el.props || (el.props = [])).push({ name: name, value: value })
        }

        function addAttr (el, name, value) {
          (el.attrs || (el.attrs = [])).push({ name: name, value: value })
        }

        function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
          (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers })
        }

        function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
          modifiers = modifiers || emptyObject
  // warn prevent and passive modifier
  /* istanbul ignore if */
          if (
    'development' !== 'production' && warn &&
    modifiers.prevent && modifiers.passive
  ) {
            warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    )
          }

  // check capture modifier
          if (modifiers.capture) {
            delete modifiers.capture
            name = '!' + name // mark the event as captured
          }
          if (modifiers.once) {
            delete modifiers.once
            name = '~' + name // mark the event as once
          }
  /* istanbul ignore if */
          if (modifiers.passive) {
            delete modifiers.passive
            name = '&' + name // mark the event as passive
          }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
          if (name === 'click') {
            if (modifiers.right) {
              name = 'contextmenu'
              delete modifiers.right
            } else if (modifiers.middle) {
              name = 'mouseup'
            }
          }

          var events
          if (modifiers.native) {
            delete modifiers.native
            events = el.nativeEvents || (el.nativeEvents = {})
          } else {
            events = el.events || (el.events = {})
          }

          var newHandler = { value: value }
          if (modifiers !== emptyObject) {
            newHandler.modifiers = modifiers
          }

          var handlers = events[name]
  /* istanbul ignore if */
          if (Array.isArray(handlers)) {
            important ? handlers.unshift(newHandler) : handlers.push(newHandler)
          } else if (handlers) {
            events[name] = important ? [newHandler, handlers] : [handlers, newHandler]
          } else {
            events[name] = newHandler
          }
        }

        function getBindingAttr (
  el,
  name,
  getStatic
) {
          var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name)
          if (dynamicValue != null) {
            return parseFilters(dynamicValue)
          } else if (getStatic !== false) {
            var staticValue = getAndRemoveAttr(el, name)
            if (staticValue != null) {
              return JSON.stringify(staticValue)
            }
          }
        }

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
        function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
          var val
          if ((val = el.attrsMap[name]) != null) {
            var list = el.attrsList
            for (var i = 0, l = list.length; i < l; i++) {
              if (list[i].name === name) {
                list.splice(i, 1)
                break
              }
            }
          }
          if (removeFromMap) {
            delete el.attrsMap[name]
          }
          return val
        }

/*  */

/**
 * Cross-platform code generation for component v-model
 */
        function genComponentModel (
  el,
  value,
  modifiers
) {
          var ref = modifiers || {}
          var number = ref.number
          var trim = ref.trim

          var baseValueExpression = '$$v'
          var valueExpression = baseValueExpression
          if (trim) {
            valueExpression =
      '(typeof ' + baseValueExpression + " === 'string'" +
        '? ' + baseValueExpression + '.trim()' +
        ': ' + baseValueExpression + ')'
          }
          if (number) {
            valueExpression = '_n(' + valueExpression + ')'
          }
          var assignment = genAssignmentCode(value, valueExpression)

          el.model = {
            value: ('(' + value + ')'),
            expression: ('"' + value + '"'),
            callback: ('function (' + baseValueExpression + ') {' + assignment + '}')
          }
        }

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
        function genAssignmentCode (
  value,
  assignment
) {
          var res = parseModel(value)
          if (res.key === null) {
            return (value + '=' + assignment)
          } else {
            return ('$set(' + (res.exp) + ', ' + (res.key) + ', ' + assignment + ')')
          }
        }

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

        var len
        var str
        var chr
        var index$1
        var expressionPos
        var expressionEndPos

        function parseModel (val) {
          len = val.length

          if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
            index$1 = val.lastIndexOf('.')
            if (index$1 > -1) {
              return {
                exp: val.slice(0, index$1),
                key: '"' + val.slice(index$1 + 1) + '"'
              }
            } else {
              return {
                exp: val,
                key: null
              }
            }
          }

          str = val
          index$1 = expressionPos = expressionEndPos = 0

          while (!eof()) {
            chr = next()
    /* istanbul ignore if */
            if (isStringStart(chr)) {
              parseString(chr)
            } else if (chr === 0x5B) {
              parseBracket(chr)
            }
          }

          return {
            exp: val.slice(0, expressionPos),
            key: val.slice(expressionPos + 1, expressionEndPos)
          }
        }

        function next () {
          return str.charCodeAt(++index$1)
        }

        function eof () {
          return index$1 >= len
        }

        function isStringStart (chr) {
          return chr === 0x22 || chr === 0x27
        }

        function parseBracket (chr) {
          var inBracket = 1
          expressionPos = index$1
          while (!eof()) {
            chr = next()
            if (isStringStart(chr)) {
              parseString(chr)
              continue
            }
            if (chr === 0x5B) { inBracket++ }
            if (chr === 0x5D) { inBracket-- }
            if (inBracket === 0) {
              expressionEndPos = index$1
              break
            }
          }
        }

        function parseString (chr) {
          var stringQuote = chr
          while (!eof()) {
            chr = next()
            if (chr === stringQuote) {
              break
            }
          }
        }

/*  */

        var warn$1

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
        var RANGE_TOKEN = '__r'
        var CHECKBOX_RADIO_TOKEN = '__c'

        function model (
  el,
  dir,
  _warn
) {
          warn$1 = _warn
          var value = dir.value
          var modifiers = dir.modifiers
          var tag = el.tag
          var type = el.attrsMap.type

          {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
            if (tag === 'input' && type === 'file') {
              warn$1(
        '<' + (el.tag) + ' v-model="' + value + '" type="file">:\n' +
        'File inputs are read only. Use a v-on:change listener instead.'
      )
            }
          }

          if (el.component) {
            genComponentModel(el, value, modifiers)
    // component v-model doesn't need extra runtime
            return false
          } else if (tag === 'select') {
            genSelect(el, value, modifiers)
          } else if (tag === 'input' && type === 'checkbox') {
            genCheckboxModel(el, value, modifiers)
          } else if (tag === 'input' && type === 'radio') {
            genRadioModel(el, value, modifiers)
          } else if (tag === 'input' || tag === 'textarea') {
            genDefaultModel(el, value, modifiers)
          } else if (!config.isReservedTag(tag)) {
            genComponentModel(el, value, modifiers)
    // component v-model doesn't need extra runtime
            return false
          } else {
            warn$1(
      '<' + (el.tag) + ' v-model="' + value + '">: ' +
      'v-model is not supported on this element type. ' +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    )
          }

  // ensure runtime directive metadata
          return true
        }

        function genCheckboxModel (
  el,
  value,
  modifiers
) {
          var number = modifiers && modifiers.number
          var valueBinding = getBindingAttr(el, 'value') || 'null'
          var trueValueBinding = getBindingAttr(el, 'true-value') || 'true'
          var falseValueBinding = getBindingAttr(el, 'false-value') || 'false'
          addProp(el, 'checked',
    'Array.isArray(' + value + ')' +
      '?_i(' + value + ',' + valueBinding + ')>-1' + (
        trueValueBinding === 'true'
          ? (':(' + value + ')')
          : (':_q(' + value + ',' + trueValueBinding + ')')
      )
  )
          addHandler(el, 'change',
    'var $$a=' + value + ',' +
        '$$el=$event.target,' +
        '$$c=$$el.checked?(' + trueValueBinding + '):(' + falseValueBinding + ');' +
    'if(Array.isArray($$a)){' +
      'var $$v=' + (number ? '_n(' + valueBinding + ')' : valueBinding) + ',' +
          '$$i=_i($$a,$$v);' +
      'if($$el.checked){$$i<0&&(' + value + '=$$a.concat([$$v]))}' +
      'else{$$i>-1&&(' + value + '=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}' +
    '}else{' + (genAssignmentCode(value, '$$c')) + '}',
    null, true
  )
        }

        function genRadioModel (
    el,
    value,
    modifiers
) {
          var number = modifiers && modifiers.number
          var valueBinding = getBindingAttr(el, 'value') || 'null'
          valueBinding = number ? ('_n(' + valueBinding + ')') : valueBinding
          addProp(el, 'checked', ('_q(' + value + ',' + valueBinding + ')'))
          addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true)
        }

        function genSelect (
    el,
    value,
    modifiers
) {
          var number = modifiers && modifiers.number
          var selectedVal = 'Array.prototype.filter' +
    '.call($event.target.options,function(o){return o.selected})' +
    '.map(function(o){var val = "_value" in o ? o._value : o.value;' +
    'return ' + (number ? '_n(val)' : 'val') + '})'

          var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]'
          var code = 'var $$selectedVal = ' + selectedVal + ';'
          code = code + ' ' + (genAssignmentCode(value, assignment))
          addHandler(el, 'change', code, null, true)
        }

        function genDefaultModel (
  el,
  value,
  modifiers
) {
          var type = el.attrsMap.type

  // warn if v-bind:value conflicts with v-model
          {
            var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value']
            if (value$1) {
              var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value'
              warn$1(
        binding + '="' + value$1 + '" conflicts with v-model on the same element ' +
        'because the latter already expands to a value binding internally'
      )
            }
          }

          var ref = modifiers || {}
          var lazy = ref.lazy
          var number = ref.number
          var trim = ref.trim
          var needCompositionGuard = !lazy && type !== 'range'
          var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input'

          var valueExpression = '$event.target.value'
          if (trim) {
            valueExpression = '$event.target.value.trim()'
          }
          if (number) {
            valueExpression = '_n(' + valueExpression + ')'
          }

          var code = genAssignmentCode(value, valueExpression)
          if (needCompositionGuard) {
            code = 'if($event.target.composing)return;' + code
          }

          addProp(el, 'value', ('(' + value + ')'))
          addHandler(el, event, code, null, true)
          if (trim || number) {
            addHandler(el, 'blur', '$forceUpdate()')
          }
        }

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
        function normalizeEvents (on) {
  /* istanbul ignore if */
          if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
            var event = isIE ? 'change' : 'input'
            on[event] = [].concat(on[RANGE_TOKEN], on[event] || [])
            delete on[RANGE_TOKEN]
          }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
          if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
            on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || [])
            delete on[CHECKBOX_RADIO_TOKEN]
          }
        }

        var target$1

        function createOnceHandler (handler, event, capture) {
          var _target = target$1 // save current target element in closure
          return function onceHandler () {
            var res = handler.apply(null, arguments)
            if (res !== null) {
              remove$2(event, onceHandler, capture, _target)
            }
          }
        }

        function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
          handler = withMacroTask(handler)
          if (once$$1) { handler = createOnceHandler(handler, event, capture) }
          target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  )
        }

        function remove$2 (
  event,
  handler,
  capture,
  _target
) {
          (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  )
        }

        function updateDOMListeners (oldVnode, vnode) {
          if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
            return
          }
          var on = vnode.data.on || {}
          var oldOn = oldVnode.data.on || {}
          target$1 = vnode.elm
          normalizeEvents(on)
          updateListeners(on, oldOn, add$1, remove$2, vnode.context)
          target$1 = undefined
        }

        var events = {
          create: updateDOMListeners,
          update: updateDOMListeners
        }

/*  */

        function updateDOMProps (oldVnode, vnode) {
          if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
            return
          }
          var key, cur
          var elm = vnode.elm
          var oldProps = oldVnode.data.domProps || {}
          var props = vnode.data.domProps || {}
  // clone observed objects, as the user probably wants to mutate it
          if (isDef(props.__ob__)) {
            props = vnode.data.domProps = extend({}, props)
          }

          for (key in oldProps) {
            if (isUndef(props[key])) {
              elm[key] = ''
            }
          }
          for (key in props) {
            cur = props[key]
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
            if (key === 'textContent' || key === 'innerHTML') {
              if (vnode.children) { vnode.children.length = 0 }
              if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
              if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0])
              }
            }

            if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
              elm._value = cur
      // avoid resetting cursor position when value is the same
              var strCur = isUndef(cur) ? '' : String(cur)
              if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur
              }
            } else {
              elm[key] = cur
            }
          }
        }

// check platforms/web/util/attrs.js acceptValue

        function shouldUpdateValue (elm, checkVal) {
          return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isDirty(elm, checkVal) ||
    isInputChanged(elm, checkVal)
  ))
        }

        function isDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
          var notInFocus = true
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
          try { notInFocus = document.activeElement !== elm } catch (e) {}
          return notInFocus && elm.value !== checkVal
        }

        function isInputChanged (elm, newVal) {
          var value = elm.value
          var modifiers = elm._vModifiers // injected by v-model runtime
          if (isDef(modifiers) && modifiers.number) {
            return toNumber(value) !== toNumber(newVal)
          }
          if (isDef(modifiers) && modifiers.trim) {
            return value.trim() !== newVal.trim()
          }
          return value !== newVal
        }

        var domProps = {
          create: updateDOMProps,
          update: updateDOMProps
        }

/*  */

        var parseStyleText = cached(function (cssText) {
          var res = {}
          var listDelimiter = /;(?![^(]*\))/g
          var propertyDelimiter = /:(.+)/
          cssText.split(listDelimiter).forEach(function (item) {
            if (item) {
              var tmp = item.split(propertyDelimiter)
              tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim())
            }
          })
          return res
        })

// merge static and dynamic style data on the same vnode
        function normalizeStyleData (data) {
          var style = normalizeStyleBinding(data.style)
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
          return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
        }

// normalize possible array / string values into Object
        function normalizeStyleBinding (bindingStyle) {
          if (Array.isArray(bindingStyle)) {
            return toObject(bindingStyle)
          }
          if (typeof bindingStyle === 'string') {
            return parseStyleText(bindingStyle)
          }
          return bindingStyle
        }

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
        function getStyle (vnode, checkChild) {
          var res = {}
          var styleData

          if (checkChild) {
            var childNode = vnode
            while (childNode.componentInstance) {
              childNode = childNode.componentInstance._vnode
              if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData)
              }
            }
          }

          if ((styleData = normalizeStyleData(vnode.data))) {
            extend(res, styleData)
          }

          var parentNode = vnode
          while ((parentNode = parentNode.parent)) {
            if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
              extend(res, styleData)
            }
          }
          return res
        }

/*  */

        var cssVarRE = /^--/
        var importantRE = /\s*!important$/
        var setProp = function (el, name, val) {
  /* istanbul ignore if */
          if (cssVarRE.test(name)) {
            el.style.setProperty(name, val)
          } else if (importantRE.test(val)) {
            el.style.setProperty(name, val.replace(importantRE, ''), 'important')
          } else {
            var normalizedName = normalize(name)
            if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
              for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i]
              }
            } else {
              el.style[normalizedName] = val
            }
          }
        }

        var vendorNames = ['Webkit', 'Moz', 'ms']

        var emptyStyle
        var normalize = cached(function (prop) {
          emptyStyle = emptyStyle || document.createElement('div').style
          prop = camelize(prop)
          if (prop !== 'filter' && (prop in emptyStyle)) {
            return prop
          }
          var capName = prop.charAt(0).toUpperCase() + prop.slice(1)
          for (var i = 0; i < vendorNames.length; i++) {
            var name = vendorNames[i] + capName
            if (name in emptyStyle) {
              return name
            }
          }
        })

        function updateStyle (oldVnode, vnode) {
          var data = vnode.data
          var oldData = oldVnode.data

          if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
            return
          }

          var cur, name
          var el = vnode.elm
          var oldStaticStyle = oldData.staticStyle
          var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
          var oldStyle = oldStaticStyle || oldStyleBinding

          var style = normalizeStyleBinding(vnode.data.style) || {}

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
          vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style

          var newStyle = getStyle(vnode, true)

          for (name in oldStyle) {
            if (isUndef(newStyle[name])) {
              setProp(el, name, '')
            }
          }
          for (name in newStyle) {
            cur = newStyle[name]
            if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
              setProp(el, name, cur == null ? '' : cur)
            }
          }
        }

        var style = {
          create: updateStyle,
          update: updateStyle
        }

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
        function addClass (el, cls) {
  /* istanbul ignore if */
          if (!cls || !(cls = cls.trim())) {
            return
          }

  /* istanbul ignore else */
          if (el.classList) {
            if (cls.indexOf(' ') > -1) {
              cls.split(/\s+/).forEach(function (c) { return el.classList.add(c) })
            } else {
              el.classList.add(cls)
            }
          } else {
            var cur = ' ' + (el.getAttribute('class') || '') + ' '
            if (cur.indexOf(' ' + cls + ' ') < 0) {
              el.setAttribute('class', (cur + cls).trim())
            }
          }
        }

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
        function removeClass (el, cls) {
  /* istanbul ignore if */
          if (!cls || !(cls = cls.trim())) {
            return
          }

  /* istanbul ignore else */
          if (el.classList) {
            if (cls.indexOf(' ') > -1) {
              cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c) })
            } else {
              el.classList.remove(cls)
            }
            if (!el.classList.length) {
              el.removeAttribute('class')
            }
          } else {
            var cur = ' ' + (el.getAttribute('class') || '') + ' '
            var tar = ' ' + cls + ' '
            while (cur.indexOf(tar) >= 0) {
              cur = cur.replace(tar, ' ')
            }
            cur = cur.trim()
            if (cur) {
              el.setAttribute('class', cur)
            } else {
              el.removeAttribute('class')
            }
          }
        }

/*  */

        function resolveTransition (def) {
          if (!def) {
            return
          }
  /* istanbul ignore else */
          if (typeof def === 'object') {
            var res = {}
            if (def.css !== false) {
              extend(res, autoCssTransition(def.name || 'v'))
            }
            extend(res, def)
            return res
          } else if (typeof def === 'string') {
            return autoCssTransition(def)
          }
        }

        var autoCssTransition = cached(function (name) {
          return {
            enterClass: (name + '-enter'),
            enterToClass: (name + '-enter-to'),
            enterActiveClass: (name + '-enter-active'),
            leaveClass: (name + '-leave'),
            leaveToClass: (name + '-leave-to'),
            leaveActiveClass: (name + '-leave-active')
          }
        })

        var hasTransition = inBrowser && !isIE9
        var TRANSITION = 'transition'
        var ANIMATION = 'animation'

// Transition property/event sniffing
        var transitionProp = 'transition'
        var transitionEndEvent = 'transitionend'
        var animationProp = 'animation'
        var animationEndEvent = 'animationend'
        if (hasTransition) {
  /* istanbul ignore if */
          if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
            transitionProp = 'WebkitTransition'
            transitionEndEvent = 'webkitTransitionEnd'
          }
          if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
            animationProp = 'WebkitAnimation'
            animationEndEvent = 'webkitAnimationEnd'
          }
        }

// binding to window is necessary to make hot reload work in IE in strict mode
        var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn() }

        function nextFrame (fn) {
          raf(function () {
            raf(fn)
          })
        }

        function addTransitionClass (el, cls) {
          var transitionClasses = el._transitionClasses || (el._transitionClasses = [])
          if (transitionClasses.indexOf(cls) < 0) {
            transitionClasses.push(cls)
            addClass(el, cls)
          }
        }

        function removeTransitionClass (el, cls) {
          if (el._transitionClasses) {
            remove(el._transitionClasses, cls)
          }
          removeClass(el, cls)
        }

        function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
          var ref = getTransitionInfo(el, expectedType)
          var type = ref.type
          var timeout = ref.timeout
          var propCount = ref.propCount
          if (!type) { return cb() }
          var event = type === TRANSITION ? transitionEndEvent : animationEndEvent
          var ended = 0
          var end = function () {
            el.removeEventListener(event, onEnd)
            cb()
          }
          var onEnd = function (e) {
            if (e.target === el) {
              if (++ended >= propCount) {
                end()
              }
            }
          }
          setTimeout(function () {
            if (ended < propCount) {
              end()
            }
          }, timeout + 1)
          el.addEventListener(event, onEnd)
        }

        var transformRE = /\b(transform|all)(,|$)/

        function getTransitionInfo (el, expectedType) {
          var styles = window.getComputedStyle(el)
          var transitionDelays = styles[transitionProp + 'Delay'].split(', ')
          var transitionDurations = styles[transitionProp + 'Duration'].split(', ')
          var transitionTimeout = getTimeout(transitionDelays, transitionDurations)
          var animationDelays = styles[animationProp + 'Delay'].split(', ')
          var animationDurations = styles[animationProp + 'Duration'].split(', ')
          var animationTimeout = getTimeout(animationDelays, animationDurations)

          var type
          var timeout = 0
          var propCount = 0
  /* istanbul ignore if */
          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION
              timeout = transitionTimeout
              propCount = transitionDurations.length
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION
              timeout = animationTimeout
              propCount = animationDurations.length
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout)
            type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null
            propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0
          }
          var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property'])
          return {
            type: type,
            timeout: timeout,
            propCount: propCount,
            hasTransform: hasTransform
          }
        }

        function getTimeout (delays, durations) {
  /* istanbul ignore next */
          while (delays.length < durations.length) {
            delays = delays.concat(delays)
          }

          return Math.max.apply(null, durations.map(function (d, i) {
            return toMs(d) + toMs(delays[i])
          }))
        }

        function toMs (s) {
          return Number(s.slice(0, -1)) * 1000
        }

/*  */

        function enter (vnode, toggleDisplay) {
          var el = vnode.elm

  // call leave callback now
          if (isDef(el._leaveCb)) {
            el._leaveCb.cancelled = true
            el._leaveCb()
          }

          var data = resolveTransition(vnode.data.transition)
          if (isUndef(data)) {
            return
          }

  /* istanbul ignore if */
          if (isDef(el._enterCb) || el.nodeType !== 1) {
            return
          }

          var css = data.css
          var type = data.type
          var enterClass = data.enterClass
          var enterToClass = data.enterToClass
          var enterActiveClass = data.enterActiveClass
          var appearClass = data.appearClass
          var appearToClass = data.appearToClass
          var appearActiveClass = data.appearActiveClass
          var beforeEnter = data.beforeEnter
          var enter = data.enter
          var afterEnter = data.afterEnter
          var enterCancelled = data.enterCancelled
          var beforeAppear = data.beforeAppear
          var appear = data.appear
          var afterAppear = data.afterAppear
          var appearCancelled = data.appearCancelled
          var duration = data.duration

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
          var context = activeInstance
          var transitionNode = activeInstance.$vnode
          while (transitionNode && transitionNode.parent) {
            transitionNode = transitionNode.parent
            context = transitionNode.context
          }

          var isAppear = !context._isMounted || !vnode.isRootInsert

          if (isAppear && !appear && appear !== '') {
            return
          }

          var startClass = isAppear && appearClass
    ? appearClass
    : enterClass
          var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass
          var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass

          var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter
          var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter
          var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter
          var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled

          var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  )

          if ('development' !== 'production' && explicitEnterDuration != null) {
            checkDuration(explicitEnterDuration, 'enter', vnode)
          }

          var expectsCSS = css !== false && !isIE9
          var userWantsControl = getHookArgumentsLength(enterHook)

          var cb = el._enterCb = once(function () {
            if (expectsCSS) {
              removeTransitionClass(el, toClass)
              removeTransitionClass(el, activeClass)
            }
            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, startClass)
              }
              enterCancelledHook && enterCancelledHook(el)
            } else {
              afterEnterHook && afterEnterHook(el)
            }
            el._enterCb = null
          })

          if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
            mergeVNodeHook(vnode, 'insert', function () {
              var parent = el.parentNode
              var pendingNode = parent && parent._pending && parent._pending[vnode.key]
              if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
                pendingNode.elm._leaveCb()
              }
              enterHook && enterHook(el, cb)
            })
          }

  // start enter transition
          beforeEnterHook && beforeEnterHook(el)
          if (expectsCSS) {
            addTransitionClass(el, startClass)
            addTransitionClass(el, activeClass)
            nextFrame(function () {
              addTransitionClass(el, toClass)
              removeTransitionClass(el, startClass)
              if (!cb.cancelled && !userWantsControl) {
                if (isValidDuration(explicitEnterDuration)) {
                  setTimeout(cb, explicitEnterDuration)
                } else {
                  whenTransitionEnds(el, type, cb)
                }
              }
            })
          }

          if (vnode.data.show) {
            toggleDisplay && toggleDisplay()
            enterHook && enterHook(el, cb)
          }

          if (!expectsCSS && !userWantsControl) {
            cb()
          }
        }

        function leave (vnode, rm) {
          var el = vnode.elm

  // call enter callback now
          if (isDef(el._enterCb)) {
            el._enterCb.cancelled = true
            el._enterCb()
          }

          var data = resolveTransition(vnode.data.transition)
          if (isUndef(data) || el.nodeType !== 1) {
            return rm()
          }

  /* istanbul ignore if */
          if (isDef(el._leaveCb)) {
            return
          }

          var css = data.css
          var type = data.type
          var leaveClass = data.leaveClass
          var leaveToClass = data.leaveToClass
          var leaveActiveClass = data.leaveActiveClass
          var beforeLeave = data.beforeLeave
          var leave = data.leave
          var afterLeave = data.afterLeave
          var leaveCancelled = data.leaveCancelled
          var delayLeave = data.delayLeave
          var duration = data.duration

          var expectsCSS = css !== false && !isIE9
          var userWantsControl = getHookArgumentsLength(leave)

          var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  )

          if ('development' !== 'production' && isDef(explicitLeaveDuration)) {
            checkDuration(explicitLeaveDuration, 'leave', vnode)
          }

          var cb = el._leaveCb = once(function () {
            if (el.parentNode && el.parentNode._pending) {
              el.parentNode._pending[vnode.key] = null
            }
            if (expectsCSS) {
              removeTransitionClass(el, leaveToClass)
              removeTransitionClass(el, leaveActiveClass)
            }
            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, leaveClass)
              }
              leaveCancelled && leaveCancelled(el)
            } else {
              rm()
              afterLeave && afterLeave(el)
            }
            el._leaveCb = null
          })

          if (delayLeave) {
            delayLeave(performLeave)
          } else {
            performLeave()
          }

          function performLeave () {
    // the delayed leave may have already been cancelled
            if (cb.cancelled) {
              return
            }
    // record leaving element
            if (!vnode.data.show) {
              (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode
            }
            beforeLeave && beforeLeave(el)
            if (expectsCSS) {
              addTransitionClass(el, leaveClass)
              addTransitionClass(el, leaveActiveClass)
              nextFrame(function () {
                addTransitionClass(el, leaveToClass)
                removeTransitionClass(el, leaveClass)
                if (!cb.cancelled && !userWantsControl) {
                  if (isValidDuration(explicitLeaveDuration)) {
                    setTimeout(cb, explicitLeaveDuration)
                  } else {
                    whenTransitionEnds(el, type, cb)
                  }
                }
              })
            }
            leave && leave(el, cb)
            if (!expectsCSS && !userWantsControl) {
              cb()
            }
          }
        }

// only used in dev mode
        function checkDuration (val, name, vnode) {
          if (typeof val !== 'number') {
            warn(
      '<transition> explicit ' + name + ' duration is not a valid number - ' +
      'got ' + (JSON.stringify(val)) + '.',
      vnode.context
    )
          } else if (isNaN(val)) {
            warn(
      '<transition> explicit ' + name + ' duration is NaN - ' +
      'the duration expression might be incorrect.',
      vnode.context
    )
          }
        }

        function isValidDuration (val) {
          return typeof val === 'number' && !isNaN(val)
        }

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
        function getHookArgumentsLength (fn) {
          if (isUndef(fn)) {
            return false
          }
          var invokerFns = fn.fns
          if (isDef(invokerFns)) {
    // invoker
            return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
          } else {
            return (fn._length || fn.length) > 1
          }
        }

        function _enter (_, vnode) {
          if (vnode.data.show !== true) {
            enter(vnode)
          }
        }

        var transition = inBrowser ? {
          create: _enter,
          activate: _enter,
          remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
            if (vnode.data.show !== true) {
              leave(vnode, rm)
            } else {
              rm()
            }
          }
        } : {}

        var platformModules = [
          attrs,
          klass,
          events,
          domProps,
          style,
          transition
        ]

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
        var modules = platformModules.concat(baseModules)

        var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules })

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
        if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
          document.addEventListener('selectionchange', function () {
            var el = document.activeElement
            if (el && el.vmodel) {
              trigger(el, 'input')
            }
          })
        }

        var directive = {
          inserted: function inserted (el, binding, vnode, oldVnode) {
            if (vnode.tag === 'select') {
      // #6903
              if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                  directive.componentUpdated(el, binding, vnode)
                })
              } else {
                setSelected(el, binding, vnode.context)
              }
              el._vOptions = [].map.call(el.options, getValue)
            } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
              el._vModifiers = binding.modifiers
              if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd)
                if (!isAndroid) {
                  el.addEventListener('compositionstart', onCompositionStart)
                  el.addEventListener('compositionend', onCompositionEnd)
                }
        /* istanbul ignore if */
                if (isIE9) {
                  el.vmodel = true
                }
              }
            }
          },

          componentUpdated: function componentUpdated (el, binding, vnode) {
            if (vnode.tag === 'select') {
              setSelected(el, binding, vnode.context)
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
              var prevOptions = el._vOptions
              var curOptions = el._vOptions = [].map.call(el.options, getValue)
              if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]) })) {
        // trigger change event if
        // no matching option found for at least one value
                var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions) })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions)
                if (needReset) {
                  trigger(el, 'change')
                }
              }
            }
          }
        }

        function setSelected (el, binding, vm) {
          actuallySetSelected(el, binding, vm)
  /* istanbul ignore if */
          if (isIE || isEdge) {
            setTimeout(function () {
              actuallySetSelected(el, binding, vm)
            }, 0)
          }
        }

        function actuallySetSelected (el, binding, vm) {
          var value = binding.value
          var isMultiple = el.multiple
          if (isMultiple && !Array.isArray(value)) {
            'development' !== 'production' && warn(
      '<select multiple v-model="' + (binding.expression) + '"> ' +
      'expects an Array value for its binding, but got ' + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    )
            return
          }
          var selected, option
          for (var i = 0, l = el.options.length; i < l; i++) {
            option = el.options[i]
            if (isMultiple) {
              selected = looseIndexOf(value, getValue(option)) > -1
              if (option.selected !== selected) {
                option.selected = selected
              }
            } else {
              if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                  el.selectedIndex = i
                }
                return
              }
            }
          }
          if (!isMultiple) {
            el.selectedIndex = -1
          }
        }

        function hasNoMatchingOption (value, options) {
          return options.every(function (o) { return !looseEqual(o, value) })
        }

        function getValue (option) {
          return '_value' in option
    ? option._value
    : option.value
        }

        function onCompositionStart (e) {
          e.target.composing = true
        }

        function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
          if (!e.target.composing) { return }
          e.target.composing = false
          trigger(e.target, 'input')
        }

        function trigger (el, type) {
          var e = document.createEvent('HTMLEvents')
          e.initEvent(type, true, true)
          el.dispatchEvent(e)
        }

/*  */

// recursively search for possible transition defined inside the component root
        function locateNode (vnode) {
          return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
        }

        var show = {
          bind: function bind (el, ref, vnode) {
            var value = ref.value

            vnode = locateNode(vnode)
            var transition$$1 = vnode.data && vnode.data.transition
            var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display
            if (value && transition$$1) {
              vnode.data.show = true
              enter(vnode, function () {
                el.style.display = originalDisplay
              })
            } else {
              el.style.display = value ? originalDisplay : 'none'
            }
          },

          update: function update (el, ref, vnode) {
            var value = ref.value
            var oldValue = ref.oldValue

    /* istanbul ignore if */
            if (value === oldValue) { return }
            vnode = locateNode(vnode)
            var transition$$1 = vnode.data && vnode.data.transition
            if (transition$$1) {
              vnode.data.show = true
              if (value) {
                enter(vnode, function () {
                  el.style.display = el.__vOriginalDisplay
                })
              } else {
                leave(vnode, function () {
                  el.style.display = 'none'
                })
              }
            } else {
              el.style.display = value ? el.__vOriginalDisplay : 'none'
            }
          },

          unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
            if (!isDestroy) {
              el.style.display = el.__vOriginalDisplay
            }
          }
        }

        var platformDirectives = {
          model: directive,
          show: show
        }

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

        var transitionProps = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object]
        }

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
        function getRealChild (vnode) {
          var compOptions = vnode && vnode.componentOptions
          if (compOptions && compOptions.Ctor.options.abstract) {
            return getRealChild(getFirstComponentChild(compOptions.children))
          } else {
            return vnode
          }
        }

        function extractTransitionData (comp) {
          var data = {}
          var options = comp.$options
  // props
          for (var key in options.propsData) {
            data[key] = comp[key]
          }
  // events.
  // extract listeners and pass them directly to the transition methods
          var listeners = options._parentListeners
          for (var key$1 in listeners) {
            data[camelize(key$1)] = listeners[key$1]
          }
          return data
        }

        function placeholder (h, rawChild) {
          if (/\d-keep-alive$/.test(rawChild.tag)) {
            return h('keep-alive', {
              props: rawChild.componentOptions.propsData
            })
          }
        }

        function hasParentTransition (vnode) {
          while ((vnode = vnode.parent)) {
            if (vnode.data.transition) {
              return true
            }
          }
        }

        function isSameChild (child, oldChild) {
          return oldChild.key === child.key && oldChild.tag === child.tag
        }

        var Transition = {
          name: 'transition',
          props: transitionProps,
          abstract: true,

          render: function render (h) {
            var this$1 = this

            var children = this.$slots.default
            if (!children) {
              return
            }

    // filter out text nodes (possible whitespaces)
            children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c) })
    /* istanbul ignore if */
            if (!children.length) {
              return
            }

    // warn multiple elements
            if ('development' !== 'production' && children.length > 1) {
              warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      )
            }

            var mode = this.mode

    // warn invalid mode
            if ('development' !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
              warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      )
            }

            var rawChild = children[0]

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
            if (hasParentTransition(this.$vnode)) {
              return rawChild
            }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
            var child = getRealChild(rawChild)
    /* istanbul ignore if */
            if (!child) {
              return rawChild
            }

            if (this._leaving) {
              return placeholder(h, rawChild)
            }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
            var id = '__transition-' + (this._uid) + '-'
            child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key

            var data = (child.data || (child.data = {})).transition = extractTransitionData(this)
            var oldRawChild = this._vnode
            var oldChild = getRealChild(oldRawChild)

    // mark v-show
    // so that the transition module can hand over the control to the directive
            if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show' })) {
              child.data.show = true
            }

            if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
              var oldData = oldChild.data.transition = extend({}, data)
      // handle transition mode
              if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
                this._leaving = true
                mergeVNodeHook(oldData, 'afterLeave', function () {
                  this$1._leaving = false
                  this$1.$forceUpdate()
                })
                return placeholder(h, rawChild)
              } else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                  return oldRawChild
                }
                var delayedLeave
                var performLeave = function () { delayedLeave() }
                mergeVNodeHook(data, 'afterEnter', performLeave)
                mergeVNodeHook(data, 'enterCancelled', performLeave)
                mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave })
              }
            }

            return rawChild
          }
        }

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

        var props = extend({
          tag: String,
          moveClass: String
        }, transitionProps)

        delete props.mode

        var TransitionGroup = {
          props: props,

          render: function render (h) {
            var tag = this.tag || this.$vnode.data.tag || 'span'
            var map = Object.create(null)
            var prevChildren = this.prevChildren = this.children
            var rawChildren = this.$slots.default || []
            var children = this.children = []
            var transitionData = extractTransitionData(this)

            for (var i = 0; i < rawChildren.length; i++) {
              var c = rawChildren[i]
              if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                  children.push(c)
                  map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData
                } else {
                  var opts = c.componentOptions
                  var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag
                  warn(('<transition-group> children must be keyed: <' + name + '>'))
                }
              }
            }

            if (prevChildren) {
              var kept = []
              var removed = []
              for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                var c$1 = prevChildren[i$1]
                c$1.data.transition = transitionData
                c$1.data.pos = c$1.elm.getBoundingClientRect()
                if (map[c$1.key]) {
                  kept.push(c$1)
                } else {
                  removed.push(c$1)
                }
              }
              this.kept = h(tag, null, kept)
              this.removed = removed
            }

            return h(tag, null, children)
          },

          beforeUpdate: function beforeUpdate () {
    // force removing pass
            this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    )
            this._vnode = this.kept
          },

          updated: function updated () {
            var children = this.prevChildren
            var moveClass = this.moveClass || ((this.name || 'v') + '-move')
            if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
              return
            }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
            children.forEach(callPendingCbs)
            children.forEach(recordPosition)
            children.forEach(applyTranslation)

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
            this._reflow = document.body.offsetHeight

            children.forEach(function (c) {
              if (c.data.moved) {
                var el = c.elm
                var s = el.style
                addTransitionClass(el, moveClass)
                s.transform = s.WebkitTransform = s.transitionDuration = ''
                el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
                  if (!e || /transform$/.test(e.propertyName)) {
                    el.removeEventListener(transitionEndEvent, cb)
                    el._moveCb = null
                    removeTransitionClass(el, moveClass)
                  }
                })
              }
            })
          },

          methods: {
            hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
              if (!hasTransition) {
                return false
              }
      /* istanbul ignore if */
              if (this._hasMove) {
                return this._hasMove
              }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
              var clone = el.cloneNode()
              if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) { removeClass(clone, cls) })
              }
              addClass(clone, moveClass)
              clone.style.display = 'none'
              this.$el.appendChild(clone)
              var info = getTransitionInfo(clone)
              this.$el.removeChild(clone)
              return (this._hasMove = info.hasTransform)
            }
          }
        }

        function callPendingCbs (c) {
  /* istanbul ignore if */
          if (c.elm._moveCb) {
            c.elm._moveCb()
          }
  /* istanbul ignore if */
          if (c.elm._enterCb) {
            c.elm._enterCb()
          }
        }

        function recordPosition (c) {
          c.data.newPos = c.elm.getBoundingClientRect()
        }

        function applyTranslation (c) {
          var oldPos = c.data.pos
          var newPos = c.data.newPos
          var dx = oldPos.left - newPos.left
          var dy = oldPos.top - newPos.top
          if (dx || dy) {
            c.data.moved = true
            var s = c.elm.style
            s.transform = s.WebkitTransform = 'translate(' + dx + 'px,' + dy + 'px)'
            s.transitionDuration = '0s'
          }
        }

        var platformComponents = {
          Transition: Transition,
          TransitionGroup: TransitionGroup
        }

/*  */

// install platform specific utils
        Vue$3.config.mustUseProp = mustUseProp
        Vue$3.config.isReservedTag = isReservedTag
        Vue$3.config.isReservedAttr = isReservedAttr
        Vue$3.config.getTagNamespace = getTagNamespace
        Vue$3.config.isUnknownElement = isUnknownElement

// install platform runtime directives & components
        extend(Vue$3.options.directives, platformDirectives)
        extend(Vue$3.options.components, platformComponents)

// install platform patch function
        Vue$3.prototype.__patch__ = inBrowser ? patch : noop

// public mount method
        Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
          el = el && inBrowser ? query(el) : undefined
          return mountComponent(this, el, hydrating)
        }

// devtools global hook
/* istanbul ignore next */
        Vue$3.nextTick(function () {
          if (config.devtools) {
            if (devtools) {
              devtools.emit('init', Vue$3)
            } else if ('development' !== 'production' && isChrome) {
              console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      )
            }
          }
          if ('development' !== 'production' &&
    config.productionTip !== false &&
    inBrowser && typeof console !== 'undefined'
  ) {
            console[console.info ? 'info' : 'log'](
      'You are running Vue in development mode.\n' +
      'Make sure to turn on production mode when deploying for production.\n' +
      'See more tips at https://vuejs.org/guide/deployment.html'
    )
          }
        }, 0)

/*  */

        var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
        var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g

        var buildRegex = cached(function (delimiters) {
          var open = delimiters[0].replace(regexEscapeRE, '\\$&')
          var close = delimiters[1].replace(regexEscapeRE, '\\$&')
          return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
        })

        function parseText (
  text,
  delimiters
) {
          var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
          if (!tagRE.test(text)) {
            return
          }
          var tokens = []
          var lastIndex = tagRE.lastIndex = 0
          var match, index
          while ((match = tagRE.exec(text))) {
            index = match.index
    // push text token
            if (index > lastIndex) {
              tokens.push(JSON.stringify(text.slice(lastIndex, index)))
            }
    // tag token
            var exp = parseFilters(match[1].trim())
            tokens.push(('_s(' + exp + ')'))
            lastIndex = index + match[0].length
          }
          if (lastIndex < text.length) {
            tokens.push(JSON.stringify(text.slice(lastIndex)))
          }
          return tokens.join('+')
        }

/*  */

        function transformNode (el, options) {
          var warn = options.warn || baseWarn
          var staticClass = getAndRemoveAttr(el, 'class')
          if ('development' !== 'production' && staticClass) {
            var expression = parseText(staticClass, options.delimiters)
            if (expression) {
              warn(
        'class="' + staticClass + '": ' +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      )
            }
          }
          if (staticClass) {
            el.staticClass = JSON.stringify(staticClass)
          }
          var classBinding = getBindingAttr(el, 'class', false /* getStatic */)
          if (classBinding) {
            el.classBinding = classBinding
          }
        }

        function genData (el) {
          var data = ''
          if (el.staticClass) {
            data += 'staticClass:' + (el.staticClass) + ','
          }
          if (el.classBinding) {
            data += 'class:' + (el.classBinding) + ','
          }
          return data
        }

        var klass$1 = {
          staticKeys: ['staticClass'],
          transformNode: transformNode,
          genData: genData
        }

/*  */

        function transformNode$1 (el, options) {
          var warn = options.warn || baseWarn
          var staticStyle = getAndRemoveAttr(el, 'style')
          if (staticStyle) {
    /* istanbul ignore if */
            {
              var expression = parseText(staticStyle, options.delimiters)
              if (expression) {
                warn(
          'style="' + staticStyle + '": ' +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        )
              }
            }
            el.staticStyle = JSON.stringify(parseStyleText(staticStyle))
          }

          var styleBinding = getBindingAttr(el, 'style', false /* getStatic */)
          if (styleBinding) {
            el.styleBinding = styleBinding
          }
        }

        function genData$1 (el) {
          var data = ''
          if (el.staticStyle) {
            data += 'staticStyle:' + (el.staticStyle) + ','
          }
          if (el.styleBinding) {
            data += 'style:(' + (el.styleBinding) + '),'
          }
          return data
        }

        var style$1 = {
          staticKeys: ['staticStyle'],
          transformNode: transformNode$1,
          genData: genData$1
        }

/*  */

        var decoder

        var he = {
          decode: function decode (html) {
            decoder = decoder || document.createElement('div')
            decoder.innerHTML = html
            return decoder.textContent
          }
        }

/*  */

        var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
)

// Elements that you can, intentionally, leave open
// (and which close themselves)
        var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
)

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
        var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
)

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
        var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
        var ncname = '[a-zA-Z_][\\w\\-\\.]*'
        var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')'
        var startTagOpen = new RegExp(('^<' + qnameCapture))
        var startTagClose = /^\s*(\/?)>/
        var endTag = new RegExp(('^<\\/' + qnameCapture + '[^>]*>'))
        var doctype = /^<!DOCTYPE [^>]+>/i
        var comment = /^<!--/
        var conditionalComment = /^<!\[/

        var IS_REGEX_CAPTURING_BROKEN = false
        'x'.replace(/x(.)?/g, function (m, g) {
          IS_REGEX_CAPTURING_BROKEN = g === ''
        })

// Special Elements (can contain anything)
        var isPlainTextElement = makeMap('script,style,textarea', true)
        var reCache = {}

        var decodingMap = {
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&amp;': '&',
          '&#10;': '\n',
          '&#9;': '\t'
        }
        var encodedAttr = /&(?:lt|gt|quot|amp);/g
        var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g

// #5992
        var isIgnoreNewlineTag = makeMap('pre,textarea', true)
        var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n' }

        function decodeAttr (value, shouldDecodeNewlines) {
          var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr
          return value.replace(re, function (match) { return decodingMap[match] })
        }

        function parseHTML (html, options) {
          var stack = []
          var expectHTML = options.expectHTML
          var isUnaryTag$$1 = options.isUnaryTag || no
          var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no
          var index = 0
          var last, lastTag
          while (html) {
            last = html
    // Make sure we're not in a plaintext content element like script/style
            if (!lastTag || !isPlainTextElement(lastTag)) {
              var textEnd = html.indexOf('<')
              if (textEnd === 0) {
        // Comment:
                if (comment.test(html)) {
                  var commentEnd = html.indexOf('-->')

                  if (commentEnd >= 0) {
                    if (options.shouldKeepComment) {
                      options.comment(html.substring(4, commentEnd))
                    }
                    advance(commentEnd + 3)
                    continue
                  }
                }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                if (conditionalComment.test(html)) {
                  var conditionalEnd = html.indexOf(']>')

                  if (conditionalEnd >= 0) {
                    advance(conditionalEnd + 2)
                    continue
                  }
                }

        // Doctype:
                var doctypeMatch = html.match(doctype)
                if (doctypeMatch) {
                  advance(doctypeMatch[0].length)
                  continue
                }

        // End tag:
                var endTagMatch = html.match(endTag)
                if (endTagMatch) {
                  var curIndex = index
                  advance(endTagMatch[0].length)
                  parseEndTag(endTagMatch[1], curIndex, index)
                  continue
                }

        // Start tag:
                var startTagMatch = parseStartTag()
                if (startTagMatch) {
                  handleStartTag(startTagMatch)
                  if (shouldIgnoreFirstNewline(lastTag, html)) {
                    advance(1)
                  }
                  continue
                }
              }

              var text = (void 0), rest = (void 0), next = (void 0)
              if (textEnd >= 0) {
                rest = html.slice(textEnd)
                while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
                  next = rest.indexOf('<', 1)
                  if (next < 0) { break }
                  textEnd += next
                  rest = html.slice(textEnd)
                }
                text = html.substring(0, textEnd)
                advance(textEnd)
              }

              if (textEnd < 0) {
                text = html
                html = ''
              }

              if (options.chars && text) {
                options.chars(text)
              }
            } else {
              var endTagLength = 0
              var stackedTag = lastTag.toLowerCase()
              var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'))
              var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
                endTagLength = endTag.length
                if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
                  text = text
            .replace(/<!--([\s\S]*?)-->/g, '$1')
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1')
                }
                if (shouldIgnoreFirstNewline(stackedTag, text)) {
                  text = text.slice(1)
                }
                if (options.chars) {
                  options.chars(text)
                }
                return ''
              })
              index += html.length - rest$1.length
              html = rest$1
              parseEndTag(stackedTag, index - endTagLength, index)
            }

            if (html === last) {
              options.chars && options.chars(html)
              if ('development' !== 'production' && !stack.length && options.warn) {
                options.warn(('Mal-formatted tag at end of template: "' + html + '"'))
              }
              break
            }
          }

  // Clean up any remaining tags
          parseEndTag()

          function advance (n) {
            index += n
            html = html.substring(n)
          }

          function parseStartTag () {
            var start = html.match(startTagOpen)
            if (start) {
              var match = {
                tagName: start[1],
                attrs: [],
                start: index
              }
              advance(start[0].length)
              var end, attr
              while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
                advance(attr[0].length)
                match.attrs.push(attr)
              }
              if (end) {
                match.unarySlash = end[1]
                advance(end[0].length)
                match.end = index
                return match
              }
            }
          }

          function handleStartTag (match) {
            var tagName = match.tagName
            var unarySlash = match.unarySlash

            if (expectHTML) {
              if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                parseEndTag(lastTag)
              }
              if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
                parseEndTag(tagName)
              }
            }

            var unary = isUnaryTag$$1(tagName) || !!unarySlash

            var l = match.attrs.length
            var attrs = new Array(l)
            for (var i = 0; i < l; i++) {
              var args = match.attrs[i]
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
              if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
                if (args[3] === '') { delete args[3] }
                if (args[4] === '') { delete args[4] }
                if (args[5] === '') { delete args[5] }
              }
              var value = args[3] || args[4] || args[5] || ''
              var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines
              attrs[i] = {
                name: args[1],
                value: decodeAttr(value, shouldDecodeNewlines)
              }
            }

            if (!unary) {
              stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
              lastTag = tagName
            }

            if (options.start) {
              options.start(tagName, attrs, unary, match.start, match.end)
            }
          }

          function parseEndTag (tagName, start, end) {
            var pos, lowerCasedTagName
            if (start == null) { start = index }
            if (end == null) { end = index }

            if (tagName) {
              lowerCasedTagName = tagName.toLowerCase()
            }

    // Find the closest opened tag of the same type
            if (tagName) {
              for (pos = stack.length - 1; pos >= 0; pos--) {
                if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                  break
                }
              }
            } else {
      // If no tag name is provided, clean shop
              pos = 0
            }

            if (pos >= 0) {
      // Close all the open elements, up the stack
              for (var i = stack.length - 1; i >= pos; i--) {
                if ('development' !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
                  options.warn(
            ('tag <' + (stack[i].tag) + '> has no matching end tag.')
          )
                }
                if (options.end) {
                  options.end(stack[i].tag, start, end)
                }
              }

      // Remove the open elements from the stack
              stack.length = pos
              lastTag = pos && stack[pos - 1].tag
            } else if (lowerCasedTagName === 'br') {
              if (options.start) {
                options.start(tagName, [], true, start, end)
              }
            } else if (lowerCasedTagName === 'p') {
              if (options.start) {
                options.start(tagName, [], false, start, end)
              }
              if (options.end) {
                options.end(tagName, start, end)
              }
            }
          }
        }

/*  */

        var onRE = /^@|^v-on:/
        var dirRE = /^v-|^@|^:/
        var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/
        var forIteratorRE = /\((\{[^}]*\}|[^,{]*),([^,]*)(?:,([^,]*))?\)/
        var stripParensRE = /^\(|\)$/g

        var argRE = /:(.*)$/
        var bindRE = /^:|^v-bind:/
        var modifierRE = /\.[^.]+/g

        var decodeHTMLCached = cached(he.decode)

// configurable state
        var warn$2
        var delimiters
        var transforms
        var preTransforms
        var postTransforms
        var platformIsPreTag
        var platformMustUseProp
        var platformGetTagNamespace

        function createASTElement (
  tag,
  attrs,
  parent
) {
          return {
            type: 1,
            tag: tag,
            attrsList: attrs,
            attrsMap: makeAttrsMap(attrs),
            parent: parent,
            children: []
          }
        }

/**
 * Convert HTML string to AST.
 */
        function parse (
  template,
  options
) {
          warn$2 = options.warn || baseWarn

          platformIsPreTag = options.isPreTag || no
          platformMustUseProp = options.mustUseProp || no
          platformGetTagNamespace = options.getTagNamespace || no

          transforms = pluckModuleFunction(options.modules, 'transformNode')
          preTransforms = pluckModuleFunction(options.modules, 'preTransformNode')
          postTransforms = pluckModuleFunction(options.modules, 'postTransformNode')

          delimiters = options.delimiters

          var stack = []
          var preserveWhitespace = options.preserveWhitespace !== false
          var root
          var currentParent
          var inVPre = false
          var inPre = false
          var warned = false

          function warnOnce (msg) {
            if (!warned) {
              warned = true
              warn$2(msg)
            }
          }

          function endPre (element) {
    // check pre state
            if (element.pre) {
              inVPre = false
            }
            if (platformIsPreTag(element.tag)) {
              inPre = false
            }
          }

          parseHTML(template, {
            warn: warn$2,
            expectHTML: options.expectHTML,
            isUnaryTag: options.isUnaryTag,
            canBeLeftOpenTag: options.canBeLeftOpenTag,
            shouldDecodeNewlines: options.shouldDecodeNewlines,
            shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
            shouldKeepComment: options.comments,
            start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
              var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag)

      // handle IE svg bug
      /* istanbul ignore if */
              if (isIE && ns === 'svg') {
                attrs = guardIESVGBug(attrs)
              }

              var element = createASTElement(tag, attrs, currentParent)
              if (ns) {
                element.ns = ns
              }

              if (isForbiddenTag(element) && !isServerRendering()) {
                element.forbidden = true
                'development' !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          '<' + tag + '>' + ', as they will not be parsed.'
        )
              }

      // apply pre-transforms
              for (var i = 0; i < preTransforms.length; i++) {
                element = preTransforms[i](element, options) || element
              }

              if (!inVPre) {
                processPre(element)
                if (element.pre) {
                  inVPre = true
                }
              }
              if (platformIsPreTag(element.tag)) {
                inPre = true
              }
              if (inVPre) {
                processRawAttrs(element)
              } else if (!element.processed) {
        // structural directives
                processFor(element)
                processIf(element)
                processOnce(element)
        // element-scope stuff
                processElement(element, options)
              }

              function checkRootConstraints (el) {
                {
                  if (el.tag === 'slot' || el.tag === 'template') {
                    warnOnce(
              'Cannot use <' + (el.tag) + '> as component root element because it may ' +
              'contain multiple nodes.'
            )
                  }
                  if (el.attrsMap.hasOwnProperty('v-for')) {
                    warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            )
                  }
                }
              }

      // tree management
              if (!root) {
                root = element
                checkRootConstraints(root)
              } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
                if (root.if && (element.elseif || element.else)) {
                  checkRootConstraints(element)
                  addIfCondition(root, {
                    exp: element.elseif,
                    block: element
                  })
                } else {
                  warnOnce(
            'Component template should contain exactly one root element. ' +
            'If you are using v-if on multiple elements, ' +
            'use v-else-if to chain them instead.'
          )
                }
              }
              if (currentParent && !element.forbidden) {
                if (element.elseif || element.else) {
                  processIfConditions(element, currentParent)
                } else if (element.slotScope) { // scoped slot
                  currentParent.plain = false
                  var name = element.slotTarget || '"default"'; (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
                } else {
                  currentParent.children.push(element)
                  element.parent = currentParent
                }
              }
              if (!unary) {
                currentParent = element
                stack.push(element)
              } else {
                endPre(element)
              }
      // apply post-transforms
              for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {
                postTransforms[i$1](element, options)
              }
            },

            end: function end () {
      // remove trailing whitespace
              var element = stack[stack.length - 1]
              var lastNode = element.children[element.children.length - 1]
              if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
                element.children.pop()
              }
      // pop stack
              stack.length -= 1
              currentParent = stack[stack.length - 1]
              endPre(element)
            },

            chars: function chars (text) {
              if (!currentParent) {
                {
                  if (text === template) {
                    warnOnce(
              'Component template requires a root element, rather than just text.'
            )
                  } else if ((text = text.trim())) {
                    warnOnce(
              ('text "' + text + '" outside root element will be ignored.')
            )
                  }
                }
                return
              }
      // IE textarea placeholder bug
      /* istanbul ignore if */
              if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
                return
              }
              var children = currentParent.children
              text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : ''
              if (text) {
                var expression
                if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
                  children.push({
                    type: 2,
                    expression: expression,
                    text: text
                  })
                } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
                  children.push({
                    type: 3,
                    text: text
                  })
                }
              }
            },
            comment: function comment (text) {
              currentParent.children.push({
                type: 3,
                text: text,
                isComment: true
              })
            }
          })
          return root
        }

        function processPre (el) {
          if (getAndRemoveAttr(el, 'v-pre') != null) {
            el.pre = true
          }
        }

        function processRawAttrs (el) {
          var l = el.attrsList.length
          if (l) {
            var attrs = el.attrs = new Array(l)
            for (var i = 0; i < l; i++) {
              attrs[i] = {
                name: el.attrsList[i].name,
                value: JSON.stringify(el.attrsList[i].value)
              }
            }
          } else if (!el.pre) {
    // non root node in pre blocks with no attributes
            el.plain = true
          }
        }

        function processElement (element, options) {
          processKey(element)

  // determine whether this is a plain element after
  // removing structural attributes
          element.plain = !element.key && !element.attrsList.length

          processRef(element)
          processSlot(element)
          processComponent(element)
          for (var i = 0; i < transforms.length; i++) {
            element = transforms[i](element, options) || element
          }
          processAttrs(element)
        }

        function processKey (el) {
          var exp = getBindingAttr(el, 'key')
          if (exp) {
            if ('development' !== 'production' && el.tag === 'template') {
              warn$2('<template> cannot be keyed. Place the key on real elements instead.')
            }
            el.key = exp
          }
        }

        function processRef (el) {
          var ref = getBindingAttr(el, 'ref')
          if (ref) {
            el.ref = ref
            el.refInFor = checkInFor(el)
          }
        }

        function processFor (el) {
          var exp
          if ((exp = getAndRemoveAttr(el, 'v-for'))) {
            var inMatch = exp.match(forAliasRE)
            if (!inMatch) {
              'development' !== 'production' && warn$2(
        ('Invalid v-for expression: ' + exp)
      )
              return
            }
            el.for = inMatch[2].trim()
            var alias = inMatch[1].trim()
            var iteratorMatch = alias.match(forIteratorRE)
            if (iteratorMatch) {
              el.alias = iteratorMatch[1].trim()
              el.iterator1 = iteratorMatch[2].trim()
              if (iteratorMatch[3]) {
                el.iterator2 = iteratorMatch[3].trim()
              }
            } else {
              el.alias = alias.replace(stripParensRE, '')
            }
          }
        }

        function processIf (el) {
          var exp = getAndRemoveAttr(el, 'v-if')
          if (exp) {
            el.if = exp
            addIfCondition(el, {
              exp: exp,
              block: el
            })
          } else {
            if (getAndRemoveAttr(el, 'v-else') != null) {
              el.else = true
            }
            var elseif = getAndRemoveAttr(el, 'v-else-if')
            if (elseif) {
              el.elseif = elseif
            }
          }
        }

        function processIfConditions (el, parent) {
          var prev = findPrevElement(parent.children)
          if (prev && prev.if) {
            addIfCondition(prev, {
              exp: el.elseif,
              block: el
            })
          } else {
            warn$2(
      'v-' + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + ' ' +
      'used on element <' + (el.tag) + '> without corresponding v-if.'
    )
          }
        }

        function findPrevElement (children) {
          var i = children.length
          while (i--) {
            if (children[i].type === 1) {
              return children[i]
            } else {
              if ('development' !== 'production' && children[i].text !== ' ') {
                warn$2(
          'text "' + (children[i].text.trim()) + '" between v-if and v-else(-if) ' +
          'will be ignored.'
        )
              }
              children.pop()
            }
          }
        }

        function addIfCondition (el, condition) {
          if (!el.ifConditions) {
            el.ifConditions = []
          }
          el.ifConditions.push(condition)
        }

        function processOnce (el) {
          var once$$1 = getAndRemoveAttr(el, 'v-once')
          if (once$$1 != null) {
            el.once = true
          }
        }

        function processSlot (el) {
          if (el.tag === 'slot') {
            el.slotName = getBindingAttr(el, 'name')
            if ('development' !== 'production' && el.key) {
              warn$2(
        '`key` does not work on <slot> because slots are abstract outlets ' +
        'and can possibly expand into multiple elements. ' +
        'Use the key on a wrapping element instead.'
      )
            }
          } else {
            var slotScope
            if (el.tag === 'template') {
              slotScope = getAndRemoveAttr(el, 'scope')
      /* istanbul ignore if */
              if ('development' !== 'production' && slotScope) {
                warn$2(
          'the "scope" attribute for scoped slots have been deprecated and ' +
          'replaced by "slot-scope" since 2.5. The new "slot-scope" attribute ' +
          'can also be used on plain elements in addition to <template> to ' +
          'denote scoped slots.',
          true
        )
              }
              el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope')
            } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      /* istanbul ignore if */
              if ('development' !== 'production' && el.attrsMap['v-for']) {
                warn$2(
          'Ambiguous combined usage of slot-scope and v-for on <' + (el.tag) + '> ' +
          '(v-for takes higher priority). Use a wrapper <template> for the ' +
          'scoped slot to make it clearer.',
          true
        )
              }
              el.slotScope = slotScope
            }
            var slotTarget = getBindingAttr(el, 'slot')
            if (slotTarget) {
              el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
              if (el.tag !== 'template' && !el.slotScope) {
                addAttr(el, 'slot', slotTarget)
              }
            }
          }
        }

        function processComponent (el) {
          var binding
          if ((binding = getBindingAttr(el, 'is'))) {
            el.component = binding
          }
          if (getAndRemoveAttr(el, 'inline-template') != null) {
            el.inlineTemplate = true
          }
        }

        function processAttrs (el) {
          var list = el.attrsList
          var i, l, name, rawName, value, modifiers, isProp
          for (i = 0, l = list.length; i < l; i++) {
            name = rawName = list[i].name
            value = list[i].value
            if (dirRE.test(name)) {
      // mark element as dynamic
              el.hasBindings = true
      // modifiers
              modifiers = parseModifiers(name)
              if (modifiers) {
                name = name.replace(modifierRE, '')
              }
              if (bindRE.test(name)) { // v-bind
                name = name.replace(bindRE, '')
                value = parseFilters(value)
                isProp = false
                if (modifiers) {
                  if (modifiers.prop) {
                    isProp = true
                    name = camelize(name)
                    if (name === 'innerHtml') { name = 'innerHTML' }
                  }
                  if (modifiers.camel) {
                    name = camelize(name)
                  }
                  if (modifiers.sync) {
                    addHandler(
              el,
              ('update:' + (camelize(name))),
              genAssignmentCode(value, '$event')
            )
                  }
                }
                if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
                  addProp(el, name, value)
                } else {
                  addAttr(el, name, value)
                }
              } else if (onRE.test(name)) { // v-on
                name = name.replace(onRE, '')
                addHandler(el, name, value, modifiers, false, warn$2)
              } else { // normal directives
                name = name.replace(dirRE, '')
        // parse arg
                var argMatch = name.match(argRE)
                var arg = argMatch && argMatch[1]
                if (arg) {
                  name = name.slice(0, -(arg.length + 1))
                }
                addDirective(el, name, rawName, value, arg, modifiers)
                if ('development' !== 'production' && name === 'model') {
                  checkForAliasModel(el, value)
                }
              }
            } else {
      // literal attribute
              {
                var expression = parseText(value, delimiters)
                if (expression) {
                  warn$2(
            name + '="' + value + '": ' +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          )
                }
              }
              addAttr(el, name, JSON.stringify(value))
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
              if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                addProp(el, name, 'true')
              }
            }
          }
        }

        function checkInFor (el) {
          var parent = el
          while (parent) {
            if (parent.for !== undefined) {
              return true
            }
            parent = parent.parent
          }
          return false
        }

        function parseModifiers (name) {
          var match = name.match(modifierRE)
          if (match) {
            var ret = {}
            match.forEach(function (m) { ret[m.slice(1)] = true })
            return ret
          }
        }

        function makeAttrsMap (attrs) {
          var map = {}
          for (var i = 0, l = attrs.length; i < l; i++) {
            if (
      'development' !== 'production' &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
              warn$2('duplicate attribute: ' + attrs[i].name)
            }
            map[attrs[i].name] = attrs[i].value
          }
          return map
        }

// for script (e.g. type="x/template") or style, do not decode content
        function isTextTag (el) {
          return el.tag === 'script' || el.tag === 'style'
        }

        function isForbiddenTag (el) {
          return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
          )
        }

        var ieNSBug = /^xmlns:NS\d+/
        var ieNSPrefix = /^NS\d+:/

/* istanbul ignore next */
        function guardIESVGBug (attrs) {
          var res = []
          for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i]
            if (!ieNSBug.test(attr.name)) {
              attr.name = attr.name.replace(ieNSPrefix, '')
              res.push(attr)
            }
          }
          return res
        }

        function checkForAliasModel (el, value) {
          var _el = el
          while (_el) {
            if (_el.for && _el.alias === value) {
              warn$2(
        '<' + (el.tag) + ' v-model="' + value + '">: ' +
        'You are binding v-model directly to a v-for iteration alias. ' +
        'This will not be able to modify the v-for source array because ' +
        'writing to the alias is like modifying a function local variable. ' +
        'Consider using an array of objects and use v-model on an object property instead.'
      )
            }
            _el = _el.parent
          }
        }

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

        function preTransformNode (el, options) {
          if (el.tag === 'input') {
            var map = el.attrsMap
            if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
              var typeBinding = getBindingAttr(el, 'type')
              var ifCondition = getAndRemoveAttr(el, 'v-if', true)
              var ifConditionExtra = ifCondition ? ('&&(' + ifCondition + ')') : ''
              var hasElse = getAndRemoveAttr(el, 'v-else', true) != null
              var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true)
      // 1. checkbox
              var branch0 = cloneASTElement(el)
      // process for on the main node
              processFor(branch0)
              addRawAttr(branch0, 'type', 'checkbox')
              processElement(branch0, options)
              branch0.processed = true // prevent it from double-processed
              branch0.if = '(' + typeBinding + ")==='checkbox'" + ifConditionExtra
              addIfCondition(branch0, {
                exp: branch0.if,
                block: branch0
              })
      // 2. add radio else-if condition
              var branch1 = cloneASTElement(el)
              getAndRemoveAttr(branch1, 'v-for', true)
              addRawAttr(branch1, 'type', 'radio')
              processElement(branch1, options)
              addIfCondition(branch0, {
                exp: '(' + typeBinding + ")==='radio'" + ifConditionExtra,
                block: branch1
              })
      // 3. other
              var branch2 = cloneASTElement(el)
              getAndRemoveAttr(branch2, 'v-for', true)
              addRawAttr(branch2, ':type', typeBinding)
              processElement(branch2, options)
              addIfCondition(branch0, {
                exp: ifCondition,
                block: branch2
              })

              if (hasElse) {
                branch0.else = true
              } else if (elseIfCondition) {
                branch0.elseif = elseIfCondition
              }

              return branch0
            }
          }
        }

        function cloneASTElement (el) {
          return createASTElement(el.tag, el.attrsList.slice(), el.parent)
        }

        function addRawAttr (el, name, value) {
          el.attrsMap[name] = value
          el.attrsList.push({ name: name, value: value })
        }

        var model$2 = {
          preTransformNode: preTransformNode
        }

        var modules$1 = [
          klass$1,
          style$1,
          model$2
        ]

/*  */

        function text (el, dir) {
          if (dir.value) {
            addProp(el, 'textContent', ('_s(' + (dir.value) + ')'))
          }
        }

/*  */

        function html (el, dir) {
          if (dir.value) {
            addProp(el, 'innerHTML', ('_s(' + (dir.value) + ')'))
          }
        }

        var directives$1 = {
          model: model,
          text: text,
          html: html
        }

/*  */

        var baseOptions = {
          expectHTML: true,
          modules: modules$1,
          directives: directives$1,
          isPreTag: isPreTag,
          isUnaryTag: isUnaryTag,
          mustUseProp: mustUseProp,
          canBeLeftOpenTag: canBeLeftOpenTag,
          isReservedTag: isReservedTag,
          getTagNamespace: getTagNamespace,
          staticKeys: genStaticKeys(modules$1)
        }

/*  */

        var isStaticKey
        var isPlatformReservedTag

        var genStaticKeysCached = cached(genStaticKeys$1)

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
        function optimize (root, options) {
          if (!root) { return }
          isStaticKey = genStaticKeysCached(options.staticKeys || '')
          isPlatformReservedTag = options.isReservedTag || no
  // first pass: mark all non-static nodes.
          markStatic$1(root)
  // second pass: mark static roots.
          markStaticRoots(root, false)
        }

        function genStaticKeys$1 (keys) {
          return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
        }

        function markStatic$1 (node) {
          node.static = isStatic(node)
          if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
            if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
              return
            }
            for (var i = 0, l = node.children.length; i < l; i++) {
              var child = node.children[i]
              markStatic$1(child)
              if (!child.static) {
                node.static = false
              }
            }
            if (node.ifConditions) {
              for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                var block = node.ifConditions[i$1].block
                markStatic$1(block)
                if (!block.static) {
                  node.static = false
                }
              }
            }
          }
        }

        function markStaticRoots (node, isInFor) {
          if (node.type === 1) {
            if (node.static || node.once) {
              node.staticInFor = isInFor
            }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
            if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
              node.staticRoot = true
              return
            } else {
              node.staticRoot = false
            }
            if (node.children) {
              for (var i = 0, l = node.children.length; i < l; i++) {
                markStaticRoots(node.children[i], isInFor || !!node.for)
              }
            }
            if (node.ifConditions) {
              for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                markStaticRoots(node.ifConditions[i$1].block, isInFor)
              }
            }
          }
        }

        function isStatic (node) {
          if (node.type === 2) { // expression
            return false
          }
          if (node.type === 3) { // text
            return true
          }
          return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
        }

        function isDirectChildOfTemplateFor (node) {
          while (node.parent) {
            node = node.parent
            if (node.tag !== 'template') {
              return false
            }
            if (node.for) {
              return true
            }
          }
          return false
        }

/*  */

        var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/
        var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/

// keyCode aliases
        var keyCodes = {
          esc: 27,
          tab: 9,
          enter: 13,
          space: 32,
          up: 38,
          left: 37,
          right: 39,
          down: 40,
          'delete': [8, 46]
        }

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
        var genGuard = function (condition) { return ('if(' + condition + ')return null;') }

        var modifierCode = {
          stop: '$event.stopPropagation();',
          prevent: '$event.preventDefault();',
          self: genGuard('$event.target !== $event.currentTarget'),
          ctrl: genGuard('!$event.ctrlKey'),
          shift: genGuard('!$event.shiftKey'),
          alt: genGuard('!$event.altKey'),
          meta: genGuard('!$event.metaKey'),
          left: genGuard("'button' in $event && $event.button !== 0"),
          middle: genGuard("'button' in $event && $event.button !== 1"),
          right: genGuard("'button' in $event && $event.button !== 2")
        }

        function genHandlers (
  events,
  isNative,
  warn
) {
          var res = isNative ? 'nativeOn:{' : 'on:{'
          for (var name in events) {
            res += '"' + name + '":' + (genHandler(name, events[name])) + ','
          }
          return res.slice(0, -1) + '}'
        }

        function genHandler (
  name,
  handler
) {
          if (!handler) {
            return 'function(){}'
          }

          if (Array.isArray(handler)) {
            return ('[' + (handler.map(function (handler) { return genHandler(name, handler) }).join(',')) + ']')
          }

          var isMethodPath = simplePathRE.test(handler.value)
          var isFunctionExpression = fnExpRE.test(handler.value)

          if (!handler.modifiers) {
            return isMethodPath || isFunctionExpression
      ? handler.value
      : ('function($event){' + (handler.value) + '}') // inline statement
          } else {
            var code = ''
            var genModifierCode = ''
            var keys = []
            for (var key in handler.modifiers) {
              if (modifierCode[key]) {
                genModifierCode += modifierCode[key]
        // left/right
                if (keyCodes[key]) {
                  keys.push(key)
                }
              } else if (key === 'exact') {
                var modifiers = (handler.modifiers)
                genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier] })
            .map(function (keyModifier) { return ('$event.' + keyModifier + 'Key') })
            .join('||')
        )
              } else {
                keys.push(key)
              }
            }
            if (keys.length) {
              code += genKeyFilter(keys)
            }
    // Make sure modifiers like prevent and stop get executed after key filtering
            if (genModifierCode) {
              code += genModifierCode
            }
            var handlerCode = isMethodPath
      ? handler.value + '($event)'
      : isFunctionExpression
        ? ('(' + (handler.value) + ')($event)')
        : handler.value
            return ('function($event){' + code + handlerCode + '}')
          }
        }

        function genKeyFilter (keys) {
          return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ')return null;')
        }

        function genFilterCode (key) {
          var keyVal = parseInt(key, 10)
          if (keyVal) {
            return ('$event.keyCode!==' + keyVal)
          }
          var code = keyCodes[key]
          return (
    '_k($event.keyCode,' +
    (JSON.stringify(key)) + ',' +
    (JSON.stringify(code)) + ',' +
    '$event.key)'
          )
        }

/*  */

        function on (el, dir) {
          if ('development' !== 'production' && dir.modifiers) {
            warn('v-on without argument does not support modifiers.')
          }
          el.wrapListeners = function (code) { return ('_g(' + code + ',' + (dir.value) + ')') }
        }

/*  */

        function bind$1 (el, dir) {
          el.wrapData = function (code) {
            return ('_b(' + code + ",'" + (el.tag) + "'," + (dir.value) + ',' + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ')')
          }
        }

/*  */

        var baseDirectives = {
          on: on,
          bind: bind$1,
          cloak: noop
        }

/*  */

        var CodegenState = function CodegenState (options) {
          this.options = options
          this.warn = options.warn || baseWarn
          this.transforms = pluckModuleFunction(options.modules, 'transformCode')
          this.dataGenFns = pluckModuleFunction(options.modules, 'genData')
          this.directives = extend(extend({}, baseDirectives), options.directives)
          var isReservedTag = options.isReservedTag || no
          this.maybeComponent = function (el) { return !isReservedTag(el.tag) }
          this.onceId = 0
          this.staticRenderFns = []
        }

        function generate (
  ast,
  options
) {
          var state = new CodegenState(options)
          var code = ast ? genElement(ast, state) : '_c("div")'
          return {
            render: ('with(this){return ' + code + '}'),
            staticRenderFns: state.staticRenderFns
          }
        }

        function genElement (el, state) {
          if (el.staticRoot && !el.staticProcessed) {
            return genStatic(el, state)
          } else if (el.once && !el.onceProcessed) {
            return genOnce(el, state)
          } else if (el.for && !el.forProcessed) {
            return genFor(el, state)
          } else if (el.if && !el.ifProcessed) {
            return genIf(el, state)
          } else if (el.tag === 'template' && !el.slotTarget) {
            return genChildren(el, state) || 'void 0'
          } else if (el.tag === 'slot') {
            return genSlot(el, state)
          } else {
    // component or element
            var code
            if (el.component) {
              code = genComponent(el.component, el, state)
            } else {
              var data = el.plain ? undefined : genData$2(el, state)

              var children = el.inlineTemplate ? null : genChildren(el, state, true)
              code = "_c('" + (el.tag) + "'" + (data ? (',' + data) : '') + (children ? (',' + children) : '') + ')'
            }
    // module transforms
            for (var i = 0; i < state.transforms.length; i++) {
              code = state.transforms[i](el, code)
            }
            return code
          }
        }

// hoist static sub-trees out
        function genStatic (el, state, once$$1) {
          el.staticProcessed = true
          state.staticRenderFns.push(('with(this){return ' + (genElement(el, state)) + '}'))
          return ('_m(' + (state.staticRenderFns.length - 1) + ',' + (el.staticInFor ? 'true' : 'false') + ',' + (once$$1 ? 'true' : 'false') + ')')
        }

// v-once
        function genOnce (el, state) {
          el.onceProcessed = true
          if (el.if && !el.ifProcessed) {
            return genIf(el, state)
          } else if (el.staticInFor) {
            var key = ''
            var parent = el.parent
            while (parent) {
              if (parent.for) {
                key = parent.key
                break
              }
              parent = parent.parent
            }
            if (!key) {
              'development' !== 'production' && state.warn(
        'v-once can only be used inside v-for that is keyed. '
      )
              return genElement(el, state)
            }
            return ('_o(' + (genElement(el, state)) + ',' + (state.onceId++) + ',' + key + ')')
          } else {
            return genStatic(el, state, true)
          }
        }

        function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
          el.ifProcessed = true // avoid recursion
          return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
        }

        function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
          if (!conditions.length) {
            return altEmpty || '_e()'
          }

          var condition = conditions.shift()
          if (condition.exp) {
            return ('(' + (condition.exp) + ')?' + (genTernaryExp(condition.block)) + ':' + (genIfConditions(conditions, state, altGen, altEmpty)))
          } else {
            return ('' + (genTernaryExp(condition.block)))
          }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
          function genTernaryExp (el) {
            return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
          }
        }

        function genFor (
  el,
  state,
  altGen,
  altHelper
) {
          var exp = el.for
          var alias = el.alias
          var iterator1 = el.iterator1 ? (',' + (el.iterator1)) : ''
          var iterator2 = el.iterator2 ? (',' + (el.iterator2)) : ''

          if ('development' !== 'production' &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
            state.warn(
      '<' + (el.tag) + ' v-for="' + alias + ' in ' + exp + '">: component lists rendered with ' +
      'v-for should have explicit keys. ' +
      'See https://vuejs.org/guide/list.html#key for more info.',
      true /* tip */
    )
          }

          el.forProcessed = true // avoid recursion
          return (altHelper || '_l') + '((' + exp + '),' +
    'function(' + alias + iterator1 + iterator2 + '){' +
      'return ' + ((altGen || genElement)(el, state)) +
    '})'
        }

        function genData$2 (el, state) {
          var data = '{'

  // directives first.
  // directives may mutate the el's other properties before they are generated.
          var dirs = genDirectives(el, state)
          if (dirs) { data += dirs + ',' }

  // key
          if (el.key) {
            data += 'key:' + (el.key) + ','
          }
  // ref
          if (el.ref) {
            data += 'ref:' + (el.ref) + ','
          }
          if (el.refInFor) {
            data += 'refInFor:true,'
          }
  // pre
          if (el.pre) {
            data += 'pre:true,'
          }
  // record original tag name for components using "is" attribute
          if (el.component) {
            data += 'tag:"' + (el.tag) + '",'
          }
  // module data generation functions
          for (var i = 0; i < state.dataGenFns.length; i++) {
            data += state.dataGenFns[i](el)
          }
  // attributes
          if (el.attrs) {
            data += 'attrs:{' + (genProps(el.attrs)) + '},'
          }
  // DOM props
          if (el.props) {
            data += 'domProps:{' + (genProps(el.props)) + '},'
          }
  // event handlers
          if (el.events) {
            data += (genHandlers(el.events, false, state.warn)) + ','
          }
          if (el.nativeEvents) {
            data += (genHandlers(el.nativeEvents, true, state.warn)) + ','
          }
  // slot target
  // only for non-scoped slots
          if (el.slotTarget && !el.slotScope) {
            data += 'slot:' + (el.slotTarget) + ','
          }
  // scoped slots
          if (el.scopedSlots) {
            data += (genScopedSlots(el.scopedSlots, state)) + ','
          }
  // component v-model
          if (el.model) {
            data += 'model:{value:' + (el.model.value) + ',callback:' + (el.model.callback) + ',expression:' + (el.model.expression) + '},'
          }
  // inline-template
          if (el.inlineTemplate) {
            var inlineTemplate = genInlineTemplate(el, state)
            if (inlineTemplate) {
              data += inlineTemplate + ','
            }
          }
          data = data.replace(/,$/, '') + '}'
  // v-bind data wrap
          if (el.wrapData) {
            data = el.wrapData(data)
          }
  // v-on data wrap
          if (el.wrapListeners) {
            data = el.wrapListeners(data)
          }
          return data
        }

        function genDirectives (el, state) {
          var dirs = el.directives
          if (!dirs) { return }
          var res = 'directives:['
          var hasRuntime = false
          var i, l, dir, needRuntime
          for (i = 0, l = dirs.length; i < l; i++) {
            dir = dirs[i]
            needRuntime = true
            var gen = state.directives[dir.name]
            if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
              needRuntime = !!gen(el, dir, state.warn)
            }
            if (needRuntime) {
              hasRuntime = true
              res += '{name:"' + (dir.name) + '",rawName:"' + (dir.rawName) + '"' + (dir.value ? (',value:(' + (dir.value) + '),expression:' + (JSON.stringify(dir.value))) : '') + (dir.arg ? (',arg:"' + (dir.arg) + '"') : '') + (dir.modifiers ? (',modifiers:' + (JSON.stringify(dir.modifiers))) : '') + '},'
            }
          }
          if (hasRuntime) {
            return res.slice(0, -1) + ']'
          }
        }

        function genInlineTemplate (el, state) {
          var ast = el.children[0]
          if ('development' !== 'production' && (
    el.children.length !== 1 || ast.type !== 1
  )) {
            state.warn('Inline-template components must have exactly one child element.')
          }
          if (ast.type === 1) {
            var inlineRenderFns = generate(ast, state.options)
            return ('inlineTemplate:{render:function(){' + (inlineRenderFns.render) + '},staticRenderFns:[' + (inlineRenderFns.staticRenderFns.map(function (code) { return ('function(){' + code + '}') }).join(',')) + ']}')
          }
        }

        function genScopedSlots (
  slots,
  state
) {
          return ('scopedSlots:_u([' + (Object.keys(slots).map(function (key) {
            return genScopedSlot(key, slots[key], state)
          }).join(',')) + '])')
        }

        function genScopedSlot (
  key,
  el,
  state
) {
          if (el.for && !el.forProcessed) {
            return genForScopedSlot(key, el, state)
          }
          var fn = 'function(' + (String(el.slotScope)) + '){' +
    'return ' + (el.tag === 'template'
      ? el.if
        ? ((el.if) + '?' + (genChildren(el, state) || 'undefined') + ':undefined')
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + '}'
          return ('{key:' + key + ',fn:' + fn + '}')
        }

        function genForScopedSlot (
  key,
  el,
  state
) {
          var exp = el.for
          var alias = el.alias
          var iterator1 = el.iterator1 ? (',' + (el.iterator1)) : ''
          var iterator2 = el.iterator2 ? (',' + (el.iterator2)) : ''
          el.forProcessed = true // avoid recursion
          return '_l((' + exp + '),' +
    'function(' + alias + iterator1 + iterator2 + '){' +
      'return ' + (genScopedSlot(key, el, state)) +
    '})'
        }

        function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
          var children = el.children
          if (children.length) {
            var el$1 = children[0]
    // optimize single v-for
            if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
              return (altGenElement || genElement)(el$1, state)
            }
            var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0
            var gen = altGenNode || genNode
            return ('[' + (children.map(function (c) { return gen(c, state) }).join(',')) + ']' + (normalizationType ? (',' + normalizationType) : ''))
          }
        }

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
        function getNormalizationType (
  children,
  maybeComponent
) {
          var res = 0
          for (var i = 0; i < children.length; i++) {
            var el = children[i]
            if (el.type !== 1) {
              continue
            }
            if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block) }))) {
              res = 2
              break
            }
            if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block) }))) {
              res = 1
            }
          }
          return res
        }

        function needsNormalization (el) {
          return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
        }

        function genNode (node, state) {
          if (node.type === 1) {
            return genElement(node, state)
          } if (node.type === 3 && node.isComment) {
            return genComment(node)
          } else {
            return genText(node)
          }
        }

        function genText (text) {
          return ('_v(' + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ')')
        }

        function genComment (comment) {
          return ('_e(' + (JSON.stringify(comment.text)) + ')')
        }

        function genSlot (el, state) {
          var slotName = el.slotName || '"default"'
          var children = genChildren(el, state)
          var res = '_t(' + slotName + (children ? (',' + children) : '')
          var attrs = el.attrs && ('{' + (el.attrs.map(function (a) { return ((camelize(a.name)) + ':' + (a.value)) }).join(',')) + '}')
          var bind$$1 = el.attrsMap['v-bind']
          if ((attrs || bind$$1) && !children) {
            res += ',null'
          }
          if (attrs) {
            res += ',' + attrs
          }
          if (bind$$1) {
            res += (attrs ? '' : ',null') + ',' + bind$$1
          }
          return res + ')'
        }

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
        function genComponent (
  componentName,
  el,
  state
) {
          var children = el.inlineTemplate ? null : genChildren(el, state, true)
          return ('_c(' + componentName + ',' + (genData$2(el, state)) + (children ? (',' + children) : '') + ')')
        }

        function genProps (props) {
          var res = ''
          for (var i = 0; i < props.length; i++) {
            var prop = props[i]
            res += '"' + (prop.name) + '":' + (transformSpecialNewlines(prop.value)) + ','
          }
          return res.slice(0, -1)
        }

// #3895, #4268
        function transformSpecialNewlines (text) {
          return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
        }

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
        var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b')

// these unary operators should not be used as property/method names
        var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)')

// strip strings in expressions
        var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g

// detect problematic expressions in a template
        function detectErrors (ast) {
          var errors = []
          if (ast) {
            checkNode(ast, errors)
          }
          return errors
        }

        function checkNode (node, errors) {
          if (node.type === 1) {
            for (var name in node.attrsMap) {
              if (dirRE.test(name)) {
                var value = node.attrsMap[name]
                if (value) {
                  if (name === 'v-for') {
                    checkFor(node, ('v-for="' + value + '"'), errors)
                  } else if (onRE.test(name)) {
                    checkEvent(value, (name + '="' + value + '"'), errors)
                  } else {
                    checkExpression(value, (name + '="' + value + '"'), errors)
                  }
                }
              }
            }
            if (node.children) {
              for (var i = 0; i < node.children.length; i++) {
                checkNode(node.children[i], errors)
              }
            }
          } else if (node.type === 2) {
            checkExpression(node.expression, node.text, errors)
          }
        }

        function checkEvent (exp, text, errors) {
          var stipped = exp.replace(stripStringRE, '')
          var keywordMatch = stipped.match(unaryOperatorsRE)
          if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
            errors.push(
      'avoid using JavaScript unary operator as property name: ' +
      '"' + (keywordMatch[0]) + '" in expression ' + (text.trim())
    )
          }
          checkExpression(exp, text, errors)
        }

        function checkFor (node, text, errors) {
          checkExpression(node.for || '', text, errors)
          checkIdentifier(node.alias, 'v-for alias', text, errors)
          checkIdentifier(node.iterator1, 'v-for iterator', text, errors)
          checkIdentifier(node.iterator2, 'v-for iterator', text, errors)
        }

        function checkIdentifier (
  ident,
  type,
  text,
  errors
) {
          if (typeof ident === 'string') {
            try {
              new Function(('var ' + ident + '=_'))
            } catch (e) {
              errors.push(('invalid ' + type + ' "' + ident + '" in expression: ' + (text.trim())))
            }
          }
        }

        function checkExpression (exp, text, errors) {
          try {
            new Function(('return ' + exp))
          } catch (e) {
            var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE)
            if (keywordMatch) {
              errors.push(
        'avoid using JavaScript keyword as property name: ' +
        '"' + (keywordMatch[0]) + '"\n  Raw expression: ' + (text.trim())
      )
            } else {
              errors.push(
        'invalid expression: ' + (e.message) + ' in\n\n' +
        '    ' + exp + '\n\n' +
        '  Raw expression: ' + (text.trim()) + '\n'
      )
            }
          }
        }

/*  */

        function createFunction (code, errors) {
          try {
            return new Function(code)
          } catch (err) {
            errors.push({ err: err, code: code })
            return noop
          }
        }

        function createCompileToFunctionFn (compile) {
          var cache = Object.create(null)

          return function compileToFunctions (
    template,
    options,
    vm
  ) {
            options = extend({}, options)
            var warn$$1 = options.warn || warn
            delete options.warn

    /* istanbul ignore if */
            {
      // detect possible CSP restriction
              try {
                new Function('return 1')
              } catch (e) {
                if (e.toString().match(/unsafe-eval|CSP/)) {
                  warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          )
                }
              }
            }

    // check cache
            var key = options.delimiters
      ? String(options.delimiters) + template
      : template
            if (cache[key]) {
              return cache[key]
            }

    // compile
            var compiled = compile(template, options)

    // check compilation errors/tips
            {
              if (compiled.errors && compiled.errors.length) {
                warn$$1(
          'Error compiling template:\n\n' + template + '\n\n' +
          compiled.errors.map(function (e) { return ('- ' + e) }).join('\n') + '\n',
          vm
        )
              }
              if (compiled.tips && compiled.tips.length) {
                compiled.tips.forEach(function (msg) { return tip(msg, vm) })
              }
            }

    // turn code into functions
            var res = {}
            var fnGenErrors = []
            res.render = createFunction(compiled.render, fnGenErrors)
            res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
              return createFunction(code, fnGenErrors)
            })

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
            {
              if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
                warn$$1(
          'Failed to generate render function:\n\n' +
          fnGenErrors.map(function (ref) {
            var err = ref.err
            var code = ref.code

            return ((err.toString()) + ' in\n\n' + code + '\n')
          }).join('\n'),
          vm
        )
              }
            }

            return (cache[key] = res)
          }
        }

/*  */

        function createCompilerCreator (baseCompile) {
          return function createCompiler (baseOptions) {
            function compile (
      template,
      options
    ) {
              var finalOptions = Object.create(baseOptions)
              var errors = []
              var tips = []
              finalOptions.warn = function (msg, tip) {
                (tip ? tips : errors).push(msg)
              }

              if (options) {
        // merge custom modules
                if (options.modules) {
                  finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
                }
        // merge custom directives
                if (options.directives) {
                  finalOptions.directives = extend(
            Object.create(baseOptions.directives),
            options.directives
          )
                }
        // copy other options
                for (var key in options) {
                  if (key !== 'modules' && key !== 'directives') {
                    finalOptions[key] = options[key]
                  }
                }
              }

              var compiled = baseCompile(template, finalOptions)
              {
                errors.push.apply(errors, detectErrors(compiled.ast))
              }
              compiled.errors = errors
              compiled.tips = tips
              return compiled
            }

            return {
              compile: compile,
              compileToFunctions: createCompileToFunctionFn(compile)
            }
          }
        }

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
        var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
          var ast = parse(template.trim(), options)
          optimize(ast, options)
          var code = generate(ast, options)
          return {
            ast: ast,
            render: code.render,
            staticRenderFns: code.staticRenderFns
          }
        })

/*  */

        var ref$1 = createCompiler(baseOptions)
        var compileToFunctions = ref$1.compileToFunctions

/*  */

// check whether current browser encodes a char inside attribute values
        var div
        function getShouldDecode (href) {
          div = div || document.createElement('div')
          div.innerHTML = href ? '<a href="\n"/>' : '<div a="\n"/>'
          return div.innerHTML.indexOf('&#10;') > 0
        }

// #3663: IE encodes newlines inside attribute values while other browsers don't
        var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false
// #6828: chrome encodes content in a[href]
        var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false

/*  */

        var idToTemplate = cached(function (id) {
          var el = query(id)
          return el && el.innerHTML
        })

        var mount = Vue$3.prototype.$mount
        Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
          el = el && query(el)

  /* istanbul ignore if */
          if (el === document.body || el === document.documentElement) {
            'development' !== 'production' && warn(
      'Do not mount Vue to <html> or <body> - mount to normal elements instead.'
    )
            return this
          }

          var options = this.$options
  // resolve template/el and convert to render function
          if (!options.render) {
            var template = options.template
            if (template) {
              if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                  template = idToTemplate(template)
          /* istanbul ignore if */
                  if ('development' !== 'production' && !template) {
                    warn(
              ('Template element not found or is empty: ' + (options.template)),
              this
            )
                  }
                }
              } else if (template.nodeType) {
                template = template.innerHTML
              } else {
                {
                  warn('invalid template option:' + template, this)
                }
                return this
              }
            } else if (el) {
              template = getOuterHTML(el)
            }
            if (template) {
      /* istanbul ignore if */
              if ('development' !== 'production' && config.performance && mark) {
                mark('compile')
              }

              var ref = compileToFunctions(template, {
                shouldDecodeNewlines: shouldDecodeNewlines,
                shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
              }, this)
              var render = ref.render
              var staticRenderFns = ref.staticRenderFns
              options.render = render
              options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
              if ('development' !== 'production' && config.performance && mark) {
                mark('compile end')
                measure(('vue ' + (this._name) + ' compile'), 'compile', 'compile end')
              }
            }
          }
          return mount.call(this, el, hydrating)
        }

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
        function getOuterHTML (el) {
          if (el.outerHTML) {
            return el.outerHTML
          } else {
            var container = document.createElement('div')
            container.appendChild(el.cloneNode(true))
            return container.innerHTML
          }
        }

        Vue$3.compile = compileToFunctions

        return Vue$3
      }))
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6), __webpack_require__(170).setImmediate))
  /** */ },
/* 184 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray

    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }

    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63

    function placeHoldersCount (b64) {
      var len = b64.length
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
      return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
    }

    function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
      return (b64.length * 3 / 4) - placeHoldersCount(b64)
    }

    function toByteArray (b64) {
      var i, l, tmp, placeHolders, arr
      var len = b64.length
      placeHolders = placeHoldersCount(b64)

      arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len

      var L = 0

      for (i = 0; i < l; i += 4) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
        arr[L++] = (tmp >> 16) & 0xFF
        arr[L++] = (tmp >> 8) & 0xFF
        arr[L++] = tmp & 0xFF
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[L++] = tmp & 0xFF
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[L++] = (tmp >> 8) & 0xFF
        arr[L++] = tmp & 0xFF
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var output = ''
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }

  // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        output += lookup[tmp >> 2]
        output += lookup[(tmp << 4) & 0x3F]
        output += '=='
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
        output += lookup[tmp >> 10]
        output += lookup[(tmp >> 4) & 0x3F]
        output += lookup[(tmp << 2) & 0x3F]
        output += '='
      }

      parts.push(output)

      return parts.join('')
    }
  /** */ },
/* 185 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (global) { /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

      var base64 = __webpack_require__(184)
      var ieee754 = __webpack_require__(425)
      var isArray = __webpack_require__(186)

      exports.Buffer = Buffer
      exports.SlowBuffer = SlowBuffer
      exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
      Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
      exports.kMaxLength = kMaxLength()

      function typedArraySupport () {
        try {
          var arr = new Uint8Array(1)
          arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
          return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
        } catch (e) {
          return false
        }
      }

      function kMaxLength () {
        return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
      }

      function createBuffer (that, length) {
        if (kMaxLength() < length) {
          throw new RangeError('Invalid typed array length')
        }
        if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
          that = new Uint8Array(length)
          that.__proto__ = Buffer.prototype
        } else {
    // Fallback: Return an object instance of the Buffer class
          if (that === null) {
            that = new Buffer(length)
          }
          that.length = length
        }

        return that
      }

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

      function Buffer (arg, encodingOrOffset, length) {
        if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
          return new Buffer(arg, encodingOrOffset, length)
        }

  // Common case.
        if (typeof arg === 'number') {
          if (typeof encodingOrOffset === 'string') {
            throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
          }
          return allocUnsafe(this, arg)
        }
        return from(this, arg, encodingOrOffset, length)
      }

      Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
      Buffer._augment = function (arr) {
        arr.__proto__ = Buffer.prototype
        return arr
      }

      function from (that, value, encodingOrOffset, length) {
        if (typeof value === 'number') {
          throw new TypeError('"value" argument must not be a number')
        }

        if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length)
        }

        if (typeof value === 'string') {
          return fromString(that, value, encodingOrOffset)
        }

        return fromObject(that, value)
      }

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
      Buffer.from = function (value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length)
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array
        if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true
          })
        }
      }

      function assertSize (size) {
        if (typeof size !== 'number') {
          throw new TypeError('"size" argument must be a number')
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative')
        }
      }

      function alloc (that, size, fill, encoding) {
        assertSize(size)
        if (size <= 0) {
          return createBuffer(that, size)
        }
        if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
          return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
        }
        return createBuffer(that, size)
      }

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
      Buffer.alloc = function (size, fill, encoding) {
        return alloc(null, size, fill, encoding)
      }

      function allocUnsafe (that, size) {
        assertSize(size)
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
        if (!Buffer.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0
          }
        }
        return that
      }

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
      Buffer.allocUnsafe = function (size) {
        return allocUnsafe(null, size)
      }
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
      Buffer.allocUnsafeSlow = function (size) {
        return allocUnsafe(null, size)
      }

      function fromString (that, string, encoding) {
        if (typeof encoding !== 'string' || encoding === '') {
          encoding = 'utf8'
        }

        if (!Buffer.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding')
        }

        var length = byteLength(string, encoding) | 0
        that = createBuffer(that, length)

        var actual = that.write(string, encoding)

        if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
          that = that.slice(0, actual)
        }

        return that
      }

      function fromArrayLike (that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0
        that = createBuffer(that, length)
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255
        }
        return that
      }

      function fromArrayBuffer (that, array, byteOffset, length) {
        array.byteLength // this throws if `array` is not a valid ArrayBuffer

        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('\'offset\' is out of bounds')
        }

        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('\'length\' is out of bounds')
        }

        if (byteOffset === undefined && length === undefined) {
          array = new Uint8Array(array)
        } else if (length === undefined) {
          array = new Uint8Array(array, byteOffset)
        } else {
          array = new Uint8Array(array, byteOffset, length)
        }

        if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
          that = array
          that.__proto__ = Buffer.prototype
        } else {
    // Fallback: Return an object instance of the Buffer class
          that = fromArrayLike(that, array)
        }
        return that
      }

      function fromObject (that, obj) {
        if (Buffer.isBuffer(obj)) {
          var len = checked(obj.length) | 0
          that = createBuffer(that, len)

          if (that.length === 0) {
            return that
          }

          obj.copy(that, 0, 0, len)
          return that
        }

        if (obj) {
          if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
            if (typeof obj.length !== 'number' || isnan(obj.length)) {
              return createBuffer(that, 0)
            }
            return fromArrayLike(that, obj)
          }

          if (obj.type === 'Buffer' && isArray(obj.data)) {
            return fromArrayLike(that, obj.data)
          }
        }

        throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
      }

      function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
        if (length >= kMaxLength()) {
          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
        }
        return length | 0
      }

      function SlowBuffer (length) {
        if (+length != length) { // eslint-disable-line eqeqeq
          length = 0
        }
        return Buffer.alloc(+length)
      }

      Buffer.isBuffer = function isBuffer (b) {
        return !!(b != null && b._isBuffer)
      }

      Buffer.compare = function compare (a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
          throw new TypeError('Arguments must be Buffers')
        }

        if (a === b) return 0

        var x = a.length
        var y = b.length

        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i]
            y = b[i]
            break
          }
        }

        if (x < y) return -1
        if (y < x) return 1
        return 0
      }

      Buffer.isEncoding = function isEncoding (encoding) {
        switch (String(encoding).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'latin1':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return true
          default:
            return false
        }
      }

      Buffer.concat = function concat (list, length) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }

        if (list.length === 0) {
          return Buffer.alloc(0)
        }

        var i
        if (length === undefined) {
          length = 0
          for (i = 0; i < list.length; ++i) {
            length += list[i].length
          }
        }

        var buffer = Buffer.allocUnsafe(length)
        var pos = 0
        for (i = 0; i < list.length; ++i) {
          var buf = list[i]
          if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }
          buf.copy(buffer, pos)
          pos += buf.length
        }
        return buffer
      }

      function byteLength (string, encoding) {
        if (Buffer.isBuffer(string)) {
          return string.length
        }
        if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength
        }
        if (typeof string !== 'string') {
          string = '' + string
        }

        var len = string.length
        if (len === 0) return 0

  // Use a for loop to avoid recursion
        var loweredCase = false
        for (;;) {
          switch (encoding) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return len
            case 'utf8':
            case 'utf-8':
            case undefined:
              return utf8ToBytes(string).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return len * 2
            case 'hex':
              return len >>> 1
            case 'base64':
              return base64ToBytes(string).length
            default:
              if (loweredCase) return utf8ToBytes(string).length // assume utf8
              encoding = ('' + encoding).toLowerCase()
              loweredCase = true
          }
        }
      }
      Buffer.byteLength = byteLength

      function slowToString (encoding, start, end) {
        var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
        if (start === undefined || start < 0) {
          start = 0
        }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
        if (start > this.length) {
          return ''
        }

        if (end === undefined || end > this.length) {
          end = this.length
        }

        if (end <= 0) {
          return ''
        }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
        end >>>= 0
        start >>>= 0

        if (end <= start) {
          return ''
        }

        if (!encoding) encoding = 'utf8'

        while (true) {
          switch (encoding) {
            case 'hex':
              return hexSlice(this, start, end)

            case 'utf8':
            case 'utf-8':
              return utf8Slice(this, start, end)

            case 'ascii':
              return asciiSlice(this, start, end)

            case 'latin1':
            case 'binary':
              return latin1Slice(this, start, end)

            case 'base64':
              return base64Slice(this, start, end)

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return utf16leSlice(this, start, end)

            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = (encoding + '').toLowerCase()
              loweredCase = true
          }
        }
      }

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
      Buffer.prototype._isBuffer = true

      function swap (b, n, m) {
        var i = b[n]
        b[n] = b[m]
        b[m] = i
      }

      Buffer.prototype.swap16 = function swap16 () {
        var len = this.length
        if (len % 2 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 16-bits')
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1)
        }
        return this
      }

      Buffer.prototype.swap32 = function swap32 () {
        var len = this.length
        if (len % 4 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 32-bits')
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3)
          swap(this, i + 1, i + 2)
        }
        return this
      }

      Buffer.prototype.swap64 = function swap64 () {
        var len = this.length
        if (len % 8 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 64-bits')
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7)
          swap(this, i + 1, i + 6)
          swap(this, i + 2, i + 5)
          swap(this, i + 3, i + 4)
        }
        return this
      }

      Buffer.prototype.toString = function toString () {
        var length = this.length | 0
        if (length === 0) return ''
        if (arguments.length === 0) return utf8Slice(this, 0, length)
        return slowToString.apply(this, arguments)
      }

      Buffer.prototype.equals = function equals (b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
        if (this === b) return true
        return Buffer.compare(this, b) === 0
      }

      Buffer.prototype.inspect = function inspect () {
        var str = ''
        var max = exports.INSPECT_MAX_BYTES
        if (this.length > 0) {
          str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
          if (this.length > max) str += ' ... '
        }
        return '<Buffer ' + str + '>'
      }

      Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
        if (!Buffer.isBuffer(target)) {
          throw new TypeError('Argument must be a Buffer')
        }

        if (start === undefined) {
          start = 0
        }
        if (end === undefined) {
          end = target ? target.length : 0
        }
        if (thisStart === undefined) {
          thisStart = 0
        }
        if (thisEnd === undefined) {
          thisEnd = this.length
        }

        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError('out of range index')
        }

        if (thisStart >= thisEnd && start >= end) {
          return 0
        }
        if (thisStart >= thisEnd) {
          return -1
        }
        if (start >= end) {
          return 1
        }

        start >>>= 0
        end >>>= 0
        thisStart >>>= 0
        thisEnd >>>= 0

        if (this === target) return 0

        var x = thisEnd - thisStart
        var y = end - start
        var len = Math.min(x, y)

        var thisCopy = this.slice(thisStart, thisEnd)
        var targetCopy = target.slice(start, end)

        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i]
            y = targetCopy[i]
            break
          }
        }

        if (x < y) return -1
        if (y < x) return 1
        return 0
      }

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
      function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
        if (buffer.length === 0) return -1

  // Normalize byteOffset
        if (typeof byteOffset === 'string') {
          encoding = byteOffset
          byteOffset = 0
        } else if (byteOffset > 0x7fffffff) {
          byteOffset = 0x7fffffff
        } else if (byteOffset < -0x80000000) {
          byteOffset = -0x80000000
        }
        byteOffset = +byteOffset  // Coerce to Number.
        if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
          byteOffset = dir ? 0 : (buffer.length - 1)
        }

  // Normalize byteOffset: negative offsets start from the end of the buffer
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset
        if (byteOffset >= buffer.length) {
          if (dir) return -1
          else byteOffset = buffer.length - 1
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0
          else return -1
        }

  // Normalize val
        if (typeof val === 'string') {
          val = Buffer.from(val, encoding)
        }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
        if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
          if (val.length === 0) {
            return -1
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
        } else if (typeof val === 'number') {
          val = val & 0xFF // Search for a byte value [0-255]
          if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
        }

        throw new TypeError('val must be string, number or Buffer')
      }

      function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
        var indexSize = 1
        var arrLength = arr.length
        var valLength = val.length

        if (encoding !== undefined) {
          encoding = String(encoding).toLowerCase()
          if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
              return -1
            }
            indexSize = 2
            arrLength /= 2
            valLength /= 2
            byteOffset /= 2
          }
        }

        function read (buf, i) {
          if (indexSize === 1) {
            return buf[i]
          } else {
            return buf.readUInt16BE(i * indexSize)
          }
        }

        var i
        if (dir) {
          var foundIndex = -1
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
            } else {
              if (foundIndex !== -1) i -= i - foundIndex
              foundIndex = -1
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
          for (i = byteOffset; i >= 0; i--) {
            var found = true
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false
                break
              }
            }
            if (found) return i
          }
        }

        return -1
      }

      Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1
      }

      Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
      }

      Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
      }

      function hexWrite (buf, string, offset, length) {
        offset = Number(offset) || 0
        var remaining = buf.length - offset
        if (!length) {
          length = remaining
        } else {
          length = Number(length)
          if (length > remaining) {
            length = remaining
          }
        }

  // must be an even number of digits
        var strLen = string.length
        if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

        if (length > strLen / 2) {
          length = strLen / 2
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16)
          if (isNaN(parsed)) return i
          buf[offset + i] = parsed
        }
        return i
      }

      function utf8Write (buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
      }

      function asciiWrite (buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length)
      }

      function latin1Write (buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length)
      }

      function base64Write (buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length)
      }

      function ucs2Write (buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
      }

      Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
        if (offset === undefined) {
          encoding = 'utf8'
          length = this.length
          offset = 0
  // Buffer#write(string, encoding)
        } else if (length === undefined && typeof offset === 'string') {
          encoding = offset
          length = this.length
          offset = 0
  // Buffer#write(string, offset[, length][, encoding])
        } else if (isFinite(offset)) {
          offset = offset | 0
          if (isFinite(length)) {
            length = length | 0
            if (encoding === undefined) encoding = 'utf8'
          } else {
            encoding = length
            length = undefined
          }
  // legacy write(string, encoding, offset, length) - remove in v0.13
        } else {
          throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
        }

        var remaining = this.length - offset
        if (length === undefined || length > remaining) length = remaining

        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
          throw new RangeError('Attempt to write outside buffer bounds')
        }

        if (!encoding) encoding = 'utf8'

        var loweredCase = false
        for (;;) {
          switch (encoding) {
            case 'hex':
              return hexWrite(this, string, offset, length)

            case 'utf8':
            case 'utf-8':
              return utf8Write(this, string, offset, length)

            case 'ascii':
              return asciiWrite(this, string, offset, length)

            case 'latin1':
            case 'binary':
              return latin1Write(this, string, offset, length)

            case 'base64':
        // Warning: maxLength not taken into account in base64Write
              return base64Write(this, string, offset, length)

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ucs2Write(this, string, offset, length)

            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = ('' + encoding).toLowerCase()
              loweredCase = true
          }
        }
      }

      Buffer.prototype.toJSON = function toJSON () {
        return {
          type: 'Buffer',
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      }

      function base64Slice (buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf)
        } else {
          return base64.fromByteArray(buf.slice(start, end))
        }
      }

      function utf8Slice (buf, start, end) {
        end = Math.min(buf.length, end)
        var res = []

        var i = start
        while (i < end) {
          var firstByte = buf[i]
          var codePoint = null
          var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint

            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 0x80) {
                  codePoint = firstByte
                }
                break
              case 2:
                secondByte = buf[i + 1]
                if ((secondByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                  if (tempCodePoint > 0x7F) {
                    codePoint = tempCodePoint
                  }
                }
                break
              case 3:
                secondByte = buf[i + 1]
                thirdByte = buf[i + 2]
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                    codePoint = tempCodePoint
                  }
                }
                break
              case 4:
                secondByte = buf[i + 1]
                thirdByte = buf[i + 2]
                fourthByte = buf[i + 3]
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                    codePoint = tempCodePoint
                  }
                }
            }
          }

          if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD
            bytesPerSequence = 1
          } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000
            res.push(codePoint >>> 10 & 0x3FF | 0xD800)
            codePoint = 0xDC00 | codePoint & 0x3FF
          }

          res.push(codePoint)
          i += bytesPerSequence
        }

        return decodeCodePointsArray(res)
      }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
      var MAX_ARGUMENTS_LENGTH = 0x1000

      function decodeCodePointsArray (codePoints) {
        var len = codePoints.length
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
        }

  // Decode in chunks to avoid "call stack size exceeded".
        var res = ''
        var i = 0
        while (i < len) {
          res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
        }
        return res
      }

      function asciiSlice (buf, start, end) {
        var ret = ''
        end = Math.min(buf.length, end)

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 0x7F)
        }
        return ret
      }

      function latin1Slice (buf, start, end) {
        var ret = ''
        end = Math.min(buf.length, end)

        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i])
        }
        return ret
      }

      function hexSlice (buf, start, end) {
        var len = buf.length

        if (!start || start < 0) start = 0
        if (!end || end < 0 || end > len) end = len

        var out = ''
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i])
        }
        return out
      }

      function utf16leSlice (buf, start, end) {
        var bytes = buf.slice(start, end)
        var res = ''
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
        }
        return res
      }

      Buffer.prototype.slice = function slice (start, end) {
        var len = this.length
        start = ~~start
        end = end === undefined ? len : ~~end

        if (start < 0) {
          start += len
          if (start < 0) start = 0
        } else if (start > len) {
          start = len
        }

        if (end < 0) {
          end += len
          if (end < 0) end = 0
        } else if (end > len) {
          end = len
        }

        if (end < start) end = start

        var newBuf
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end)
          newBuf.__proto__ = Buffer.prototype
        } else {
          var sliceLen = end - start
          newBuf = new Buffer(sliceLen, undefined)
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start]
          }
        }

        return newBuf
      }

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
      function checkOffset (offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
      }

      Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)

        var val = this[offset]
        var mul = 1
        var i = 0
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul
        }

        return val
      }

      Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) {
          checkOffset(offset, byteLength, this.length)
        }

        var val = this[offset + --byteLength]
        var mul = 1
        while (byteLength > 0 && (mul *= 0x100)) {
          val += this[offset + --byteLength] * mul
        }

        return val
      }

      Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length)
        return this[offset]
      }

      Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        return this[offset] | (this[offset + 1] << 8)
      }

      Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        return (this[offset] << 8) | this[offset + 1]
      }

      Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)

        return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
      }

      Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)

        return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
      }

      Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)

        var val = this[offset]
        var mul = 1
        var i = 0
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul
        }
        mul *= 0x80

        if (val >= mul) val -= Math.pow(2, 8 * byteLength)

        return val
      }

      Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)

        var i = byteLength
        var mul = 1
        var val = this[offset + --i]
        while (i > 0 && (mul *= 0x100)) {
          val += this[offset + --i] * mul
        }
        mul *= 0x80

        if (val >= mul) val -= Math.pow(2, 8 * byteLength)

        return val
      }

      Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length)
        if (!(this[offset] & 0x80)) return (this[offset])
        return ((0xff - this[offset] + 1) * -1)
      }

      Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        var val = this[offset] | (this[offset + 1] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      }

      Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        var val = this[offset + 1] | (this[offset] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      }

      Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)

        return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
      }

      Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)

        return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
      }

      Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ieee754.read(this, offset, true, 23, 4)
      }

      Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ieee754.read(this, offset, false, 23, 4)
      }

      Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length)
        return ieee754.read(this, offset, true, 52, 8)
      }

      Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length)
        return ieee754.read(this, offset, false, 52, 8)
      }

      function checkInt (buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
      }

      Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1
          checkInt(this, value, offset, byteLength, maxBytes, 0)
        }

        var mul = 1
        var i = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF
        }

        return offset + byteLength
      }

      Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1
          checkInt(this, value, offset, byteLength, maxBytes, 0)
        }

        var i = byteLength - 1
        var mul = 1
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF
        }

        return offset + byteLength
      }

      Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
        this[offset] = (value & 0xff)
        return offset + 1
      }

      function objectWriteUInt16 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffff + value + 1
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
          buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
        }
      }

      Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
        } else {
          objectWriteUInt16(this, value, offset, true)
        }
        return offset + 2
      }

      Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
        } else {
          objectWriteUInt16(this, value, offset, false)
        }
        return offset + 2
      }

      function objectWriteUInt32 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffffffff + value + 1
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
          buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
        }
      }

      Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = (value >>> 24)
          this[offset + 2] = (value >>> 16)
          this[offset + 1] = (value >>> 8)
          this[offset] = (value & 0xff)
        } else {
          objectWriteUInt32(this, value, offset, true)
        }
        return offset + 4
      }

      Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
        } else {
          objectWriteUInt32(this, value, offset, false)
        }
        return offset + 4
      }

      Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1)

          checkInt(this, value, offset, byteLength, limit - 1, -limit)
        }

        var i = 0
        var mul = 1
        var sub = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
        }

        return offset + byteLength
      }

      Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1)

          checkInt(this, value, offset, byteLength, limit - 1, -limit)
        }

        var i = byteLength - 1
        var mul = 1
        var sub = 0
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
        }

        return offset + byteLength
      }

      Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
        if (value < 0) value = 0xff + value + 1
        this[offset] = (value & 0xff)
        return offset + 1
      }

      Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
        } else {
          objectWriteUInt16(this, value, offset, true)
        }
        return offset + 2
      }

      Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
        } else {
          objectWriteUInt16(this, value, offset, false)
        }
        return offset + 2
      }

      Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          this[offset + 2] = (value >>> 16)
          this[offset + 3] = (value >>> 24)
        } else {
          objectWriteUInt32(this, value, offset, true)
        }
        return offset + 4
      }

      Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (value < 0) value = 0xffffffff + value + 1
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
        } else {
          objectWriteUInt32(this, value, offset, false)
        }
        return offset + 4
      }

      function checkIEEE754 (buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
        if (offset < 0) throw new RangeError('Index out of range')
      }

      function writeFloat (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4)
        return offset + 4
      }

      Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
      }

      Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
      }

      function writeDouble (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8)
        return offset + 8
      }

      Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
      }

      Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
      }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
      Buffer.prototype.copy = function copy (target, targetStart, start, end) {
        if (!start) start = 0
        if (!end && end !== 0) end = this.length
        if (targetStart >= target.length) targetStart = target.length
        if (!targetStart) targetStart = 0
        if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
        if (end === start) return 0
        if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
        if (targetStart < 0) {
          throw new RangeError('targetStart out of bounds')
        }
        if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
        if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
        if (end > this.length) end = this.length
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start
        }

        var len = end - start
        var i

        if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start]
          }
        } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start]
          }
        } else {
          Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
        }

        return len
      }

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
      Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
        if (typeof val === 'string') {
          if (typeof start === 'string') {
            encoding = start
            start = 0
            end = this.length
          } else if (typeof end === 'string') {
            encoding = end
            end = this.length
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0)
            if (code < 256) {
              val = code
            }
          }
          if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string')
          }
          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding)
          }
        } else if (typeof val === 'number') {
          val = val & 255
        }

  // Invalid ranges are not set to a default, so can range check early.
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError('Out of range index')
        }

        if (end <= start) {
          return this
        }

        start = start >>> 0
        end = end === undefined ? this.length : end >>> 0

        if (!val) val = 0

        var i
        if (typeof val === 'number') {
          for (i = start; i < end; ++i) {
            this[i] = val
          }
        } else {
          var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
          var len = bytes.length
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len]
          }
        }

        return this
      }

// HELPER FUNCTIONS
// ================

      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

      function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
        str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
        if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
        while (str.length % 4 !== 0) {
          str = str + '='
        }
        return str
      }

      function stringtrim (str) {
        if (str.trim) return str.trim()
        return str.replace(/^\s+|\s+$/g, '')
      }

      function toHex (n) {
        if (n < 16) return '0' + n.toString(16)
        return n.toString(16)
      }

      function utf8ToBytes (string, units) {
        units = units || Infinity
        var codePoint
        var length = string.length
        var leadSurrogate = null
        var bytes = []

        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i)

    // is surrogate component
          if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
            if (!leadSurrogate) {
        // no lead yet
              if (codePoint > 0xDBFF) {
          // unexpected trail
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                continue
              } else if (i + 1 === length) {
          // unpaired lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                continue
              }

        // valid lead
              leadSurrogate = codePoint

              continue
            }

      // 2 leads in a row
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              leadSurrogate = codePoint
              continue
            }

      // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
          } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          }

          leadSurrogate = null

    // encode utf8
          if (codePoint < 0x80) {
            if ((units -= 1) < 0) break
            bytes.push(codePoint)
          } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break
            bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
          } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break
            bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
          } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break
            bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
          } else {
            throw new Error('Invalid code point')
          }
        }

        return bytes
      }

      function asciiToBytes (str) {
        var byteArray = []
        for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
          byteArray.push(str.charCodeAt(i) & 0xFF)
        }
        return byteArray
      }

      function utf16leToBytes (str, units) {
        var c, hi, lo
        var byteArray = []
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break

          c = str.charCodeAt(i)
          hi = c >> 8
          lo = c % 256
          byteArray.push(lo)
          byteArray.push(hi)
        }

        return byteArray
      }

      function base64ToBytes (str) {
        return base64.toByteArray(base64clean(str))
      }

      function blitBuffer (src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if ((i + offset >= dst.length) || (i >= src.length)) break
          dst[i + offset] = src[i]
        }
        return i
      }

      function isnan (val) {
        return val !== val // eslint-disable-line no-self-compare
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6)))
  /** */ },
/* 186 */
  /** */ function (module, exports) {
    var toString = {}.toString

    module.exports = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]'
    }
  /** */ },
/* 187 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var used = [],
      exports = module.exports = {}

/*!
 * Chai version
 */

    exports.version = '3.5.0'

/*!
 * Assertion Error
 */

    exports.AssertionError = __webpack_require__(113)

/*!
 * Utils for plugins (not exported)
 */

    var util = __webpack_require__(201)

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

    exports.use = function (fn) {
      if (!~used.indexOf(fn)) {
        fn(this, util)
        used.push(fn)
      }

      return this
    }

/*!
 * Utility Functions
 */

    exports.util = util

/*!
 * Configuration
 */

    var config = __webpack_require__(50)
    exports.config = config

/*!
 * Primary `Assertion` prototype
 */

    var assertion = __webpack_require__(188)
    exports.use(assertion)

/*!
 * Core Assertions
 */

    var core = __webpack_require__(189)
    exports.use(core)

/*!
 * Expect interface
 */

    var expect = __webpack_require__(191)
    exports.use(expect)

/*!
 * Should interface
 */

    var should = __webpack_require__(192)
    exports.use(should)

/*!
 * Assert interface
 */

    var assert = __webpack_require__(190)
    exports.use(assert)
  /** */ },
/* 188 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var config = __webpack_require__(50)

    module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

      var AssertionError = _chai.AssertionError,
        flag = util.flag

  /*!
   * Module export.
   */

      _chai.Assertion = Assertion

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

      function Assertion (obj, msg, stack) {
        flag(this, 'ssfi', stack || arguments.callee)
        flag(this, 'object', obj)
        flag(this, 'message', msg)
      }

      Object.defineProperty(Assertion, 'includeStack', {
        get: function () {
          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.')
          return config.includeStack
        },
        set: function (value) {
          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.')
          config.includeStack = value
        }
      })

      Object.defineProperty(Assertion, 'showDiff', {
        get: function () {
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.')
          return config.showDiff
        },
        set: function (value) {
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.')
          config.showDiff = value
        }
      })

      Assertion.addProperty = function (name, fn) {
        util.addProperty(this.prototype, name, fn)
      }

      Assertion.addMethod = function (name, fn) {
        util.addMethod(this.prototype, name, fn)
      }

      Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
        util.addChainableMethod(this.prototype, name, fn, chainingBehavior)
      }

      Assertion.overwriteProperty = function (name, fn) {
        util.overwriteProperty(this.prototype, name, fn)
      }

      Assertion.overwriteMethod = function (name, fn) {
        util.overwriteMethod(this.prototype, name, fn)
      }

      Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
        util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior)
      }

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

      Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
        var ok = util.test(this, arguments)
        if (showDiff !== true) showDiff = false
        if (config.showDiff !== true) showDiff = false

        if (!ok) {
          var msg = util.getMessage(this, arguments),
            actual = util.getActual(this, arguments)
          throw new AssertionError(msg, {
            actual: actual,
            expected: expected,
            showDiff: showDiff
          }, (config.includeStack) ? this.assert : flag(this, 'ssfi'))
        }
      }

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

      Object.defineProperty(Assertion.prototype, '_obj',
        { get: function () {
          return flag(this, 'object')
        },
          set: function (val) {
            flag(this, 'object', val)
          }
        })
    }
  /** */ },
/* 189 */
  /** */ function (module, exports) {
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function (chai, _) {
      var Assertion = chai.Assertion,
        toString = Object.prototype.toString,
        flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

      ['to', 'be', 'been',
        'is', 'and', 'has', 'have',
        'with', 'that', 'which', 'at',
        'of', 'same'].forEach(function (chain) {
          Assertion.addProperty(chain, function () {
            return this
          })
        })

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('not', function () {
        flag(this, 'negate', true)
      })

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('deep', function () {
        flag(this, 'deep', true)
      })

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('any', function () {
        flag(this, 'any', true)
        flag(this, 'all', false)
      })

  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('all', function () {
        flag(this, 'all', true)
        flag(this, 'any', false)
      })

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function an (type, msg) {
        if (msg) flag(this, 'message', msg)
        type = type.toLowerCase()
        var obj = flag(this, 'object'),
          article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a '

        this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    )
      }

      Assertion.addChainableMethod('an', an)
      Assertion.addChainableMethod('a', an)

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function includeChainingBehavior () {
        flag(this, 'contains', true)
      }

      function include (val, msg) {
        _.expectTypes(this, ['array', 'object', 'string'])

        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        var expected = false

        if (_.type(obj) === 'array' && _.type(val) === 'object') {
          for (var i in obj) {
            if (_.eql(obj[i], val)) {
              expected = true
              break
            }
          }
        } else if (_.type(val) === 'object') {
          if (!flag(this, 'negate')) {
            for (var k in val) new Assertion(obj).property(k, val[k])
            return
          }
          var subset = {}
          for (var k in val) subset[k] = obj[k]
          expected = _.eql(subset, val)
        } else {
          expected = (obj != undefined) && ~obj.indexOf(val)
        }
        this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val))
      }

      Assertion.addChainableMethod('include', include, includeChainingBehavior)
      Assertion.addChainableMethod('contain', include, includeChainingBehavior)
      Assertion.addChainableMethod('contains', include, includeChainingBehavior)
      Assertion.addChainableMethod('includes', include, includeChainingBehavior)

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everything').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('ok', function () {
        this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy')
      })

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('true', function () {
        this.assert(
        flag(this, 'object') === true
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , !this.negate
    )
      })

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('false', function () {
        this.assert(
        flag(this, 'object') === false
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , !!this.negate
    )
      })

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('null', function () {
        this.assert(
        flag(this, 'object') === null
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    )
      })

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('undefined', function () {
        this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    )
      })

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('NaN', function () {
        this.assert(
        isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    )
      })

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('exist', function () {
        this.assert(
        flag(this, 'object') != null
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    )
      })

  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('empty', function () {
        var obj = flag(this, 'object'),
          expected = obj

        if (Array.isArray(obj) || typeof object === 'string') {
          expected = obj.length
        } else if (typeof obj === 'object') {
          expected = Object.keys(obj).length
        }

        this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    )
      })

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

      function checkArguments () {
        var obj = flag(this, 'object'),
          type = Object.prototype.toString.call(obj)
        this.assert(
        type === '[object Arguments]'
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    )
      }

      Assertion.addProperty('arguments', checkArguments)
      Assertion.addProperty('Arguments', checkArguments)

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertEqual (val, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        if (flag(this, 'deep')) {
          return this.eql(val)
        } else {
          this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      )
        }
      }

      Assertion.addMethod('equal', assertEqual)
      Assertion.addMethod('equals', assertEqual)
      Assertion.addMethod('eq', assertEqual)

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertEql (obj, msg) {
        if (msg) flag(this, 'message', msg)
        this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    )
      }

      Assertion.addMethod('eql', assertEql)
      Assertion.addMethod('eqls', assertEql)

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertAbove (n, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        if (flag(this, 'doLength')) {
          new Assertion(obj, msg).to.have.property('length')
          var len = obj.length
          this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      )
        } else {
          this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      )
        }
      }

      Assertion.addMethod('above', assertAbove)
      Assertion.addMethod('gt', assertAbove)
      Assertion.addMethod('greaterThan', assertAbove)

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertLeast (n, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        if (flag(this, 'doLength')) {
          new Assertion(obj, msg).to.have.property('length')
          var len = obj.length
          this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      )
        } else {
          this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      )
        }
      }

      Assertion.addMethod('least', assertLeast)
      Assertion.addMethod('gte', assertLeast)

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertBelow (n, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        if (flag(this, 'doLength')) {
          new Assertion(obj, msg).to.have.property('length')
          var len = obj.length
          this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      )
        } else {
          this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      )
        }
      }

      Assertion.addMethod('below', assertBelow)
      Assertion.addMethod('lt', assertBelow)
      Assertion.addMethod('lessThan', assertBelow)

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertMost (n, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        if (flag(this, 'doLength')) {
          new Assertion(obj, msg).to.have.property('length')
          var len = obj.length
          this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      )
        } else {
          this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      )
        }
      }

      Assertion.addMethod('most', assertMost)
      Assertion.addMethod('lte', assertMost)

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      Assertion.addMethod('within', function (start, finish, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object'),
          range = start + '..' + finish
        if (flag(this, 'doLength')) {
          new Assertion(obj, msg).to.have.property('length')
          var len = obj.length
          this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      )
        } else {
          this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      )
        }
      })

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

      function assertInstanceOf (constructor, msg) {
        if (msg) flag(this, 'message', msg)
        var name = _.getName(constructor)
        this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    )
      };

      Assertion.addMethod('instanceof', assertInstanceOf)
      Assertion.addMethod('instanceOf', assertInstanceOf)

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

      Assertion.addMethod('property', function (name, val, msg) {
        if (msg) flag(this, 'message', msg)

        var isDeep = !!flag(this, 'deep'),
          descriptor = isDeep ? 'deep property ' : 'property ',
          negate = flag(this, 'negate'),
          obj = flag(this, 'object'),
          pathInfo = isDeep ? _.getPathInfo(name, obj) : null,
          hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj),
          value = isDeep
        ? pathInfo.value
        : obj[name]

        if (negate && arguments.length > 1) {
          if (undefined === value) {
            msg = (msg != null) ? msg + ': ' : ''
            throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name))
          }
        } else {
          this.assert(
          hasProperty
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name))
        }

        if (arguments.length > 1) {
          this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      )
        }

        flag(this, 'object', value)
      })

  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertOwnProperty (name, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    )
      }

      Assertion.addMethod('ownProperty', assertOwnProperty)
      Assertion.addMethod('haveOwnProperty', assertOwnProperty)

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertOwnPropertyDescriptor (name, descriptor, msg) {
        if (typeof descriptor === 'string') {
          msg = descriptor
          descriptor = null
        }
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name)
        if (actualDescriptor && descriptor) {
          this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      )
        } else {
          this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      )
        }
        flag(this, 'object', actualDescriptor)
      }

      Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor)
      Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor)

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @namespace BDD
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertLengthChain () {
        flag(this, 'doLength', true)
      }

      function assertLength (n, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        new Assertion(obj, msg).to.have.property('length')
        var len = obj.length

        this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    )
      }

      Assertion.addChainableMethod('length', assertLength, assertLengthChain)
      Assertion.addMethod('lengthOf', assertLength)

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */
      function assertMatch (re, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    )
      }

      Assertion.addMethod('match', assertMatch)
      Assertion.addMethod('matches', assertMatch)

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      Assertion.addMethod('string', function (str, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        new Assertion(obj, msg).is.a('string')

        this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    )
      })

  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

      function assertKeys (keys) {
        var obj = flag(this, 'object'),
          str,
          ok = true,
          mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments'

        switch (_.type(keys)) {
          case 'array':
            if (arguments.length > 1) throw (new Error(mixedArgsMsg))
            break
          case 'object':
            if (arguments.length > 1) throw (new Error(mixedArgsMsg))
            keys = Object.keys(keys)
            break
          default:
            keys = Array.prototype.slice.call(arguments)
        }

        if (!keys.length) throw new Error('keys required')

        var actual = Object.keys(obj),
          expected = keys,
          len = keys.length,
          any = flag(this, 'any'),
          all = flag(this, 'all')

        if (!any && !all) {
          all = true
        }

    // Has any
        if (any) {
          var intersection = expected.filter(function (key) {
            return ~actual.indexOf(key)
          })
          ok = intersection.length > 0
        }

    // Has all
        if (all) {
          ok = keys.every(function (key) {
            return ~actual.indexOf(key)
          })
          if (!flag(this, 'negate') && !flag(this, 'contains')) {
            ok = ok && keys.length == actual.length
          }
        }

    // Key string
        if (len > 1) {
          keys = keys.map(function (key) {
            return _.inspect(key)
          })
          var last = keys.pop()
          if (all) {
            str = keys.join(', ') + ', and ' + last
          }
          if (any) {
            str = keys.join(', ') + ', or ' + last
          }
        } else {
          str = _.inspect(keys[0])
        }

    // Form
        str = (len > 1 ? 'keys ' : 'key ') + str

    // Have / include
        str = (flag(this, 'contains') ? 'contain ' : 'have ') + str

    // Assertion
        this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    )
      }

      Assertion.addMethod('keys', assertKeys)
      Assertion.addMethod('key', assertKeys)

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

      function assertThrows (constructor, errMsg, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        new Assertion(obj, msg).is.a('function')

        var thrown = false,
          desiredError = null,
          name = null,
          thrownError = null

        if (arguments.length === 0) {
          errMsg = null
          constructor = null
        } else if (constructor && (constructor instanceof RegExp || typeof constructor === 'string')) {
          errMsg = constructor
          constructor = null
        } else if (constructor && constructor instanceof Error) {
          desiredError = constructor
          constructor = null
          errMsg = null
        } else if (typeof constructor === 'function') {
          name = constructor.prototype.name
          if (!name || (name === 'Error' && constructor !== Error)) {
            name = constructor.name || (new constructor()).name
          }
        } else {
          constructor = null
        }

        try {
          obj()
        } catch (err) {
      // first, check desired error
          if (desiredError) {
            this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        )

            flag(this, 'object', err)
            return this
          }

      // next, check constructor
          if (constructor) {
            this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        )

            if (!errMsg) {
              flag(this, 'object', err)
              return this
            }
          }

      // next, check message
          var message = _.type(err) === 'error' && 'message' in err
        ? err.message
        : '' + err

          if ((message != null) && errMsg && errMsg instanceof RegExp) {
            this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        )

            flag(this, 'object', err)
            return this
          } else if ((message != null) && errMsg && typeof errMsg === 'string') {
            this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        )

            flag(this, 'object', err)
            return this
          } else {
            thrown = true
            thrownError = err
          }
        }

        var actuallyGot = '',
          expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' // _.inspect(desiredError)
          : 'an error'

        if (thrown) {
          actuallyGot = ' but #{act} was thrown'
        }

        this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    )

        flag(this, 'object', thrownError)
      };

      Assertion.addMethod('throw', assertThrows)
      Assertion.addMethod('throws', assertThrows)
      Assertion.addMethod('Throw', assertThrows)

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function respondTo (method, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object'),
          itself = flag(this, 'itself'),
          context = (_.type(obj) === 'function' && !itself)
        ? obj.prototype[method]
        : obj[method]

        this.assert(
        typeof context === 'function'
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    )
      }

      Assertion.addMethod('respondTo', respondTo)
      Assertion.addMethod('respondsTo', respondTo)

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('itself', function () {
        flag(this, 'itself', true)
      })

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function satisfy (matcher, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')
        var result = matcher(obj)
        this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , !this.negate
      , result
    )
      }

      Assertion.addMethod('satisfy', satisfy)
      Assertion.addMethod('satisfies', satisfy)

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function closeTo (expected, delta, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')

        new Assertion(obj, msg).is.a('number')
        if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
          throw new Error('the arguments to closeTo or approximately must be numbers')
        }

        this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    )
      }

      Assertion.addMethod('closeTo', closeTo)
      Assertion.addMethod('approximately', closeTo)

      function isSubsetOf (subset, superset, cmp) {
        return subset.every(function (elem) {
          if (!cmp) return superset.indexOf(elem) !== -1

          return superset.some(function (elem2) {
            return cmp(elem, elem2)
          })
        })
      }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      Assertion.addMethod('members', function (subset, msg) {
        if (msg) flag(this, 'message', msg)
        var obj = flag(this, 'object')

        new Assertion(obj).to.be.an('array')
        new Assertion(subset).to.be.an('array')

        var cmp = flag(this, 'deep') ? _.eql : undefined

        if (flag(this, 'contains')) {
          return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      )
        }

        this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    )
      })

  /**
   * ### .oneOf(list)
   *
   * Assert that a value appears somewhere in the top level of array `list`.
   *
   *     expect('a').to.be.oneOf(['a', 'b', 'c']);
   *     expect(9).to.not.be.oneOf(['z']);
   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
   *
   *     var three = [3];
   *     // for object-types, contents are not compared
   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
   *     // comparing references works
   *     expect(three).to.be.oneOf([1, 2, three]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function oneOf (list, msg) {
        if (msg) flag(this, 'message', msg)
        var expected = flag(this, 'object')
        new Assertion(list).to.be.an('array')

        this.assert(
        list.indexOf(expected) > -1
      , 'expected #{this} to be one of #{exp}'
      , 'expected #{this} to not be one of #{exp}'
      , list
      , expected
    )
      }

      Assertion.addMethod('oneOf', oneOf)

  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangeFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertChanges (object, prop, msg) {
        if (msg) flag(this, 'message', msg)
        var fn = flag(this, 'object')
        new Assertion(object, msg).to.have.property(prop)
        new Assertion(fn).is.a('function')

        var initial = object[prop]
        fn()

        this.assert(
      initial !== object[prop]
      , 'expected .' + prop + ' to change'
      , 'expected .' + prop + ' to not change'
    )
      }

      Assertion.addChainableMethod('change', assertChanges)
      Assertion.addChainableMethod('changes', assertChanges)

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertIncreases (object, prop, msg) {
        if (msg) flag(this, 'message', msg)
        var fn = flag(this, 'object')
        new Assertion(object, msg).to.have.property(prop)
        new Assertion(fn).is.a('function')

        var initial = object[prop]
        fn()

        this.assert(
      object[prop] - initial > 0
      , 'expected .' + prop + ' to increase'
      , 'expected .' + prop + ' to not increase'
    )
      }

      Assertion.addChainableMethod('increase', assertIncreases)
      Assertion.addChainableMethod('increases', assertIncreases)

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

      function assertDecreases (object, prop, msg) {
        if (msg) flag(this, 'message', msg)
        var fn = flag(this, 'object')
        new Assertion(object, msg).to.have.property(prop)
        new Assertion(fn).is.a('function')

        var initial = object[prop]
        fn()

        this.assert(
      object[prop] - initial < 0
      , 'expected .' + prop + ' to decrease'
      , 'expected .' + prop + ' to not decrease'
    )
      }

      Assertion.addChainableMethod('decrease', assertDecreases)
      Assertion.addChainableMethod('decreases', assertDecreases)

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('extensible', function () {
        var obj = flag(this, 'object')

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

        var isExtensible

        try {
          isExtensible = Object.isExtensible(obj)
        } catch (err) {
          if (err instanceof TypeError) isExtensible = false
          else throw err
        }

        this.assert(
      isExtensible
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    )
      })

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('sealed', function () {
        var obj = flag(this, 'object')

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

        var isSealed

        try {
          isSealed = Object.isSealed(obj)
        } catch (err) {
          if (err instanceof TypeError) isSealed = true
          else throw err
        }

        this.assert(
      isSealed
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    )
      })

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

      Assertion.addProperty('frozen', function () {
        var obj = flag(this, 'object')

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

        var isFrozen

        try {
          isFrozen = Object.isFrozen(obj)
        } catch (err) {
          if (err instanceof TypeError) isFrozen = true
          else throw err
        }

        this.assert(
      isFrozen
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    )
      })
    }
  /** */ },
/* 190 */
  /** */ function (module, exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function (chai, util) {
  /*!
   * Chai dependencies.
   */

      var Assertion = chai.Assertion,
        flag = util.flag

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

      var assert = chai.assert = function (express, errmsg) {
        var test = new Assertion(null, null, chai.assert)
        test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    )
      }

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

      assert.fail = function (actual, expected, message, operator) {
        message = message || 'assert.fail()'
        throw new chai.AssertionError(message, {
          actual: actual,
          expected: expected,
          operator: operator
        }, assert.fail)
      }

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isOk = function (val, msg) {
        new Assertion(val, msg).is.ok
      }

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotOk = function (val, msg) {
        new Assertion(val, msg).is.not.ok
      }

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.equal = function (act, exp, msg) {
        var test = new Assertion(act, msg, assert.equal)

        test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    )
      }

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notEqual = function (act, exp, msg) {
        var test = new Assertion(act, msg, assert.notEqual)

        test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    )
      }

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.strictEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.equal(exp)
      }

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notStrictEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.not.equal(exp)
      }

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.deepEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.eql(exp)
      }

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notDeepEqual = function (act, exp, msg) {
        new Assertion(act, msg).to.not.eql(exp)
      }

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isAbove = function (val, abv, msg) {
        new Assertion(val, msg).to.be.above(abv)
      }

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isAtLeast = function (val, atlst, msg) {
        new Assertion(val, msg).to.be.least(atlst)
      }

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isBelow = function (val, blw, msg) {
        new Assertion(val, msg).to.be.below(blw)
      }

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isAtMost = function (val, atmst, msg) {
        new Assertion(val, msg).to.be.most(atmst)
      }

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isTrue = function (val, msg) {
        new Assertion(val, msg).is['true']
      }

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotTrue = function (val, msg) {
        new Assertion(val, msg).to.not.equal(true)
      }

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isFalse = function (val, msg) {
        new Assertion(val, msg).is['false']
      }

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotFalse = function (val, msg) {
        new Assertion(val, msg).to.not.equal(false)
      }

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNull = function (val, msg) {
        new Assertion(val, msg).to.equal(null)
      }

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotNull = function (val, msg) {
        new Assertion(val, msg).to.not.equal(null)
      }

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNaN = function (val, msg) {
        new Assertion(val, msg).to.be.NaN
      }

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
      assert.isNotNaN = function (val, msg) {
        new Assertion(val, msg).not.to.be.NaN
      }

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isUndefined = function (val, msg) {
        new Assertion(val, msg).to.equal(undefined)
      }

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isDefined = function (val, msg) {
        new Assertion(val, msg).to.not.equal(undefined)
      }

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isFunction = function (val, msg) {
        new Assertion(val, msg).to.be.a('function')
      }

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotFunction = function (val, msg) {
        new Assertion(val, msg).to.not.be.a('function')
      }

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isObject = function (val, msg) {
        new Assertion(val, msg).to.be.a('object')
      }

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotObject = function (val, msg) {
        new Assertion(val, msg).to.not.be.a('object')
      }

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isArray = function (val, msg) {
        new Assertion(val, msg).to.be.an('array')
      }

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotArray = function (val, msg) {
        new Assertion(val, msg).to.not.be.an('array')
      }

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isString = function (val, msg) {
        new Assertion(val, msg).to.be.a('string')
      }

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotString = function (val, msg) {
        new Assertion(val, msg).to.not.be.a('string')
      }

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNumber = function (val, msg) {
        new Assertion(val, msg).to.be.a('number')
      }

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotNumber = function (val, msg) {
        new Assertion(val, msg).to.not.be.a('number')
      }

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isBoolean = function (val, msg) {
        new Assertion(val, msg).to.be.a('boolean')
      }

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.isNotBoolean = function (val, msg) {
        new Assertion(val, msg).to.not.be.a('boolean')
      }

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.typeOf = function (val, type, msg) {
        new Assertion(val, msg).to.be.a(type)
      }

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notTypeOf = function (val, type, msg) {
        new Assertion(val, msg).to.not.be.a(type)
      }

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.instanceOf = function (val, type, msg) {
        new Assertion(val, msg).to.be.instanceOf(type)
      }

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notInstanceOf = function (val, type, msg) {
        new Assertion(val, msg).to.not.be.instanceOf(type)
      }

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.include = function (exp, inc, msg) {
        new Assertion(exp, msg, assert.include).include(inc)
      }

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notInclude = function (exp, inc, msg) {
        new Assertion(exp, msg, assert.notInclude).not.include(inc)
      }

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.match = function (exp, re, msg) {
        new Assertion(exp, msg).to.match(re)
      }

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notMatch = function (exp, re, msg) {
        new Assertion(exp, msg).to.not.match(re)
      }

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.property = function (obj, prop, msg) {
        new Assertion(obj, msg).to.have.property(prop)
      }

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notProperty = function (obj, prop, msg) {
        new Assertion(obj, msg).to.not.have.property(prop)
      }

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.deepProperty = function (obj, prop, msg) {
        new Assertion(obj, msg).to.have.deep.property(prop)
      }

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.notDeepProperty = function (obj, prop, msg) {
        new Assertion(obj, msg).to.not.have.deep.property(prop)
      }

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.propertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.have.property(prop, val)
      }

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.propertyNotVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.not.have.property(prop, val)
      }

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.deepPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.have.deep.property(prop, val)
      }

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.deepPropertyNotVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg).to.not.have.deep.property(prop, val)
      }

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.lengthOf = function (exp, len, msg) {
        new Assertion(exp, msg).to.have.length(len)
      }

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

      assert.throws = function (fn, errt, errs, msg) {
        if (typeof errt === 'string' || errt instanceof RegExp) {
          errs = errt
          errt = null
        }

        var assertErr = new Assertion(fn, msg).to.throw(errt, errs)
        return flag(assertErr, 'object')
      }

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

      assert.doesNotThrow = function (fn, type, msg) {
        if (typeof type === 'string') {
          msg = type
          type = null
        }

        new Assertion(fn, msg).to.not.Throw(type)
      }

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.operator = function (val, operator, val2, msg) {
        var ok
        switch (operator) {
          case '==':
            ok = val == val2
            break
          case '===':
            ok = val === val2
            break
          case '>':
            ok = val > val2
            break
          case '>=':
            ok = val >= val2
            break
          case '<':
            ok = val < val2
            break
          case '<=':
            ok = val <= val2
            break
          case '!=':
            ok = val != val2
            break
          case '!==':
            ok = val !== val2
            break
          default:
            throw new Error('Invalid operator "' + operator + '"')
        }
        var test = new Assertion(ok, msg)
        test.assert(
        flag(test, 'object') === true
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2))
      }

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.closeTo = function (act, exp, delta, msg) {
        new Assertion(act, msg).to.be.closeTo(exp, delta)
      }

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.approximately = function (act, exp, delta, msg) {
        new Assertion(act, msg).to.be.approximately(exp, delta)
      }

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.sameMembers = function (set1, set2, msg) {
        new Assertion(set1, msg).to.have.same.members(set2)
      }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.sameDeepMembers = function (set1, set2, msg) {
        new Assertion(set1, msg).to.have.same.deep.members(set2)
      }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.includeMembers = function (superset, subset, msg) {
        new Assertion(superset, msg).to.include.members(subset)
      }

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` - using deep equality checking.
   * Order is not taken into account.
   * Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.includeDeepMembers = function (superset, subset, msg) {
        new Assertion(superset, msg).to.include.deep.members(subset)
      }

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

      assert.oneOf = function (inList, list, msg) {
        new Assertion(inList, msg).to.be.oneOf(list)
      }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.changes = function (fn, obj, prop) {
        new Assertion(fn).to.change(obj, prop)
      }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.doesNotChange = function (fn, obj, prop) {
        new Assertion(fn).to.not.change(obj, prop)
      }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.increases = function (fn, obj, prop) {
        new Assertion(fn).to.increase(obj, prop)
      }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.doesNotIncrease = function (fn, obj, prop) {
        new Assertion(fn).to.not.increase(obj, prop)
      }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.decreases = function (fn, obj, prop) {
        new Assertion(fn).to.decrease(obj, prop)
      }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.doesNotDecrease = function (fn, obj, prop) {
        new Assertion(fn).to.not.decrease(obj, prop)
      }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

      assert.ifError = function (val) {
        if (val) {
          throw (val)
        }
      }

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.isExtensible = function (obj, msg) {
        new Assertion(obj, msg).to.be.extensible
      }

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.isNotExtensible = function (obj, msg) {
        new Assertion(obj, msg).to.not.be.extensible
      }

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.isSealed = function (obj, msg) {
        new Assertion(obj, msg).to.be.sealed
      }

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.isNotSealed = function (obj, msg) {
        new Assertion(obj, msg).to.not.be.sealed
      }

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.isFrozen = function (obj, msg) {
        new Assertion(obj, msg).to.be.frozen
      }

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

      assert.isNotFrozen = function (obj, msg) {
        new Assertion(obj, msg).to.not.be.frozen
      };

  /*!
   * Aliases.
   */

      (function alias (name, as) {
        assert[as] = assert[name]
        return alias
      })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')
    }
  /** */ },
/* 191 */
  /** */ function (module, exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function (chai, util) {
      chai.expect = function (val, message) {
        return new chai.Assertion(val, message)
      }

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Expect
   * @api public
   */

      chai.expect.fail = function (actual, expected, message, operator) {
        message = message || 'expect.fail()'
        throw new chai.AssertionError(message, {
          actual: actual,
          expected: expected,
          operator: operator
        }, chai.expect.fail)
      }
    }
  /** */ },
/* 192 */
  /** */ function (module, exports) {
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function (chai, util) {
      var Assertion = chai.Assertion

      function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
        function shouldGetter () {
          if (this instanceof String || this instanceof Number || this instanceof Boolean) {
            return new Assertion(this.valueOf(), null, shouldGetter)
          }
          return new Assertion(this, null, shouldGetter)
        }
        function shouldSetter (value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
          Object.defineProperty(this, 'should', {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          })
        }
    // modify Object.prototype to have `should`
        Object.defineProperty(Object.prototype, 'should', {
          set: shouldSetter,
          get: shouldGetter,
          configurable: true
        })

        var should = {}

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace Should
     * @api public
     */

        should.fail = function (actual, expected, message, operator) {
          message = message || 'should.fail()'
          throw new chai.AssertionError(message, {
            actual: actual,
            expected: expected,
            operator: operator
          }, should.fail)
        }

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

        should.equal = function (val1, val2, msg) {
          new Assertion(val1, msg).to.equal(val2)
        }

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

        should.Throw = function (fn, errt, errs, msg) {
          new Assertion(fn, msg).to.Throw(errt, errs)
        }

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */

        should.exist = function (val, msg) {
          new Assertion(val, msg).to.exist
        }

    // negation
        should.not = {}

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

        should.not.equal = function (val1, val2, msg) {
          new Assertion(val1, msg).to.not.equal(val2)
        }

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

        should.not.Throw = function (fn, errt, errs, msg) {
          new Assertion(fn, msg).to.not.Throw(errt, errs)
        }

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

        should.not.exist = function (val, msg) {
          new Assertion(val, msg).to.not.exist
        }

        should['throw'] = should['Throw']
        should.not['throw'] = should.not['Throw']

        return should
      };

      chai.should = loadShould
      chai.Should = loadShould
    }
  /** */ },
/* 193 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

    var transferFlags = __webpack_require__(119)
    var flag = __webpack_require__(42)
    var config = __webpack_require__(50)

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
    var hasProtoSupport = '__proto__' in Object

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
    var excludeNames = /^(?:length|name|arguments|caller)$/

// Cache `Function` properties
    var call = Function.prototype.call,
      apply = Function.prototype.apply

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

    module.exports = function (ctx, name, method, chainingBehavior) {
      if (typeof chainingBehavior !== 'function') {
        chainingBehavior = function () { }
      }

      var chainableBehavior = {
        method: method,
        chainingBehavior: chainingBehavior
      }

  // save the methods so we can overwrite them later, if we need to.
      if (!ctx.__methods) {
        ctx.__methods = {}
      }
      ctx.__methods[name] = chainableBehavior

      Object.defineProperty(ctx, name,
        { get: function () {
          chainableBehavior.chainingBehavior.call(this)

          var assert = function assert () {
            var old_ssfi = flag(this, 'ssfi')
            if (old_ssfi && config.includeStack === false) { flag(this, 'ssfi', assert) }
            var result = chainableBehavior.method.apply(this, arguments)
            return result === undefined ? this : result
          }

        // Use `__proto__` if available
          if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
            var prototype = assert.__proto__ = Object.create(this)
          // Restore the `call` and `apply` methods from `Function`
            prototype.call = call
            prototype.apply = apply
          }
        // Otherwise, redefine all properties (slow!)
          else {
            var asserterNames = Object.getOwnPropertyNames(ctx)
            asserterNames.forEach(function (asserterName) {
              if (!excludeNames.test(asserterName)) {
                var pd = Object.getOwnPropertyDescriptor(ctx, asserterName)
                Object.defineProperty(assert, asserterName, pd)
              }
            })
          }

          transferFlags(this, assert)
          return assert
        },
          configurable: true
        })
    }
  /** */ },
/* 194 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var config = __webpack_require__(50)

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */
    var flag = __webpack_require__(42)

    module.exports = function (ctx, name, method) {
      ctx[name] = function () {
        var old_ssfi = flag(this, 'ssfi')
        if (old_ssfi && config.includeStack === false) { flag(this, 'ssfi', ctx[name]) }
        var result = method.apply(this, arguments)
        return result === undefined ? this : result
      }
    }
  /** */ },
/* 195 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var config = __webpack_require__(50)
    var flag = __webpack_require__(42)

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

    module.exports = function (ctx, name, getter) {
      Object.defineProperty(ctx, name,
        { get: function addProperty () {
          var old_ssfi = flag(this, 'ssfi')
          if (old_ssfi && config.includeStack === false) { flag(this, 'ssfi', addProperty) }

          var result = getter.call(this)
          return result === undefined ? this : result
        },
          configurable: true
        })
    }
  /** */ },
/* 196 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

    var AssertionError = __webpack_require__(113)
    var flag = __webpack_require__(42)
    var type = __webpack_require__(111)

    module.exports = function (obj, types) {
      var obj = flag(obj, 'object')
      types = types.map(function (t) { return t.toLowerCase() })
      types.sort()

  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'
      var str = types.map(function (t, index) {
        var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a'
        var or = types.length > 1 && index === types.length - 1 ? 'or ' : ''
        return or + art + ' ' + t
      }).join(', ')

      if (!types.some(function (expected) { return type(obj) === expected })) {
        throw new AssertionError(
      'object tested must be ' + str + ', but ' + type(obj) + ' given'
    )
      }
    }
  /** */ },
/* 197 */
  /** */ function (module, exports) {
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */

    module.exports = function getEnumerableProperties (object) {
      var result = []
      for (var name in object) {
        result.push(name)
      }
      return result
    }
  /** */ },
/* 198 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

    var flag = __webpack_require__(42),
      getActual = __webpack_require__(114),
      inspect = __webpack_require__(78),
      objDisplay = __webpack_require__(118)

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

    module.exports = function (obj, args) {
      var negate = flag(obj, 'negate'),
        val = flag(obj, 'object'),
        expected = args[3],
        actual = getActual(obj, args),
        msg = negate ? args[2] : args[1],
        flagMsg = flag(obj, 'message')

      if (typeof msg === 'function') msg = msg()
      msg = msg || ''
      msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val) })
    .replace(/#\{act\}/g, function () { return objDisplay(actual) })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected) })

      return flagMsg ? flagMsg + ': ' + msg : msg
    }
  /** */ },
/* 199 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

    var getPathInfo = __webpack_require__(116)

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */
    module.exports = function (path, obj) {
      var info = getPathInfo(path, obj)
      return info.value
    }
  /** */ },
/* 200 */
  /** */ function (module, exports) {
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

    module.exports = function getProperties (object) {
      var result = Object.getOwnPropertyNames(object)

      function addProperty (property) {
        if (result.indexOf(property) === -1) {
          result.push(property)
        }
      }

      var proto = Object.getPrototypeOf(object)
      while (proto !== null) {
        Object.getOwnPropertyNames(proto).forEach(addProperty)
        proto = Object.getPrototypeOf(proto)
      }

      return result
    }
  /** */ },
/* 201 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

    var exports = module.exports = {}

/*!
 * test utility
 */

    exports.test = __webpack_require__(205)

/*!
 * type utility
 */

    exports.type = __webpack_require__(111)

/*!
 * expectTypes utility
 */
    exports.expectTypes = __webpack_require__(196)

/*!
 * message utility
 */

    exports.getMessage = __webpack_require__(198)

/*!
 * actual utility
 */

    exports.getActual = __webpack_require__(114)

/*!
 * Inspect util
 */

    exports.inspect = __webpack_require__(78)

/*!
 * Object Display util
 */

    exports.objDisplay = __webpack_require__(118)

/*!
 * Flag utility
 */

    exports.flag = __webpack_require__(42)

/*!
 * Flag transferring utility
 */

    exports.transferFlags = __webpack_require__(119)

/*!
 * Deep equal utility
 */

    exports.eql = __webpack_require__(419)

/*!
 * Deep path value
 */

    exports.getPathValue = __webpack_require__(199)

/*!
 * Deep path info
 */

    exports.getPathInfo = __webpack_require__(116)

/*!
 * Check if a property exists
 */

    exports.hasProperty = __webpack_require__(117)

/*!
 * Function name
 */

    exports.getName = __webpack_require__(115)

/*!
 * add Property
 */

    exports.addProperty = __webpack_require__(195)

/*!
 * add Method
 */

    exports.addMethod = __webpack_require__(194)

/*!
 * overwrite Property
 */

    exports.overwriteProperty = __webpack_require__(204)

/*!
 * overwrite Method
 */

    exports.overwriteMethod = __webpack_require__(203)

/*!
 * Add a chainable method
 */

    exports.addChainableMethod = __webpack_require__(193)

/*!
 * Overwrite chainable method
 */

    exports.overwriteChainableMethod = __webpack_require__(202)
  /** */ },
/* 202 */
  /** */ function (module, exports) {
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

    module.exports = function (ctx, name, method, chainingBehavior) {
      var chainableBehavior = ctx.__methods[name]

      var _chainingBehavior = chainableBehavior.chainingBehavior
      chainableBehavior.chainingBehavior = function () {
        var result = chainingBehavior(_chainingBehavior).call(this)
        return result === undefined ? this : result
      }

      var _method = chainableBehavior.method
      chainableBehavior.method = function () {
        var result = method(_method).apply(this, arguments)
        return result === undefined ? this : result
      }
    }
  /** */ },
/* 203 */
  /** */ function (module, exports) {
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

    module.exports = function (ctx, name, method) {
      var _method = ctx[name],
        _super = function () { return this }

      if (_method && typeof _method === 'function') { _super = _method }

      ctx[name] = function () {
        var result = method(_super).apply(this, arguments)
        return result === undefined ? this : result
      }
    }
  /** */ },
/* 204 */
  /** */ function (module, exports) {
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

    module.exports = function (ctx, name, getter) {
      var _get = Object.getOwnPropertyDescriptor(ctx, name),
        _super = function () {}

      if (_get && typeof _get.get === 'function') { _super = _get.get }

      Object.defineProperty(ctx, name,
        { get: function () {
          var result = getter(_super).call(this)
          return result === undefined ? this : result
        },
          configurable: true
        })
    }
  /** */ },
/* 205 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

    var flag = __webpack_require__(42)

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

    module.exports = function (obj, args) {
      var negate = flag(obj, 'negate'),
        expr = args[0]
      return negate ? !expr : expr
    }
  /** */ },
/* 206 */
  /** */ function (module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4)
    var isArray = __webpack_require__(66)
    var SPECIES = __webpack_require__(9)('species')

    module.exports = function (original) {
      var C
      if (isArray(original)) {
        C = original.constructor
    // cross-realm fallback
        if (typeof C === 'function' && (C === Array || isArray(C.prototype))) C = undefined
        if (isObject(C)) {
          C = C[SPECIES]
          if (C === null) C = undefined
        }
      } return C === undefined ? Array : C
    }
  /** */ },
/* 207 */
  /** */ function (module, exports, __webpack_require__) {
// all enumerable object keys, includes symbols
    var getKeys = __webpack_require__(38)
    var gOPS = __webpack_require__(70)
    var pIE = __webpack_require__(58)
    module.exports = function (it) {
      var result = getKeys(it)
      var getSymbols = gOPS.f
      if (getSymbols) {
        var symbols = getSymbols(it)
        var isEnum = pIE.f
        var i = 0
        var key
        while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key)
      } return result
    }
  /** */ },
/* 208 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 21.2.5.3 get RegExp.prototype.flags
    var anObject = __webpack_require__(1)
    module.exports = function () {
      var that = anObject(this)
      var result = ''
      if (that.global) result += 'g'
      if (that.ignoreCase) result += 'i'
      if (that.multiline) result += 'm'
      if (that.unicode) result += 'u'
      if (that.sticky) result += 'y'
      return result
    }
  /** */ },
/* 209 */
  /** */ function (module, exports, __webpack_require__) {
    var getKeys = __webpack_require__(38)
    var toIObject = __webpack_require__(16)
    module.exports = function (object, el) {
      var O = toIObject(object)
      var keys = getKeys(O)
      var length = keys.length
      var index = 0
      var key
      while (length > index) if (O[key = keys[index++]] === el) return key
    }
  /** */ },
/* 210 */
  /** */ function (module, exports) {
// 7.2.9 SameValue(x, y)
    module.exports = Object.is || function is (x, y) {
  // eslint-disable-next-line no-self-compare
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y
    }
  /** */ },
/* 211 */
  /** */ function (module, exports, __webpack_require__) {
    var global = __webpack_require__(2)
    var core = __webpack_require__(15)
    var $export = __webpack_require__(0)
    var partial = __webpack_require__(144)
// https://esdiscuss.org/topic/promise-returning-delay-function
    $export($export.G + $export.F, {
      delay: function delay (time) {
        return new (core.Promise || global.Promise)(function (resolve) {
          setTimeout(partial.call(resolve, true), time)
        })
      }
    })
  /** */ },
/* 212 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var ctx = __webpack_require__(20)
    var $export = __webpack_require__(0)
    var createDesc = __webpack_require__(39)
    var assign = __webpack_require__(94)
    var create = __webpack_require__(37)
    var getPrototypeOf = __webpack_require__(18)
    var getKeys = __webpack_require__(38)
    var dP = __webpack_require__(11)
    var keyOf = __webpack_require__(209)
    var aFunction = __webpack_require__(14)
    var forOf = __webpack_require__(35)
    var isIterable = __webpack_require__(152)
    var $iterCreate = __webpack_require__(67)
    var step = __webpack_require__(89)
    var isObject = __webpack_require__(4)
    var toIObject = __webpack_require__(16)
    var DESCRIPTORS = __webpack_require__(12)
    var has = __webpack_require__(21)

// 0 -> Dict.forEach
// 1 -> Dict.map
// 2 -> Dict.filter
// 3 -> Dict.some
// 4 -> Dict.every
// 5 -> Dict.find
// 6 -> Dict.findKey
// 7 -> Dict.mapPairs
    var createDictMethod = function (TYPE) {
      var IS_MAP = TYPE == 1
      var IS_EVERY = TYPE == 4
      return function (object, callbackfn, that /* = undefined */) {
        var f = ctx(callbackfn, that, 3)
        var O = toIObject(object)
        var result = IS_MAP || TYPE == 7 || TYPE == 2
          ? new (typeof this === 'function' ? this : Dict)() : undefined
        var key, val, res
        for (key in O) {
          if (has(O, key)) {
            val = O[key]
            res = f(val, key, object)
            if (TYPE) {
              if (IS_MAP) result[key] = res          // map
              else if (res) {
                switch (TYPE) {
                  case 2: result[key] = val; break     // filter
                  case 3: return true                  // some
                  case 5: return val                   // find
                  case 6: return key                   // findKey
                  case 7: result[res[0]] = res[1]      // mapPairs
                }
              } else if (IS_EVERY) return false      // every
            }
          }
        }
        return TYPE == 3 || IS_EVERY ? IS_EVERY : result
      }
    }
    var findKey = createDictMethod(6)

    var createDictIter = function (kind) {
      return function (it) {
        return new DictIterator(it, kind)
      }
    }
    var DictIterator = function (iterated, kind) {
      this._t = toIObject(iterated) // target
      this._a = getKeys(iterated)   // keys
      this._i = 0                   // next index
      this._k = kind                // kind
    }
    $iterCreate(DictIterator, 'Dict', function () {
      var that = this
      var O = that._t
      var keys = that._a
      var kind = that._k
      var key
      do {
        if (that._i >= keys.length) {
          that._t = undefined
          return step(1)
        }
      } while (!has(O, key = keys[that._i++]))
      if (kind == 'keys') return step(0, key)
      if (kind == 'values') return step(0, O[key])
      return step(0, [key, O[key]])
    })

    function Dict (iterable) {
      var dict = create(null)
      if (iterable != undefined) {
        if (isIterable(iterable)) {
          forOf(iterable, true, function (key, value) {
            dict[key] = value
          })
        } else assign(dict, iterable)
      }
      return dict
    }
    Dict.prototype = null

    function reduce (object, mapfn, init) {
      aFunction(mapfn)
      var O = toIObject(object)
      var keys = getKeys(O)
      var length = keys.length
      var i = 0
      var memo, key
      if (arguments.length < 3) {
        if (!length) throw TypeError('Reduce of empty object with no initial value')
        memo = O[keys[i++]]
      } else memo = Object(init)
      while (length > i) {
        if (has(O, key = keys[i++])) {
          memo = mapfn(memo, O[key], key, object)
        }
      }
      return memo
    }

    function includes (object, el) {
  // eslint-disable-next-line no-self-compare
      return (el == el ? keyOf(object, el) : findKey(object, function (it) {
    // eslint-disable-next-line no-self-compare
        return it != it
      })) !== undefined
    }

    function get (object, key) {
      if (has(object, key)) return object[key]
    }
    function set (object, key, value) {
      if (DESCRIPTORS && key in Object) dP.f(object, key, createDesc(0, value))
      else object[key] = value
      return object
    }

    function isDict (it) {
      return isObject(it) && getPrototypeOf(it) === Dict.prototype
    }

    $export($export.G + $export.F, { Dict: Dict })

    $export($export.S, 'Dict', {
      keys: createDictIter('keys'),
      values: createDictIter('values'),
      entries: createDictIter('entries'),
      forEach: createDictMethod(0),
      map: createDictMethod(1),
      filter: createDictMethod(2),
      some: createDictMethod(3),
      every: createDictMethod(4),
      find: createDictMethod(5),
      findKey: findKey,
      mapPairs: createDictMethod(7),
      reduce: reduce,
      keyOf: keyOf,
      includes: includes,
      has: has,
      get: get,
      set: set,
      isDict: isDict
    })
  /** */ },
/* 213 */
  /** */ function (module, exports, __webpack_require__) {
    var path = __webpack_require__(145)
    var $export = __webpack_require__(0)

// Placeholder
    __webpack_require__(15)._ = path._ = path._ || {}

    $export($export.P + $export.F, 'Function', { part: __webpack_require__(144) })
  /** */ },
/* 214 */
  /** */ function (module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1)
    var get = __webpack_require__(60)
    module.exports = __webpack_require__(15).getIterator = function (it) {
      var iterFn = get(it)
      if (typeof iterFn !== 'function') throw TypeError(it + ' is not iterable!')
      return anObject(iterFn.call(it))
    }
  /** */ },
/* 215 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    __webpack_require__(68)(Number, 'Number', function (iterated) {
      this._l = +iterated
      this._i = 0
    }, function () {
      var i = this._i++
      var done = !(i < this._l)
      return { done: done, value: done ? undefined : i }
    })
  /** */ },
/* 216 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)

    $export($export.S + $export.F, 'Object', { classof: __webpack_require__(44) })
  /** */ },
/* 217 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var define = __webpack_require__(137)

    $export($export.S + $export.F, 'Object', { define: define })
  /** */ },
/* 218 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)

    $export($export.S + $export.F, 'Object', { isObject: __webpack_require__(4) })
  /** */ },
/* 219 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var define = __webpack_require__(137)
    var create = __webpack_require__(37)

    $export($export.S + $export.F, 'Object', {
      make: function (proto, mixin) {
        return define(create(proto), mixin)
      }
    })
  /** */ },
/* 220 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/benjamingr/RexExp.escape
    var $export = __webpack_require__(0)
    var $re = __webpack_require__(97)(/[\\^$*+?.()|[\]{}]/g, '\\$&')

    $export($export.S, 'RegExp', { escape: function escape (it) { return $re(it) } })
  /** */ },
/* 221 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $re = __webpack_require__(97)(/[&<>"']/g, {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&apos;'
    })

    $export($export.P + $export.F, 'String', { escapeHTML: function escapeHTML () { return $re(this) } })
  /** */ },
/* 222 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $re = __webpack_require__(97)(/&(?:amp|lt|gt|quot|apos);/g, {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&apos;': "'"
    })

    $export($export.P + $export.F, 'String', { unescapeHTML: function unescapeHTML () { return $re(this) } })
  /** */ },
/* 223 */
  /** */ function (module, exports, __webpack_require__) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    var $export = __webpack_require__(0)

    $export($export.P, 'Array', { copyWithin: __webpack_require__(121) })

    __webpack_require__(34)('copyWithin')
  /** */ },
/* 224 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $every = __webpack_require__(25)(4)

    $export($export.P + $export.F * !__webpack_require__(26)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
      every: function every (callbackfn /* , thisArg */) {
        return $every(this, callbackfn, arguments[1])
      }
    })
  /** */ },
/* 225 */
  /** */ function (module, exports, __webpack_require__) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    var $export = __webpack_require__(0)

    $export($export.P, 'Array', { fill: __webpack_require__(79) })

    __webpack_require__(34)('fill')
  /** */ },
/* 226 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $filter = __webpack_require__(25)(2)

    $export($export.P + $export.F * !__webpack_require__(26)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
      filter: function filter (callbackfn /* , thisArg */) {
        return $filter(this, callbackfn, arguments[1])
      }
    })
  /** */ },
/* 227 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    var $export = __webpack_require__(0)
    var $find = __webpack_require__(25)(6)
    var KEY = 'findIndex'
    var forced = true
// Shouldn't skip holes
    if (KEY in []) Array(1)[KEY](function () { forced = false })
    $export($export.P + $export.F * forced, 'Array', {
      findIndex: function findIndex (callbackfn /* , that = undefined */) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined)
      }
    })
    __webpack_require__(34)(KEY)
  /** */ },
/* 228 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    var $export = __webpack_require__(0)
    var $find = __webpack_require__(25)(5)
    var KEY = 'find'
    var forced = true
// Shouldn't skip holes
    if (KEY in []) Array(1)[KEY](function () { forced = false })
    $export($export.P + $export.F * forced, 'Array', {
      find: function find (callbackfn /* , that = undefined */) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined)
      }
    })
    __webpack_require__(34)(KEY)
  /** */ },
/* 229 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $forEach = __webpack_require__(25)(0)
    var STRICT = __webpack_require__(26)([].forEach, true)

    $export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
      forEach: function forEach (callbackfn /* , thisArg */) {
        return $forEach(this, callbackfn, arguments[1])
      }
    })
  /** */ },
/* 230 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var ctx = __webpack_require__(20)
    var $export = __webpack_require__(0)
    var toObject = __webpack_require__(13)
    var call = __webpack_require__(133)
    var isArrayIter = __webpack_require__(87)
    var toLength = __webpack_require__(8)
    var createProperty = __webpack_require__(81)
    var getIterFn = __webpack_require__(60)

    $export($export.S + $export.F * !__webpack_require__(88)(function (iter) { Array.from(iter) }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
      from: function from (arrayLike /* , mapfn = undefined, thisArg = undefined */) {
        var O = toObject(arrayLike)
        var C = typeof this === 'function' ? this : Array
        var aLen = arguments.length
        var mapfn = aLen > 1 ? arguments[1] : undefined
        var mapping = mapfn !== undefined
        var index = 0
        var iterFn = getIterFn(O)
        var length, result, step, iterator
        if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2)
    // if object isn't iterable or it's array with default iterator - use simple case
        if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
            createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value)
          }
        } else {
          length = toLength(O.length)
          for (result = new C(length); length > index; index++) {
            createProperty(result, index, mapping ? mapfn(O[index], index) : O[index])
          }
        }
        result.length = index
        return result
      }
    })
  /** */ },
/* 231 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $indexOf = __webpack_require__(64)(false)
    var $native = [].indexOf
    var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0

    $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(26)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
      indexOf: function indexOf (searchElement /* , fromIndex = 0 */) {
        return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1])
      }
    })
  /** */ },
/* 232 */
  /** */ function (module, exports, __webpack_require__) {
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
    var $export = __webpack_require__(0)

    $export($export.S, 'Array', { isArray: __webpack_require__(66) })
  /** */ },
/* 233 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 22.1.3.13 Array.prototype.join(separator)
    var $export = __webpack_require__(0)
    var toIObject = __webpack_require__(16)
    var arrayJoin = [].join

// fallback for not array-like strings
    $export($export.P + $export.F * (__webpack_require__(56) != Object || !__webpack_require__(26)(arrayJoin)), 'Array', {
      join: function join (separator) {
        return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator)
      }
    })
  /** */ },
/* 234 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toIObject = __webpack_require__(16)
    var toInteger = __webpack_require__(29)
    var toLength = __webpack_require__(8)
    var $native = [].lastIndexOf
    var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0

    $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(26)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
      lastIndexOf: function lastIndexOf (searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
        if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0
        var O = toIObject(this)
        var length = toLength(O.length)
        var index = length - 1
        if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]))
        if (index < 0) index = length + index
        for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0
        return -1
      }
    })
  /** */ },
/* 235 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $map = __webpack_require__(25)(1)

    $export($export.P + $export.F * !__webpack_require__(26)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
      map: function map (callbackfn /* , thisArg */) {
        return $map(this, callbackfn, arguments[1])
      }
    })
  /** */ },
/* 236 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var createProperty = __webpack_require__(81)

// WebKit Array.of isn't generic
    $export($export.S + $export.F * __webpack_require__(5)(function () {
      function F () { /* empty */ }
      return !(Array.of.call(F) instanceof F)
    }), 'Array', {
  // 22.1.2.3 Array.of( ...items)
      of: function of (/* ...args */) {
        var index = 0
        var aLen = arguments.length
        var result = new (typeof this === 'function' ? this : Array)(aLen)
        while (aLen > index) createProperty(result, index, arguments[index++])
        result.length = aLen
        return result
      }
    })
  /** */ },
/* 237 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $reduce = __webpack_require__(123)

    $export($export.P + $export.F * !__webpack_require__(26)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
      reduceRight: function reduceRight (callbackfn /* , initialValue */) {
        return $reduce(this, callbackfn, arguments.length, arguments[1], true)
      }
    })
  /** */ },
/* 238 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $reduce = __webpack_require__(123)

    $export($export.P + $export.F * !__webpack_require__(26)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
      reduce: function reduce (callbackfn /* , initialValue */) {
        return $reduce(this, callbackfn, arguments.length, arguments[1], false)
      }
    })
  /** */ },
/* 239 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var html = __webpack_require__(85)
    var cof = __webpack_require__(27)
    var toAbsoluteIndex = __webpack_require__(49)
    var toLength = __webpack_require__(8)
    var arraySlice = [].slice

// fallback for not array-like ES3 strings and DOM objects
    $export($export.P + $export.F * __webpack_require__(5)(function () {
      if (html) arraySlice.call(html)
    }), 'Array', {
      slice: function slice (begin, end) {
        var len = toLength(this.length)
        var klass = cof(this)
        end = end === undefined ? len : end
        if (klass == 'Array') return arraySlice.call(this, begin, end)
        var start = toAbsoluteIndex(begin, len)
        var upTo = toAbsoluteIndex(end, len)
        var size = toLength(upTo - start)
        var cloned = Array(size)
        var i = 0
        for (; i < size; i++) {
          cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i]
        }
        return cloned
      }
    })
  /** */ },
/* 240 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $some = __webpack_require__(25)(3)

    $export($export.P + $export.F * !__webpack_require__(26)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
      some: function some (callbackfn /* , thisArg */) {
        return $some(this, callbackfn, arguments[1])
      }
    })
  /** */ },
/* 241 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var aFunction = __webpack_require__(14)
    var toObject = __webpack_require__(13)
    var fails = __webpack_require__(5)
    var $sort = [].sort
    var test = [1, 2, 3]

    $export($export.P + $export.F * (fails(function () {
  // IE8-
      test.sort(undefined)
    }) || !fails(function () {
  // V8 bug
      test.sort(null)
  // Old WebKit
    }) || !__webpack_require__(26)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
      sort: function sort (comparefn) {
        return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn))
      }
    })
  /** */ },
/* 242 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(48)('Array')
  /** */ },
/* 243 */
  /** */ function (module, exports, __webpack_require__) {
// 20.3.3.1 / 15.9.4.4 Date.now()
    var $export = __webpack_require__(0)

    $export($export.S, 'Date', { now: function () { return new Date().getTime() } })
  /** */ },
/* 244 */
  /** */ function (module, exports, __webpack_require__) {
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
    var $export = __webpack_require__(0)
    var toISOString = __webpack_require__(128)

// PhantomJS / old WebKit has a broken implementations
    $export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
      toISOString: toISOString
    })
  /** */ },
/* 245 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toObject = __webpack_require__(13)
    var toPrimitive = __webpack_require__(40)
    var toISOString = __webpack_require__(128)
    var classof = __webpack_require__(44)

    $export($export.P + $export.F * __webpack_require__(5)(function () {
      return new Date(NaN).toJSON() !== null ||
    Date.prototype.toJSON.call({ toISOString: function () { return 1 } }) !== 1
    }), 'Date', {
  // eslint-disable-next-line no-unused-vars
      toJSON: function toJSON (key) {
        var O = toObject(this)
        var pv = toPrimitive(O)
        return typeof pv === 'number' && !isFinite(pv) ? null
      : (!('toISOString' in O) && classof(O) == 'Date') ? toISOString.call(O) : O.toISOString()
      }
    })
  /** */ },
/* 246 */
  /** */ function (module, exports) {

  /** */ },
/* 247 */
  /** */ function (module, exports) {

  /** */ },
/* 248 */
  /** */ function (module, exports, __webpack_require__) {
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
    var $export = __webpack_require__(0)

    $export($export.P, 'Function', { bind: __webpack_require__(124) })
  /** */ },
/* 249 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var isObject = __webpack_require__(4)
    var getPrototypeOf = __webpack_require__(18)
    var HAS_INSTANCE = __webpack_require__(9)('hasInstance')
    var FunctionProto = Function.prototype
// 19.2.3.6 Function.prototype[@@hasInstance](V)
    if (!(HAS_INSTANCE in FunctionProto)) {
      __webpack_require__(11).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
        if (typeof this !== 'function' || !isObject(O)) return false
        if (!isObject(this.prototype)) return O instanceof this
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
        while (O = getPrototypeOf(O)) if (this.prototype === O) return true
        return false
      } })
    }
  /** */ },
/* 250 */
  /** */ function (module, exports) {

  /** */ },
/* 251 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.3 Math.acosh(x)
    var $export = __webpack_require__(0)
    var log1p = __webpack_require__(135)
    var sqrt = Math.sqrt
    var $acosh = Math.acosh

    $export($export.S + $export.F * !($acosh &&
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  Math.floor($acosh(Number.MAX_VALUE)) == 710 &&
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh (x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1))
  }
})
  /** */ },
/* 252 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.5 Math.asinh(x)
    var $export = __webpack_require__(0)
    var $asinh = Math.asinh

    function asinh (x) {
      return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1))
    }

// Tor Browser bug: Math.asinh(0) -> -0
    $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh })
  /** */ },
/* 253 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.7 Math.atanh(x)
    var $export = __webpack_require__(0)
    var $atanh = Math.atanh

// Tor Browser bug: Math.atanh(-0) -> 0
    $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
      atanh: function atanh (x) {
        return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2
      }
    })
  /** */ },
/* 254 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.9 Math.cbrt(x)
    var $export = __webpack_require__(0)
    var sign = __webpack_require__(91)

    $export($export.S, 'Math', {
      cbrt: function cbrt (x) {
        return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3)
      }
    })
  /** */ },
/* 255 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.11 Math.clz32(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      clz32: function clz32 (x) {
        return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32
      }
    })
  /** */ },
/* 256 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.12 Math.cosh(x)
    var $export = __webpack_require__(0)
    var exp = Math.exp

    $export($export.S, 'Math', {
      cosh: function cosh (x) {
        return (exp(x = +x) + exp(-x)) / 2
      }
    })
  /** */ },
/* 257 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.14 Math.expm1(x)
    var $export = __webpack_require__(0)
    var $expm1 = __webpack_require__(90)

    $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 })
  /** */ },
/* 258 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.16 Math.fround(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { fround: __webpack_require__(134) })
  /** */ },
/* 259 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
    var $export = __webpack_require__(0)
    var abs = Math.abs

    $export($export.S, 'Math', {
      hypot: function hypot (value1, value2) { // eslint-disable-line no-unused-vars
        var sum = 0
        var i = 0
        var aLen = arguments.length
        var larg = 0
        var arg, div
        while (i < aLen) {
          arg = abs(arguments[i++])
          if (larg < arg) {
            div = larg / arg
            sum = sum * div * div + 1
            larg = arg
          } else if (arg > 0) {
            div = arg / larg
            sum += div * div
          } else sum += arg
        }
        return larg === Infinity ? Infinity : larg * Math.sqrt(sum)
      }
    })
  /** */ },
/* 260 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.18 Math.imul(x, y)
    var $export = __webpack_require__(0)
    var $imul = Math.imul

// some WebKit versions fails with big numbers, some has wrong arity
    $export($export.S + $export.F * __webpack_require__(5)(function () {
      return $imul(0xffffffff, 5) != -5 || $imul.length != 2
    }), 'Math', {
      imul: function imul (x, y) {
        var UINT16 = 0xffff
        var xn = +x
        var yn = +y
        var xl = UINT16 & xn
        var yl = UINT16 & yn
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0)
      }
    })
  /** */ },
/* 261 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.21 Math.log10(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      log10: function log10 (x) {
        return Math.log(x) * Math.LOG10E
      }
    })
  /** */ },
/* 262 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.20 Math.log1p(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { log1p: __webpack_require__(135) })
  /** */ },
/* 263 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.22 Math.log2(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      log2: function log2 (x) {
        return Math.log(x) / Math.LN2
      }
    })
  /** */ },
/* 264 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.28 Math.sign(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { sign: __webpack_require__(91) })
  /** */ },
/* 265 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.30 Math.sinh(x)
    var $export = __webpack_require__(0)
    var expm1 = __webpack_require__(90)
    var exp = Math.exp

// V8 near Chromium 38 has a problem with very small numbers
    $export($export.S + $export.F * __webpack_require__(5)(function () {
      return !Math.sinh(-2e-17) != -2e-17
    }), 'Math', {
      sinh: function sinh (x) {
        return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2)
      }
    })
  /** */ },
/* 266 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.33 Math.tanh(x)
    var $export = __webpack_require__(0)
    var expm1 = __webpack_require__(90)
    var exp = Math.exp

    $export($export.S, 'Math', {
      tanh: function tanh (x) {
        var a = expm1(x = +x)
        var b = expm1(-x)
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x))
      }
    })
  /** */ },
/* 267 */
  /** */ function (module, exports, __webpack_require__) {
// 20.2.2.34 Math.trunc(x)
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      trunc: function trunc (it) {
        return (it > 0 ? Math.floor : Math.ceil)(it)
      }
    })
  /** */ },
/* 268 */
  /** */ function (module, exports) {

  /** */ },
/* 269 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.1 Number.EPSILON
    var $export = __webpack_require__(0)

    $export($export.S, 'Number', { EPSILON: Math.pow(2, -52) })
  /** */ },
/* 270 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.2 Number.isFinite(number)
    var $export = __webpack_require__(0)
    var _isFinite = __webpack_require__(2).isFinite

    $export($export.S, 'Number', {
      isFinite: function isFinite (it) {
        return typeof it === 'number' && _isFinite(it)
      }
    })
  /** */ },
/* 271 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.3 Number.isInteger(number)
    var $export = __webpack_require__(0)

    $export($export.S, 'Number', { isInteger: __webpack_require__(131) })
  /** */ },
/* 272 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.4 Number.isNaN(number)
    var $export = __webpack_require__(0)

    $export($export.S, 'Number', {
      isNaN: function isNaN (number) {
    // eslint-disable-next-line no-self-compare
        return number != number
      }
    })
  /** */ },
/* 273 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.5 Number.isSafeInteger(number)
    var $export = __webpack_require__(0)
    var isInteger = __webpack_require__(131)
    var abs = Math.abs

    $export($export.S, 'Number', {
      isSafeInteger: function isSafeInteger (number) {
        return isInteger(number) && abs(number) <= 0x1fffffffffffff
      }
    })
  /** */ },
/* 274 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
    var $export = __webpack_require__(0)

    $export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff })
  /** */ },
/* 275 */
  /** */ function (module, exports, __webpack_require__) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
    var $export = __webpack_require__(0)

    $export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff })
  /** */ },
/* 276 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var $parseFloat = __webpack_require__(142)
// 20.1.2.12 Number.parseFloat(string)
    $export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat })
  /** */ },
/* 277 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var $parseInt = __webpack_require__(143)
// 20.1.2.13 Number.parseInt(string, radix)
    $export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt })
  /** */ },
/* 278 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toInteger = __webpack_require__(29)
    var aNumberValue = __webpack_require__(120)
    var repeat = __webpack_require__(101)
    var $toFixed = 1.0.toFixed
    var floor = Math.floor
    var data = [0, 0, 0, 0, 0, 0]
    var ERROR = 'Number.toFixed: incorrect invocation!'
    var ZERO = '0'

    var multiply = function (n, c) {
      var i = -1
      var c2 = c
      while (++i < 6) {
        c2 += n * data[i]
        data[i] = c2 % 1e7
        c2 = floor(c2 / 1e7)
      }
    }
    var divide = function (n) {
      var i = 6
      var c = 0
      while (--i >= 0) {
        c += data[i]
        data[i] = floor(c / n)
        c = (c % n) * 1e7
      }
    }
    var numToString = function () {
      var i = 6
      var s = ''
      while (--i >= 0) {
        if (s !== '' || i === 0 || data[i] !== 0) {
          var t = String(data[i])
          s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t
        }
      } return s
    }
    var pow = function (x, n, acc) {
      return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)
    }
    var log = function (x) {
      var n = 0
      var x2 = x
      while (x2 >= 4096) {
        n += 12
        x2 /= 4096
      }
      while (x2 >= 2) {
        n += 1
        x2 /= 2
      } return n
    }

    $export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(5)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({})
})), 'Number', {
  toFixed: function toFixed (fractionDigits) {
    var x = aNumberValue(this, ERROR)
    var f = toInteger(fractionDigits)
    var s = ''
    var m = ZERO
    var e, z, j, k
    if (f < 0 || f > 20) throw RangeError(ERROR)
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN'
    if (x <= -1e21 || x >= 1e21) return String(x)
    if (x < 0) {
      s = '-'
      x = -x
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1)
      z *= 0x10000000000000
      e = 52 - e
      if (e > 0) {
        multiply(0, z)
        j = f
        while (j >= 7) {
          multiply(1e7, 0)
          j -= 7
        }
        multiply(pow(10, j, 1), 0)
        j = e - 1
        while (j >= 23) {
          divide(1 << 23)
          j -= 23
        }
        divide(1 << j)
        multiply(1, 1)
        divide(2)
        m = numToString()
      } else {
        multiply(0, z)
        multiply(1 << -e, 0)
        m = numToString() + repeat.call(ZERO, f)
      }
    }
    if (f > 0) {
      k = m.length
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f))
    } else {
      m = s + m
    } return m
  }
})
  /** */ },
/* 279 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $fails = __webpack_require__(5)
    var aNumberValue = __webpack_require__(120)
    var $toPrecision = 1.0.toPrecision

    $export($export.P + $export.F * ($fails(function () {
  // IE7-
      return $toPrecision.call(1, undefined) !== '1'
    }) || !$fails(function () {
  // V8 ~ Android 4.3-
      $toPrecision.call({})
    })), 'Number', {
      toPrecision: function toPrecision (precision) {
        var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!')
        return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision)
      }
    })
  /** */ },
/* 280 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.3.1 Object.assign(target, source)
    var $export = __webpack_require__(0)

    $export($export.S + $export.F, 'Object', { assign: __webpack_require__(94) })
  /** */ },
/* 281 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
    $export($export.S, 'Object', { create: __webpack_require__(37) })
  /** */ },
/* 282 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
    $export($export.S + $export.F * !__webpack_require__(12), 'Object', { defineProperties: __webpack_require__(138) })
  /** */ },
/* 283 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
    $export($export.S + $export.F * !__webpack_require__(12), 'Object', { defineProperty: __webpack_require__(11).f })
  /** */ },
/* 284 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.5 Object.freeze(O)
    var isObject = __webpack_require__(4)
    var meta = __webpack_require__(36).onFreeze

    __webpack_require__(28)('freeze', function ($freeze) {
      return function freeze (it) {
        return $freeze && isObject(it) ? $freeze(meta(it)) : it
      }
    })
  /** */ },
/* 285 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    var toIObject = __webpack_require__(16)
    var $getOwnPropertyDescriptor = __webpack_require__(23).f

    __webpack_require__(28)('getOwnPropertyDescriptor', function () {
      return function getOwnPropertyDescriptor (it, key) {
        return $getOwnPropertyDescriptor(toIObject(it), key)
      }
    })
  /** */ },
/* 286 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
    __webpack_require__(28)('getOwnPropertyNames', function () {
      return __webpack_require__(139).f
    })
  /** */ },
/* 287 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.9 Object.getPrototypeOf(O)
    var toObject = __webpack_require__(13)
    var $getPrototypeOf = __webpack_require__(18)

    __webpack_require__(28)('getPrototypeOf', function () {
      return function getPrototypeOf (it) {
        return $getPrototypeOf(toObject(it))
      }
    })
  /** */ },
/* 288 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.11 Object.isExtensible(O)
    var isObject = __webpack_require__(4)

    __webpack_require__(28)('isExtensible', function ($isExtensible) {
      return function isExtensible (it) {
        return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false
      }
    })
  /** */ },
/* 289 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.12 Object.isFrozen(O)
    var isObject = __webpack_require__(4)

    __webpack_require__(28)('isFrozen', function ($isFrozen) {
      return function isFrozen (it) {
        return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true
      }
    })
  /** */ },
/* 290 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.13 Object.isSealed(O)
    var isObject = __webpack_require__(4)

    __webpack_require__(28)('isSealed', function ($isSealed) {
      return function isSealed (it) {
        return isObject(it) ? $isSealed ? $isSealed(it) : false : true
      }
    })
  /** */ },
/* 291 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.3.10 Object.is(value1, value2)
    var $export = __webpack_require__(0)
    $export($export.S, 'Object', { is: __webpack_require__(210) })
  /** */ },
/* 292 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.14 Object.keys(O)
    var toObject = __webpack_require__(13)
    var $keys = __webpack_require__(38)

    __webpack_require__(28)('keys', function () {
      return function keys (it) {
        return $keys(toObject(it))
      }
    })
  /** */ },
/* 293 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.15 Object.preventExtensions(O)
    var isObject = __webpack_require__(4)
    var meta = __webpack_require__(36).onFreeze

    __webpack_require__(28)('preventExtensions', function ($preventExtensions) {
      return function preventExtensions (it) {
        return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it
      }
    })
  /** */ },
/* 294 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.2.17 Object.seal(O)
    var isObject = __webpack_require__(4)
    var meta = __webpack_require__(36).onFreeze

    __webpack_require__(28)('seal', function ($seal) {
      return function seal (it) {
        return $seal && isObject(it) ? $seal(meta(it)) : it
      }
    })
  /** */ },
/* 295 */
  /** */ function (module, exports, __webpack_require__) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
    var $export = __webpack_require__(0)
    $export($export.S, 'Object', { setPrototypeOf: __webpack_require__(148).set })
  /** */ },
/* 296 */
  /** */ function (module, exports) {

  /** */ },
/* 297 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var $parseFloat = __webpack_require__(142)
// 18.2.4 parseFloat(string)
    $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat })
  /** */ },
/* 298 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var $parseInt = __webpack_require__(143)
// 18.2.5 parseInt(string, radix)
    $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt })
  /** */ },
/* 299 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var LIBRARY = __webpack_require__(46)
    var global = __webpack_require__(2)
    var ctx = __webpack_require__(20)
    var classof = __webpack_require__(44)
    var $export = __webpack_require__(0)
    var isObject = __webpack_require__(4)
    var aFunction = __webpack_require__(14)
    var anInstance = __webpack_require__(43)
    var forOf = __webpack_require__(35)
    var speciesConstructor = __webpack_require__(74)
    var task = __webpack_require__(103).set
    var microtask = __webpack_require__(92)()
    var newPromiseCapabilityModule = __webpack_require__(93)
    var perform = __webpack_require__(146)
    var promiseResolve = __webpack_require__(147)
    var PROMISE = 'Promise'
    var TypeError = global.TypeError
    var process = global.process
    var $Promise = global[PROMISE]
    var isNode = classof(process) == 'process'
    var empty = function () { /* empty */ }
    var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper
    var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f

    var USE_NATIVE = !!(function () {
      try {
    // correct subclassing with @@species support
        var promise = $Promise.resolve(1)
        var FakePromise = (promise.constructor = {})[__webpack_require__(9)('species')] = function (exec) {
          exec(empty, empty)
        }
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
        return (isNode || typeof PromiseRejectionEvent === 'function') && promise.then(empty) instanceof FakePromise
      } catch (e) { /* empty */ }
    }())

// helpers
    var isThenable = function (it) {
      var then
      return isObject(it) && typeof (then = it.then) === 'function' ? then : false
    }
    var notify = function (promise, isReject) {
      if (promise._n) return
      promise._n = true
      var chain = promise._c
      microtask(function () {
        var value = promise._v
        var ok = promise._s == 1
        var i = 0
        var run = function (reaction) {
          var handler = ok ? reaction.ok : reaction.fail
          var resolve = reaction.resolve
          var reject = reaction.reject
          var domain = reaction.domain
          var result, then
          try {
            if (handler) {
              if (!ok) {
                if (promise._h == 2) onHandleUnhandled(promise)
                promise._h = 1
              }
              if (handler === true) result = value
              else {
                if (domain) domain.enter()
                result = handler(value)
                if (domain) domain.exit()
              }
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'))
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject)
              } else resolve(result)
            } else reject(value)
          } catch (e) {
            reject(e)
          }
        }
        while (chain.length > i) run(chain[i++]) // variable length - can't use forEach
        promise._c = []
        promise._n = false
        if (isReject && !promise._h) onUnhandled(promise)
      })
    }
    var onUnhandled = function (promise) {
      task.call(global, function () {
        var value = promise._v
        var unhandled = isUnhandled(promise)
        var result, handler, console
        if (unhandled) {
          result = perform(function () {
            if (isNode) {
              process.emit('unhandledRejection', value, promise)
            } else if (handler = global.onunhandledrejection) {
              handler({ promise: promise, reason: value })
            } else if ((console = global.console) && console.error) {
              console.error('Unhandled promise rejection', value)
            }
          })
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
          promise._h = isNode || isUnhandled(promise) ? 2 : 1
        } promise._a = undefined
        if (unhandled && result.e) throw result.v
      })
    }
    var isUnhandled = function (promise) {
      if (promise._h == 1) return false
      var chain = promise._a || promise._c
      var i = 0
      var reaction
      while (chain.length > i) {
        reaction = chain[i++]
        if (reaction.fail || !isUnhandled(reaction.promise)) return false
      } return true
    }
    var onHandleUnhandled = function (promise) {
      task.call(global, function () {
        var handler
        if (isNode) {
          process.emit('rejectionHandled', promise)
        } else if (handler = global.onrejectionhandled) {
          handler({ promise: promise, reason: promise._v })
        }
      })
    }
    var $reject = function (value) {
      var promise = this
      if (promise._d) return
      promise._d = true
      promise = promise._w || promise // unwrap
      promise._v = value
      promise._s = 2
      if (!promise._a) promise._a = promise._c.slice()
      notify(promise, true)
    }
    var $resolve = function (value) {
      var promise = this
      var then
      if (promise._d) return
      promise._d = true
      promise = promise._w || promise // unwrap
      try {
        if (promise === value) throw TypeError("Promise can't be resolved itself")
        if (then = isThenable(value)) {
          microtask(function () {
            var wrapper = { _w: promise, _d: false } // wrap
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1))
            } catch (e) {
              $reject.call(wrapper, e)
            }
          })
        } else {
          promise._v = value
          promise._s = 1
          notify(promise, false)
        }
      } catch (e) {
        $reject.call({ _w: promise, _d: false }, e) // wrap
      }
    }

// constructor polyfill
    if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
      $Promise = function Promise (executor) {
        anInstance(this, $Promise, PROMISE, '_h')
        aFunction(executor)
        Internal.call(this)
        try {
          executor(ctx($resolve, this, 1), ctx($reject, this, 1))
        } catch (err) {
          $reject.call(this, err)
        }
      }
  // eslint-disable-next-line no-unused-vars
      Internal = function Promise (executor) {
        this._c = []             // <- awaiting reactions
        this._a = undefined      // <- checked in isUnhandled reactions
        this._s = 0              // <- state
        this._d = false          // <- done
        this._v = undefined      // <- value
        this._h = 0              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
        this._n = false          // <- notify
      }
      Internal.prototype = __webpack_require__(47)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function then (onFulfilled, onRejected) {
          var reaction = newPromiseCapability(speciesConstructor(this, $Promise))
          reaction.ok = typeof onFulfilled === 'function' ? onFulfilled : true
          reaction.fail = typeof onRejected === 'function' && onRejected
          reaction.domain = isNode ? process.domain : undefined
          this._c.push(reaction)
          if (this._a) this._a.push(reaction)
          if (this._s) notify(this, false)
          return reaction.promise
        },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
        'catch': function (onRejected) {
          return this.then(undefined, onRejected)
        }
      })
      OwnPromiseCapability = function () {
        var promise = new Internal()
        this.promise = promise
        this.resolve = ctx($resolve, promise, 1)
        this.reject = ctx($reject, promise, 1)
      }
      newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
        return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C)
      }
    }

    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise })
    __webpack_require__(51)($Promise, PROMISE)
    __webpack_require__(48)(PROMISE)
    Wrapper = __webpack_require__(15)[PROMISE]

// statics
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
      reject: function reject (r) {
        var capability = newPromiseCapability(this)
        var $$reject = capability.reject
        $$reject(r)
        return capability.promise
      }
    })
    $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
      resolve: function resolve (x) {
        return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x)
      }
    })
    $export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(88)(function (iter) {
      $Promise.all(iter)['catch'](empty)
    })), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
      all: function all (iterable) {
        var C = this
        var capability = newPromiseCapability(C)
        var resolve = capability.resolve
        var reject = capability.reject
        var result = perform(function () {
          var values = []
          var index = 0
          var remaining = 1
          forOf(iterable, false, function (promise) {
            var $index = index++
            var alreadyCalled = false
            values.push(undefined)
            remaining++
            C.resolve(promise).then(function (value) {
              if (alreadyCalled) return
              alreadyCalled = true
              values[$index] = value
              --remaining || resolve(values)
            }, reject)
          })
          --remaining || resolve(values)
        })
        if (result.e) reject(result.v)
        return capability.promise
      },
  // 25.4.4.4 Promise.race(iterable)
      race: function race (iterable) {
        var C = this
        var capability = newPromiseCapability(C)
        var reject = capability.reject
        var result = perform(function () {
          forOf(iterable, false, function (promise) {
            C.resolve(promise).then(capability.resolve, reject)
          })
        })
        if (result.e) reject(result.v)
        return capability.promise
      }
    })
  /** */ },
/* 300 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    var $export = __webpack_require__(0)
    var aFunction = __webpack_require__(14)
    var anObject = __webpack_require__(1)
    var rApply = (__webpack_require__(2).Reflect || {}).apply
    var fApply = Function.apply
// MS Edge argumentsList argument is optional
    $export($export.S + $export.F * !__webpack_require__(5)(function () {
      rApply(function () { /* empty */ })
    }), 'Reflect', {
      apply: function apply (target, thisArgument, argumentsList) {
        var T = aFunction(target)
        var L = anObject(argumentsList)
        return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L)
      }
    })
  /** */ },
/* 301 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    var $export = __webpack_require__(0)
    var create = __webpack_require__(37)
    var aFunction = __webpack_require__(14)
    var anObject = __webpack_require__(1)
    var isObject = __webpack_require__(4)
    var fails = __webpack_require__(5)
    var bind = __webpack_require__(124)
    var rConstruct = (__webpack_require__(2).Reflect || {}).construct

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
    var NEW_TARGET_BUG = fails(function () {
      function F () { /* empty */ }
      return !(rConstruct(function () { /* empty */ }, [], F) instanceof F)
    })
    var ARGS_BUG = !fails(function () {
      rConstruct(function () { /* empty */ })
    })

    $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
      construct: function construct (Target, args /* , newTarget */) {
        aFunction(Target)
        anObject(args)
        var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2])
        if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget)
        if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
          switch (args.length) {
            case 0: return new Target()
            case 1: return new Target(args[0])
            case 2: return new Target(args[0], args[1])
            case 3: return new Target(args[0], args[1], args[2])
            case 4: return new Target(args[0], args[1], args[2], args[3])
          }
      // w/o altered newTarget, lot of arguments case
          var $args = [null]
          $args.push.apply($args, args)
          return new (bind.apply(Target, $args))()
        }
    // with altered newTarget, not support built-in constructors
        var proto = newTarget.prototype
        var instance = create(isObject(proto) ? proto : Object.prototype)
        var result = Function.apply.call(Target, instance, args)
        return isObject(result) ? result : instance
      }
    })
  /** */ },
/* 302 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    var dP = __webpack_require__(11)
    var $export = __webpack_require__(0)
    var anObject = __webpack_require__(1)
    var toPrimitive = __webpack_require__(40)

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
    $export($export.S + $export.F * __webpack_require__(5)(function () {
  // eslint-disable-next-line no-undef
      Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 })
    }), 'Reflect', {
      defineProperty: function defineProperty (target, propertyKey, attributes) {
        anObject(target)
        propertyKey = toPrimitive(propertyKey, true)
        anObject(attributes)
        try {
          dP.f(target, propertyKey, attributes)
          return true
        } catch (e) {
          return false
        }
      }
    })
  /** */ },
/* 303 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
    var $export = __webpack_require__(0)
    var gOPD = __webpack_require__(23).f
    var anObject = __webpack_require__(1)

    $export($export.S, 'Reflect', {
      deleteProperty: function deleteProperty (target, propertyKey) {
        var desc = gOPD(anObject(target), propertyKey)
        return desc && !desc.configurable ? false : delete target[propertyKey]
      }
    })
  /** */ },
/* 304 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 26.1.5 Reflect.enumerate(target)
    var $export = __webpack_require__(0)
    var anObject = __webpack_require__(1)
    var Enumerate = function (iterated) {
      this._t = anObject(iterated) // target
      this._i = 0                  // next index
      var keys = this._k = []      // keys
      var key
      for (key in iterated) keys.push(key)
    }
    __webpack_require__(67)(Enumerate, 'Object', function () {
      var that = this
      var keys = that._k
      var key
      do {
        if (that._i >= keys.length) return { value: undefined, done: true }
      } while (!((key = keys[that._i++]) in that._t))
      return { value: key, done: false }
    })

    $export($export.S, 'Reflect', {
      enumerate: function enumerate (target) {
        return new Enumerate(target)
      }
    })
  /** */ },
/* 305 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    var gOPD = __webpack_require__(23)
    var $export = __webpack_require__(0)
    var anObject = __webpack_require__(1)

    $export($export.S, 'Reflect', {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor (target, propertyKey) {
        return gOPD.f(anObject(target), propertyKey)
      }
    })
  /** */ },
/* 306 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.8 Reflect.getPrototypeOf(target)
    var $export = __webpack_require__(0)
    var getProto = __webpack_require__(18)
    var anObject = __webpack_require__(1)

    $export($export.S, 'Reflect', {
      getPrototypeOf: function getPrototypeOf (target) {
        return getProto(anObject(target))
      }
    })
  /** */ },
/* 307 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
    var gOPD = __webpack_require__(23)
    var getPrototypeOf = __webpack_require__(18)
    var has = __webpack_require__(21)
    var $export = __webpack_require__(0)
    var isObject = __webpack_require__(4)
    var anObject = __webpack_require__(1)

    function get (target, propertyKey /* , receiver */) {
      var receiver = arguments.length < 3 ? target : arguments[2]
      var desc, proto
      if (anObject(target) === receiver) return target[propertyKey]
      if (desc = gOPD.f(target, propertyKey)) {
        return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined
      }
      if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver)
    }

    $export($export.S, 'Reflect', { get: get })
  /** */ },
/* 308 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.9 Reflect.has(target, propertyKey)
    var $export = __webpack_require__(0)

    $export($export.S, 'Reflect', {
      has: function has (target, propertyKey) {
        return propertyKey in target
      }
    })
  /** */ },
/* 309 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.10 Reflect.isExtensible(target)
    var $export = __webpack_require__(0)
    var anObject = __webpack_require__(1)
    var $isExtensible = Object.isExtensible

    $export($export.S, 'Reflect', {
      isExtensible: function isExtensible (target) {
        anObject(target)
        return $isExtensible ? $isExtensible(target) : true
      }
    })
  /** */ },
/* 310 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.11 Reflect.ownKeys(target)
    var $export = __webpack_require__(0)

    $export($export.S, 'Reflect', { ownKeys: __webpack_require__(95) })
  /** */ },
/* 311 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.12 Reflect.preventExtensions(target)
    var $export = __webpack_require__(0)
    var anObject = __webpack_require__(1)
    var $preventExtensions = Object.preventExtensions

    $export($export.S, 'Reflect', {
      preventExtensions: function preventExtensions (target) {
        anObject(target)
        try {
          if ($preventExtensions) $preventExtensions(target)
          return true
        } catch (e) {
          return false
        }
      }
    })
  /** */ },
/* 312 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
    var $export = __webpack_require__(0)
    var setProto = __webpack_require__(148)

    if (setProto) {
      $export($export.S, 'Reflect', {
        setPrototypeOf: function setPrototypeOf (target, proto) {
          setProto.check(target, proto)
          try {
            setProto.set(target, proto)
            return true
          } catch (e) {
            return false
          }
        }
      })
    }
  /** */ },
/* 313 */
  /** */ function (module, exports, __webpack_require__) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    var dP = __webpack_require__(11)
    var gOPD = __webpack_require__(23)
    var getPrototypeOf = __webpack_require__(18)
    var has = __webpack_require__(21)
    var $export = __webpack_require__(0)
    var createDesc = __webpack_require__(39)
    var anObject = __webpack_require__(1)
    var isObject = __webpack_require__(4)

    function set (target, propertyKey, V /* , receiver */) {
      var receiver = arguments.length < 4 ? target : arguments[3]
      var ownDesc = gOPD.f(anObject(target), propertyKey)
      var existingDescriptor, proto
      if (!ownDesc) {
        if (isObject(proto = getPrototypeOf(target))) {
          return set(proto, propertyKey, V, receiver)
        }
        ownDesc = createDesc(0)
      }
      if (has(ownDesc, 'value')) {
        if (ownDesc.writable === false || !isObject(receiver)) return false
        existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0)
        existingDescriptor.value = V
        dP.f(receiver, propertyKey, existingDescriptor)
        return true
      }
      return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true)
    }

    $export($export.S, 'Reflect', { set: set })
  /** */ },
/* 314 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(48)('RegExp')
  /** */ },
/* 315 */
  /** */ function (module, exports) {

  /** */ },
/* 316 */
  /** */ function (module, exports) {

  /** */ },
/* 317 */
  /** */ function (module, exports) {

  /** */ },
/* 318 */
  /** */ function (module, exports) {

  /** */ },
/* 319 */
  /** */ function (module, exports) {

  /** */ },
/* 320 */
  /** */ function (module, exports) {

  /** */ },
/* 321 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.2 String.prototype.anchor(name)
    __webpack_require__(19)('anchor', function (createHTML) {
      return function anchor (name) {
        return createHTML(this, 'a', 'name', name)
      }
    })
  /** */ },
/* 322 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.3 String.prototype.big()
    __webpack_require__(19)('big', function (createHTML) {
      return function big () {
        return createHTML(this, 'big', '', '')
      }
    })
  /** */ },
/* 323 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.4 String.prototype.blink()
    __webpack_require__(19)('blink', function (createHTML) {
      return function blink () {
        return createHTML(this, 'blink', '', '')
      }
    })
  /** */ },
/* 324 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.5 String.prototype.bold()
    __webpack_require__(19)('bold', function (createHTML) {
      return function bold () {
        return createHTML(this, 'b', '', '')
      }
    })
  /** */ },
/* 325 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $at = __webpack_require__(99)(false)
    $export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
      codePointAt: function codePointAt (pos) {
        return $at(this, pos)
      }
    })
  /** */ },
/* 326 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

    var $export = __webpack_require__(0)
    var toLength = __webpack_require__(8)
    var context = __webpack_require__(100)
    var ENDS_WITH = 'endsWith'
    var $endsWith = ''[ENDS_WITH]

    $export($export.P + $export.F * __webpack_require__(84)(ENDS_WITH), 'String', {
      endsWith: function endsWith (searchString /* , endPosition = @length */) {
        var that = context(this, searchString, ENDS_WITH)
        var endPosition = arguments.length > 1 ? arguments[1] : undefined
        var len = toLength(that.length)
        var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
        var search = String(searchString)
        return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search
      }
    })
  /** */ },
/* 327 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.6 String.prototype.fixed()
    __webpack_require__(19)('fixed', function (createHTML) {
      return function fixed () {
        return createHTML(this, 'tt', '', '')
      }
    })
  /** */ },
/* 328 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.7 String.prototype.fontcolor(color)
    __webpack_require__(19)('fontcolor', function (createHTML) {
      return function fontcolor (color) {
        return createHTML(this, 'font', 'color', color)
      }
    })
  /** */ },
/* 329 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.8 String.prototype.fontsize(size)
    __webpack_require__(19)('fontsize', function (createHTML) {
      return function fontsize (size) {
        return createHTML(this, 'font', 'size', size)
      }
    })
  /** */ },
/* 330 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var toAbsoluteIndex = __webpack_require__(49)
    var fromCharCode = String.fromCharCode
    var $fromCodePoint = String.fromCodePoint

// length should be 1, old FF problem
    $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
      fromCodePoint: function fromCodePoint (x) { // eslint-disable-line no-unused-vars
        var res = []
        var aLen = arguments.length
        var i = 0
        var code
        while (aLen > i) {
          code = +arguments[i++]
          if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point')
          res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      )
        } return res.join('')
      }
    })
  /** */ },
/* 331 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

    var $export = __webpack_require__(0)
    var context = __webpack_require__(100)
    var INCLUDES = 'includes'

    $export($export.P + $export.F * __webpack_require__(84)(INCLUDES), 'String', {
      includes: function includes (searchString /* , position = 0 */) {
        return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined)
      }
    })
  /** */ },
/* 332 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.9 String.prototype.italics()
    __webpack_require__(19)('italics', function (createHTML) {
      return function italics () {
        return createHTML(this, 'i', '', '')
      }
    })
  /** */ },
/* 333 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $at = __webpack_require__(99)(true)

// 21.1.3.27 String.prototype[@@iterator]()
    __webpack_require__(68)(String, 'String', function (iterated) {
      this._t = String(iterated) // target
      this._i = 0                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
    }, function () {
      var O = this._t
      var index = this._i
      var point
      if (index >= O.length) return { value: undefined, done: true }
      point = $at(O, index)
      this._i += point.length
      return { value: point, done: false }
    })
  /** */ },
/* 334 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.10 String.prototype.link(url)
    __webpack_require__(19)('link', function (createHTML) {
      return function link (url) {
        return createHTML(this, 'a', 'href', url)
      }
    })
  /** */ },
/* 335 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var toIObject = __webpack_require__(16)
    var toLength = __webpack_require__(8)

    $export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
      raw: function raw (callSite) {
        var tpl = toIObject(callSite.raw)
        var len = toLength(tpl.length)
        var aLen = arguments.length
        var res = []
        var i = 0
        while (len > i) {
          res.push(String(tpl[i++]))
          if (i < aLen) res.push(String(arguments[i]))
        } return res.join('')
      }
    })
  /** */ },
/* 336 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)

    $export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
      repeat: __webpack_require__(101)
    })
  /** */ },
/* 337 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.11 String.prototype.small()
    __webpack_require__(19)('small', function (createHTML) {
      return function small () {
        return createHTML(this, 'small', '', '')
      }
    })
  /** */ },
/* 338 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

    var $export = __webpack_require__(0)
    var toLength = __webpack_require__(8)
    var context = __webpack_require__(100)
    var STARTS_WITH = 'startsWith'
    var $startsWith = ''[STARTS_WITH]

    $export($export.P + $export.F * __webpack_require__(84)(STARTS_WITH), 'String', {
      startsWith: function startsWith (searchString /* , position = 0 */) {
        var that = context(this, searchString, STARTS_WITH)
        var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
        var search = String(searchString)
        return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search
      }
    })
  /** */ },
/* 339 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.12 String.prototype.strike()
    __webpack_require__(19)('strike', function (createHTML) {
      return function strike () {
        return createHTML(this, 'strike', '', '')
      }
    })
  /** */ },
/* 340 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.13 String.prototype.sub()
    __webpack_require__(19)('sub', function (createHTML) {
      return function sub () {
        return createHTML(this, 'sub', '', '')
      }
    })
  /** */ },
/* 341 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// B.2.3.14 String.prototype.sup()
    __webpack_require__(19)('sup', function (createHTML) {
      return function sup () {
        return createHTML(this, 'sup', '', '')
      }
    })
  /** */ },
/* 342 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// 21.1.3.25 String.prototype.trim()
    __webpack_require__(59)('trim', function ($trim) {
      return function trim () {
        return $trim(this, 3)
      }
    })
  /** */ },
/* 343 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// ECMAScript 6 symbols shim
    var global = __webpack_require__(2)
    var has = __webpack_require__(21)
    var DESCRIPTORS = __webpack_require__(12)
    var $export = __webpack_require__(0)
    var redefine = __webpack_require__(96)
    var META = __webpack_require__(36).KEY
    var $fails = __webpack_require__(5)
    var shared = __webpack_require__(73)
    var setToStringTag = __webpack_require__(51)
    var uid = __webpack_require__(52)
    var wks = __webpack_require__(9)
    var wksExt = __webpack_require__(151)
    var wksDefine = __webpack_require__(105)
    var enumKeys = __webpack_require__(207)
    var isArray = __webpack_require__(66)
    var anObject = __webpack_require__(1)
    var toIObject = __webpack_require__(16)
    var toPrimitive = __webpack_require__(40)
    var createDesc = __webpack_require__(39)
    var _create = __webpack_require__(37)
    var gOPNExt = __webpack_require__(139)
    var $GOPD = __webpack_require__(23)
    var $DP = __webpack_require__(11)
    var $keys = __webpack_require__(38)
    var gOPD = $GOPD.f
    var dP = $DP.f
    var gOPN = gOPNExt.f
    var $Symbol = global.Symbol
    var $JSON = global.JSON
    var _stringify = $JSON && $JSON.stringify
    var PROTOTYPE = 'prototype'
    var HIDDEN = wks('_hidden')
    var TO_PRIMITIVE = wks('toPrimitive')
    var isEnum = {}.propertyIsEnumerable
    var SymbolRegistry = shared('symbol-registry')
    var AllSymbols = shared('symbols')
    var OPSymbols = shared('op-symbols')
    var ObjectProto = Object[PROTOTYPE]
    var USE_NATIVE = typeof $Symbol === 'function'
    var QObject = global.QObject
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
    var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
    var setSymbolDesc = DESCRIPTORS && $fails(function () {
      return _create(dP({}, 'a', {
        get: function () { return dP(this, 'a', { value: 7 }).a }
      })).a != 7
    }) ? function (it, key, D) {
      var protoDesc = gOPD(ObjectProto, key)
      if (protoDesc) delete ObjectProto[key]
      dP(it, key, D)
      if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc)
    } : dP

    var wrap = function (tag) {
      var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE])
      sym._k = tag
      return sym
    }

    var isSymbol = USE_NATIVE && typeof $Symbol.iterator === 'symbol' ? function (it) {
      return typeof it === 'symbol'
    } : function (it) {
      return it instanceof $Symbol
    }

    var $defineProperty = function defineProperty (it, key, D) {
      if (it === ObjectProto) $defineProperty(OPSymbols, key, D)
      anObject(it)
      key = toPrimitive(key, true)
      anObject(D)
      if (has(AllSymbols, key)) {
        if (!D.enumerable) {
          if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}))
          it[HIDDEN][key] = true
        } else {
          if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false
          D = _create(D, { enumerable: createDesc(0, false) })
        } return setSymbolDesc(it, key, D)
      } return dP(it, key, D)
    }
    var $defineProperties = function defineProperties (it, P) {
      anObject(it)
      var keys = enumKeys(P = toIObject(P))
      var i = 0
      var l = keys.length
      var key
      while (l > i) $defineProperty(it, key = keys[i++], P[key])
      return it
    }
    var $create = function create (it, P) {
      return P === undefined ? _create(it) : $defineProperties(_create(it), P)
    }
    var $propertyIsEnumerable = function propertyIsEnumerable (key) {
      var E = isEnum.call(this, key = toPrimitive(key, true))
      if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false
      return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true
    }
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor (it, key) {
      it = toIObject(it)
      key = toPrimitive(key, true)
      if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return
      var D = gOPD(it, key)
      if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true
      return D
    }
    var $getOwnPropertyNames = function getOwnPropertyNames (it) {
      var names = gOPN(toIObject(it))
      var result = []
      var i = 0
      var key
      while (names.length > i) {
        if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key)
      } return result
    }
    var $getOwnPropertySymbols = function getOwnPropertySymbols (it) {
      var IS_OP = it === ObjectProto
      var names = gOPN(IS_OP ? OPSymbols : toIObject(it))
      var result = []
      var i = 0
      var key
      while (names.length > i) {
        if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key])
      } return result
    }

// 19.4.1.1 Symbol([description])
    if (!USE_NATIVE) {
      $Symbol = function Symbol () {
        if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!')
        var tag = uid(arguments.length > 0 ? arguments[0] : undefined)
        var $set = function (value) {
          if (this === ObjectProto) $set.call(OPSymbols, value)
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false
          setSymbolDesc(this, tag, createDesc(1, value))
        }
        if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set })
        return wrap(tag)
      }
      redefine($Symbol[PROTOTYPE], 'toString', function toString () {
        return this._k
      })

      $GOPD.f = $getOwnPropertyDescriptor
      $DP.f = $defineProperty
      __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames
      __webpack_require__(58).f = $propertyIsEnumerable
      __webpack_require__(70).f = $getOwnPropertySymbols

      if (DESCRIPTORS && !__webpack_require__(46)) {
        redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true)
      }

      wksExt.f = function (name) {
        return wrap(wks(name))
      }
    }

    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol })

    for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++])

    for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++])

    $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
      'for': function (key) {
        return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key)
      },
  // 19.4.2.5 Symbol.keyFor(sym)
      keyFor: function keyFor (sym) {
        if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!')
        for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key
      },
      useSetter: function () { setter = true },
      useSimple: function () { setter = false }
    })

    $export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
      create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
      defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
      defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
      getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
      getOwnPropertySymbols: $getOwnPropertySymbols
    })

// 24.3.2 JSON.stringify(value [, replacer [, space]])
    $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
      var S = $Symbol()
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
      return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}'
    })), 'JSON', {
      stringify: function stringify (it) {
        if (it === undefined || isSymbol(it)) return // IE8 returns string on undefined
        var args = [it]
        var i = 1
        var replacer, $replacer
        while (arguments.length > i) args.push(arguments[i++])
        replacer = args[1]
        if (typeof replacer === 'function') $replacer = replacer
        if ($replacer || !isArray(replacer)) {
          replacer = function (key, value) {
            if ($replacer) value = $replacer.call(this, key, value)
            if (!isSymbol(value)) return value
          }
        }
        args[1] = replacer
        return _stringify.apply($JSON, args)
      }
    })

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
    $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(22)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf)
// 19.4.3.5 Symbol.prototype[@@toStringTag]
    setToStringTag($Symbol, 'Symbol')
// 20.2.1.9 Math[@@toStringTag]
    setToStringTag(Math, 'Math', true)
// 24.3.3 JSON[@@toStringTag]
    setToStringTag(global.JSON, 'JSON', true)
  /** */ },
/* 344 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var $typed = __webpack_require__(75)
    var buffer = __webpack_require__(104)
    var anObject = __webpack_require__(1)
    var toAbsoluteIndex = __webpack_require__(49)
    var toLength = __webpack_require__(8)
    var isObject = __webpack_require__(4)
    var ArrayBuffer = __webpack_require__(2).ArrayBuffer
    var speciesConstructor = __webpack_require__(74)
    var $ArrayBuffer = buffer.ArrayBuffer
    var $DataView = buffer.DataView
    var $isView = $typed.ABV && ArrayBuffer.isView
    var $slice = $ArrayBuffer.prototype.slice
    var VIEW = $typed.VIEW
    var ARRAY_BUFFER = 'ArrayBuffer'

    $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer })

    $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
      isView: function isView (it) {
        return $isView && $isView(it) || isObject(it) && VIEW in it
      }
    })

    $export($export.P + $export.U + $export.F * __webpack_require__(5)(function () {
      return !new $ArrayBuffer(2).slice(1, undefined).byteLength
    }), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
      slice: function slice (start, end) {
        if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start) // FF fix
        var len = anObject(this).byteLength
        var first = toAbsoluteIndex(start, len)
        var final = toAbsoluteIndex(end === undefined ? len : end, len)
        var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
        var viewS = new $DataView(this)
        var viewT = new $DataView(result)
        var index = 0
        while (first < final) {
          viewT.setUint8(index++, viewS.getUint8(first++))
        } return result
      }
    })

    __webpack_require__(48)(ARRAY_BUFFER)
  /** */ },
/* 345 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    $export($export.G + $export.W + $export.F * !__webpack_require__(75).ABV, {
      DataView: __webpack_require__(104).DataView
    })
  /** */ },
/* 346 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Float32', 4, function (init) {
      return function Float32Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 347 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Float64', 8, function (init) {
      return function Float64Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 348 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Int16', 2, function (init) {
      return function Int16Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 349 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Int32', 4, function (init) {
      return function Int32Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 350 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Int8', 1, function (init) {
      return function Int8Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 351 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Uint16', 2, function (init) {
      return function Uint16Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 352 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Uint32', 4, function (init) {
      return function Uint32Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 353 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Uint8', 1, function (init) {
      return function Uint8Array (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    })
  /** */ },
/* 354 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(32)('Uint8', 1, function (init) {
      return function Uint8ClampedArray (data, byteOffset, length) {
        return init(this, data, byteOffset, length)
      }
    }, true)
  /** */ },
/* 355 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var weak = __webpack_require__(127)
    var validate = __webpack_require__(53)
    var WEAK_SET = 'WeakSet'

// 23.4 WeakSet Objects
    __webpack_require__(65)(WEAK_SET, function (get) {
      return function WeakSet () { return get(this, arguments.length > 0 ? arguments[0] : undefined) }
    }, {
  // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add (value) {
        return weak.def(validate(this, WEAK_SET), value, true)
      }
    }, weak, false, true)
  /** */ },
/* 356 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
    var $export = __webpack_require__(0)
    var flattenIntoArray = __webpack_require__(129)
    var toObject = __webpack_require__(13)
    var toLength = __webpack_require__(8)
    var aFunction = __webpack_require__(14)
    var arraySpeciesCreate = __webpack_require__(80)

    $export($export.P, 'Array', {
      flatMap: function flatMap (callbackfn /* , thisArg */) {
        var O = toObject(this)
        var sourceLen, A
        aFunction(callbackfn)
        sourceLen = toLength(O.length)
        A = arraySpeciesCreate(O, 0)
        flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1])
        return A
      }
    })

    __webpack_require__(34)('flatMap')
  /** */ },
/* 357 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
    var $export = __webpack_require__(0)
    var flattenIntoArray = __webpack_require__(129)
    var toObject = __webpack_require__(13)
    var toLength = __webpack_require__(8)
    var toInteger = __webpack_require__(29)
    var arraySpeciesCreate = __webpack_require__(80)

    $export($export.P, 'Array', {
      flatten: function flatten (/* depthArg = 1 */) {
        var depthArg = arguments[0]
        var O = toObject(this)
        var sourceLen = toLength(O.length)
        var A = arraySpeciesCreate(O, 0)
        flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg))
        return A
      }
    })

    __webpack_require__(34)('flatten')
  /** */ },
/* 358 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/tc39/Array.prototype.includes
    var $export = __webpack_require__(0)
    var $includes = __webpack_require__(64)(true)

    $export($export.P, 'Array', {
      includes: function includes (el /* , fromIndex = 0 */) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined)
      }
    })

    __webpack_require__(34)('includes')
  /** */ },
/* 359 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
    var $export = __webpack_require__(0)
    var microtask = __webpack_require__(92)()
    var process = __webpack_require__(2).process
    var isNode = __webpack_require__(27)(process) == 'process'

    $export($export.G, {
      asap: function asap (fn) {
        var domain = isNode && process.domain
        microtask(domain ? domain.bind(fn) : fn)
      }
    })
  /** */ },
/* 360 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/ljharb/proposal-is-error
    var $export = __webpack_require__(0)
    var cof = __webpack_require__(27)

    $export($export.S, 'Error', {
      isError: function isError (it) {
        return cof(it) === 'Error'
      }
    })
  /** */ },
/* 361 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/tc39/proposal-global
    var $export = __webpack_require__(0)

    $export($export.G, { global: __webpack_require__(2) })
  /** */ },
/* 362 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
    __webpack_require__(71)('Map')
  /** */ },
/* 363 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
    __webpack_require__(72)('Map')
  /** */ },
/* 364 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
    var $export = __webpack_require__(0)

    $export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(126)('Map') })
  /** */ },
/* 365 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      clamp: function clamp (x, lower, upper) {
        return Math.min(upper, Math.max(lower, x))
      }
    })
  /** */ },
/* 366 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 })
  /** */ },
/* 367 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)
    var RAD_PER_DEG = 180 / Math.PI

    $export($export.S, 'Math', {
      degrees: function degrees (radians) {
        return radians * RAD_PER_DEG
      }
    })
  /** */ },
/* 368 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)
    var scale = __webpack_require__(136)
    var fround = __webpack_require__(134)

    $export($export.S, 'Math', {
      fscale: function fscale (x, inLow, inHigh, outLow, outHigh) {
        return fround(scale(x, inLow, inHigh, outLow, outHigh))
      }
    })
  /** */ },
/* 369 */
  /** */ function (module, exports, __webpack_require__) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      iaddh: function iaddh (x0, x1, y0, y1) {
        var $x0 = x0 >>> 0
        var $x1 = x1 >>> 0
        var $y0 = y0 >>> 0
        return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0
      }
    })
  /** */ },
/* 370 */
  /** */ function (module, exports, __webpack_require__) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      imulh: function imulh (u, v) {
        var UINT16 = 0xffff
        var $u = +u
        var $v = +v
        var u0 = $u & UINT16
        var v0 = $v & UINT16
        var u1 = $u >> 16
        var v1 = $v >> 16
        var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16)
        return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16)
      }
    })
  /** */ },
/* 371 */
  /** */ function (module, exports, __webpack_require__) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      isubh: function isubh (x0, x1, y0, y1) {
        var $x0 = x0 >>> 0
        var $x1 = x1 >>> 0
        var $y0 = y0 >>> 0
        return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0
      }
    })
  /** */ },
/* 372 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI })
  /** */ },
/* 373 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)
    var DEG_PER_RAD = Math.PI / 180

    $export($export.S, 'Math', {
      radians: function radians (degrees) {
        return degrees * DEG_PER_RAD
      }
    })
  /** */ },
/* 374 */
  /** */ function (module, exports, __webpack_require__) {
// https://rwaldron.github.io/proposal-math-extensions/
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { scale: __webpack_require__(136) })
  /** */ },
/* 375 */
  /** */ function (module, exports, __webpack_require__) {
// http://jfbastien.github.io/papers/Math.signbit.html
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', { signbit: function signbit (x) {
  // eslint-disable-next-line no-self-compare
      return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0
    } })
  /** */ },
/* 376 */
  /** */ function (module, exports, __webpack_require__) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
    var $export = __webpack_require__(0)

    $export($export.S, 'Math', {
      umulh: function umulh (u, v) {
        var UINT16 = 0xffff
        var $u = +u
        var $v = +v
        var u0 = $u & UINT16
        var v0 = $v & UINT16
        var u1 = $u >>> 16
        var v1 = $v >>> 16
        var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16)
        return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16)
      }
    })
  /** */ },
/* 377 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toObject = __webpack_require__(13)
    var aFunction = __webpack_require__(14)
    var $defineProperty = __webpack_require__(11)

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
    __webpack_require__(12) && $export($export.P + __webpack_require__(69), 'Object', {
      __defineGetter__: function __defineGetter__ (P, getter) {
        $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true })
      }
    })
  /** */ },
/* 378 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toObject = __webpack_require__(13)
    var aFunction = __webpack_require__(14)
    var $defineProperty = __webpack_require__(11)

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
    __webpack_require__(12) && $export($export.P + __webpack_require__(69), 'Object', {
      __defineSetter__: function __defineSetter__ (P, setter) {
        $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true })
      }
    })
  /** */ },
/* 379 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/tc39/proposal-object-values-entries
    var $export = __webpack_require__(0)
    var $entries = __webpack_require__(141)(true)

    $export($export.S, 'Object', {
      entries: function entries (it) {
        return $entries(it)
      }
    })
  /** */ },
/* 380 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
    var $export = __webpack_require__(0)
    var ownKeys = __webpack_require__(95)
    var toIObject = __webpack_require__(16)
    var gOPD = __webpack_require__(23)
    var createProperty = __webpack_require__(81)

    $export($export.S, 'Object', {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors (object) {
        var O = toIObject(object)
        var getDesc = gOPD.f
        var keys = ownKeys(O)
        var result = {}
        var i = 0
        var key, desc
        while (keys.length > i) {
          desc = getDesc(O, key = keys[i++])
          if (desc !== undefined) createProperty(result, key, desc)
        }
        return result
      }
    })
  /** */ },
/* 381 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toObject = __webpack_require__(13)
    var toPrimitive = __webpack_require__(40)
    var getPrototypeOf = __webpack_require__(18)
    var getOwnPropertyDescriptor = __webpack_require__(23).f

// B.2.2.4 Object.prototype.__lookupGetter__(P)
    __webpack_require__(12) && $export($export.P + __webpack_require__(69), 'Object', {
      __lookupGetter__: function __lookupGetter__ (P) {
        var O = toObject(this)
        var K = toPrimitive(P, true)
        var D
        do {
          if (D = getOwnPropertyDescriptor(O, K)) return D.get
        } while (O = getPrototypeOf(O))
      }
    })
  /** */ },
/* 382 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var $export = __webpack_require__(0)
    var toObject = __webpack_require__(13)
    var toPrimitive = __webpack_require__(40)
    var getPrototypeOf = __webpack_require__(18)
    var getOwnPropertyDescriptor = __webpack_require__(23).f

// B.2.2.5 Object.prototype.__lookupSetter__(P)
    __webpack_require__(12) && $export($export.P + __webpack_require__(69), 'Object', {
      __lookupSetter__: function __lookupSetter__ (P) {
        var O = toObject(this)
        var K = toPrimitive(P, true)
        var D
        do {
          if (D = getOwnPropertyDescriptor(O, K)) return D.set
        } while (O = getPrototypeOf(O))
      }
    })
  /** */ },
/* 383 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/tc39/proposal-object-values-entries
    var $export = __webpack_require__(0)
    var $values = __webpack_require__(141)(false)

    $export($export.S, 'Object', {
      values: function values (it) {
        return $values(it)
      }
    })
  /** */ },
/* 384 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/zenparsing/es-observable
    var $export = __webpack_require__(0)
    var global = __webpack_require__(2)
    var core = __webpack_require__(15)
    var microtask = __webpack_require__(92)()
    var OBSERVABLE = __webpack_require__(9)('observable')
    var aFunction = __webpack_require__(14)
    var anObject = __webpack_require__(1)
    var anInstance = __webpack_require__(43)
    var redefineAll = __webpack_require__(47)
    var hide = __webpack_require__(22)
    var forOf = __webpack_require__(35)
    var RETURN = forOf.RETURN

    var getMethod = function (fn) {
      return fn == null ? undefined : aFunction(fn)
    }

    var cleanupSubscription = function (subscription) {
      var cleanup = subscription._c
      if (cleanup) {
        subscription._c = undefined
        cleanup()
      }
    }

    var subscriptionClosed = function (subscription) {
      return subscription._o === undefined
    }

    var closeSubscription = function (subscription) {
      if (!subscriptionClosed(subscription)) {
        subscription._o = undefined
        cleanupSubscription(subscription)
      }
    }

    var Subscription = function (observer, subscriber) {
      anObject(observer)
      this._c = undefined
      this._o = observer
      observer = new SubscriptionObserver(this)
      try {
        var cleanup = subscriber(observer)
        var subscription = cleanup
        if (cleanup != null) {
          if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe() }
          else aFunction(cleanup)
          this._c = cleanup
        }
      } catch (e) {
        observer.error(e)
        return
      } if (subscriptionClosed(this)) cleanupSubscription(this)
    }

    Subscription.prototype = redefineAll({}, {
      unsubscribe: function unsubscribe () { closeSubscription(this) }
    })

    var SubscriptionObserver = function (subscription) {
      this._s = subscription
    }

    SubscriptionObserver.prototype = redefineAll({}, {
      next: function next (value) {
        var subscription = this._s
        if (!subscriptionClosed(subscription)) {
          var observer = subscription._o
          try {
            var m = getMethod(observer.next)
            if (m) return m.call(observer, value)
          } catch (e) {
            try {
              closeSubscription(subscription)
            } finally {
              throw e
            }
          }
        }
      },
      error: function error (value) {
        var subscription = this._s
        if (subscriptionClosed(subscription)) throw value
        var observer = subscription._o
        subscription._o = undefined
        try {
          var m = getMethod(observer.error)
          if (!m) throw value
          value = m.call(observer, value)
        } catch (e) {
          try {
            cleanupSubscription(subscription)
          } finally {
            throw e
          }
        } cleanupSubscription(subscription)
        return value
      },
      complete: function complete (value) {
        var subscription = this._s
        if (!subscriptionClosed(subscription)) {
          var observer = subscription._o
          subscription._o = undefined
          try {
            var m = getMethod(observer.complete)
            value = m ? m.call(observer, value) : undefined
          } catch (e) {
            try {
              cleanupSubscription(subscription)
            } finally {
              throw e
            }
          } cleanupSubscription(subscription)
          return value
        }
      }
    })

    var $Observable = function Observable (subscriber) {
      anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber)
    }

    redefineAll($Observable.prototype, {
      subscribe: function subscribe (observer) {
        return new Subscription(observer, this._f)
      },
      forEach: function forEach (fn) {
        var that = this
        return new (core.Promise || global.Promise)(function (resolve, reject) {
          aFunction(fn)
          var subscription = that.subscribe({
            next: function (value) {
              try {
                return fn(value)
              } catch (e) {
                reject(e)
                subscription.unsubscribe()
              }
            },
            error: reject,
            complete: resolve
          })
        })
      }
    })

    redefineAll($Observable, {
      from: function from (x) {
        var C = typeof this === 'function' ? this : $Observable
        var method = getMethod(anObject(x)[OBSERVABLE])
        if (method) {
          var observable = anObject(method.call(x))
          return observable.constructor === C ? observable : new C(function (observer) {
            return observable.subscribe(observer)
          })
        }
        return new C(function (observer) {
          var done = false
          microtask(function () {
            if (!done) {
              try {
                if (forOf(x, false, function (it) {
                  observer.next(it)
                  if (done) return RETURN
                }) === RETURN) return
              } catch (e) {
                if (done) throw e
                observer.error(e)
                return
              } observer.complete()
            }
          })
          return function () { done = true }
        })
      },
      of: function of () {
        for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++]
        return new (typeof this === 'function' ? this : $Observable)(function (observer) {
          var done = false
          microtask(function () {
            if (!done) {
              for (var j = 0; j < items.length; ++j) {
                observer.next(items[j])
                if (done) return
              } observer.complete()
            }
          })
          return function () { done = true }
        })
      }
    })

    hide($Observable.prototype, OBSERVABLE, function () { return this })

    $export($export.G, { Observable: $Observable })

    __webpack_require__(48)('Observable')
  /** */ },
/* 385 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// https://github.com/tc39/proposal-promise-finally

    var $export = __webpack_require__(0)
    var core = __webpack_require__(15)
    var global = __webpack_require__(2)
    var speciesConstructor = __webpack_require__(74)
    var promiseResolve = __webpack_require__(147)

    $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
      var C = speciesConstructor(this, core.Promise || global.Promise)
      var isFunction = typeof onFinally === 'function'
      return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x })
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e })
    } : onFinally
  )
    } })
  /** */ },
/* 386 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/tc39/proposal-promise-try
    var $export = __webpack_require__(0)
    var newPromiseCapability = __webpack_require__(93)
    var perform = __webpack_require__(146)

    $export($export.S, 'Promise', { 'try': function (callbackfn) {
      var promiseCapability = newPromiseCapability.f(this)
      var result = perform(callbackfn);
      (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v)
      return promiseCapability.promise
    } })
  /** */ },
/* 387 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var toMetaKey = metadata.key
    var ordinaryDefineOwnMetadata = metadata.set

    metadata.exp({ defineMetadata: function defineMetadata (metadataKey, metadataValue, target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey))
    } })
  /** */ },
/* 388 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var toMetaKey = metadata.key
    var getOrCreateMetadataMap = metadata.map
    var store = metadata.store

    metadata.exp({ deleteMetadata: function deleteMetadata (metadataKey, target /* , targetKey */) {
      var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
      var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false)
      if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false
      if (metadataMap.size) return true
      var targetMetadata = store.get(target)
      targetMetadata['delete'](targetKey)
      return !!targetMetadata.size || store['delete'](target)
    } })
  /** */ },
/* 389 */
  /** */ function (module, exports, __webpack_require__) {
    var Set = __webpack_require__(154)
    var from = __webpack_require__(122)
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var getPrototypeOf = __webpack_require__(18)
    var ordinaryOwnMetadataKeys = metadata.keys
    var toMetaKey = metadata.key

    var ordinaryMetadataKeys = function (O, P) {
      var oKeys = ordinaryOwnMetadataKeys(O, P)
      var parent = getPrototypeOf(O)
      if (parent === null) return oKeys
      var pKeys = ordinaryMetadataKeys(parent, P)
      return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys
    }

    metadata.exp({ getMetadataKeys: function getMetadataKeys (target /* , targetKey */) {
      return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]))
    } })
  /** */ },
/* 390 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var getPrototypeOf = __webpack_require__(18)
    var ordinaryHasOwnMetadata = metadata.has
    var ordinaryGetOwnMetadata = metadata.get
    var toMetaKey = metadata.key

    var ordinaryGetMetadata = function (MetadataKey, O, P) {
      var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P)
      if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P)
      var parent = getPrototypeOf(O)
      return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined
    }

    metadata.exp({ getMetadata: function getMetadata (metadataKey, target /* , targetKey */) {
      return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
    } })
  /** */ },
/* 391 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var ordinaryOwnMetadataKeys = metadata.keys
    var toMetaKey = metadata.key

    metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys (target /* , targetKey */) {
      return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]))
    } })
  /** */ },
/* 392 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var ordinaryGetOwnMetadata = metadata.get
    var toMetaKey = metadata.key

    metadata.exp({ getOwnMetadata: function getOwnMetadata (metadataKey, target /* , targetKey */) {
      return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
    } })
  /** */ },
/* 393 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var getPrototypeOf = __webpack_require__(18)
    var ordinaryHasOwnMetadata = metadata.has
    var toMetaKey = metadata.key

    var ordinaryHasMetadata = function (MetadataKey, O, P) {
      var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P)
      if (hasOwn) return true
      var parent = getPrototypeOf(O)
      return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false
    }

    metadata.exp({ hasMetadata: function hasMetadata (metadataKey, target /* , targetKey */) {
      return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
    } })
  /** */ },
/* 394 */
  /** */ function (module, exports, __webpack_require__) {
    var metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var ordinaryHasOwnMetadata = metadata.has
    var toMetaKey = metadata.key

    metadata.exp({ hasOwnMetadata: function hasOwnMetadata (metadataKey, target /* , targetKey */) {
      return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]))
    } })
  /** */ },
/* 395 */
  /** */ function (module, exports, __webpack_require__) {
    var $metadata = __webpack_require__(31)
    var anObject = __webpack_require__(1)
    var aFunction = __webpack_require__(14)
    var toMetaKey = $metadata.key
    var ordinaryDefineOwnMetadata = $metadata.set

    $metadata.exp({ metadata: function metadata (metadataKey, metadataValue) {
      return function decorator (target, targetKey) {
        ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    )
      }
    } })
  /** */ },
/* 396 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
    __webpack_require__(71)('Set')
  /** */ },
/* 397 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
    __webpack_require__(72)('Set')
  /** */ },
/* 398 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
    var $export = __webpack_require__(0)

    $export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(126)('Set') })
  /** */ },
/* 399 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/mathiasbynens/String.prototype.at
    var $export = __webpack_require__(0)
    var $at = __webpack_require__(99)(true)

    $export($export.P, 'String', {
      at: function at (pos) {
        return $at(this, pos)
      }
    })
  /** */ },
/* 400 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://tc39.github.io/String.prototype.matchAll/
    var $export = __webpack_require__(0)
    var defined = __webpack_require__(30)
    var toLength = __webpack_require__(8)
    var isRegExp = __webpack_require__(132)
    var getFlags = __webpack_require__(208)
    var RegExpProto = RegExp.prototype

    var $RegExpStringIterator = function (regexp, string) {
      this._r = regexp
      this._s = string
    }

    __webpack_require__(67)($RegExpStringIterator, 'RegExp String', function next () {
      var match = this._r.exec(this._s)
      return { value: match, done: match === null }
    })

    $export($export.P, 'String', {
      matchAll: function matchAll (regexp) {
        defined(this)
        if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!')
        var S = String(this)
        var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
        var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags)
        rx.lastIndex = toLength(regexp.lastIndex)
        return new $RegExpStringIterator(rx, S)
      }
    })
  /** */ },
/* 401 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/tc39/proposal-string-pad-start-end
    var $export = __webpack_require__(0)
    var $pad = __webpack_require__(149)

    $export($export.P, 'String', {
      padEnd: function padEnd (maxLength /* , fillString = ' ' */) {
        return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false)
      }
    })
  /** */ },
/* 402 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/tc39/proposal-string-pad-start-end
    var $export = __webpack_require__(0)
    var $pad = __webpack_require__(149)

    $export($export.P, 'String', {
      padStart: function padStart (maxLength /* , fillString = ' ' */) {
        return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true)
      }
    })
  /** */ },
/* 403 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
    __webpack_require__(59)('trimLeft', function ($trim) {
      return function trimLeft () {
        return $trim(this, 1)
      }
    }, 'trimStart')
  /** */ },
/* 404 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
    __webpack_require__(59)('trimRight', function ($trim) {
      return function trimRight () {
        return $trim(this, 2)
      }
    }, 'trimEnd')
  /** */ },
/* 405 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(105)('asyncIterator')
  /** */ },
/* 406 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(105)('observable')
  /** */ },
/* 407 */
  /** */ function (module, exports, __webpack_require__) {
// https://github.com/tc39/proposal-global
    var $export = __webpack_require__(0)

    $export($export.S, 'System', { global: __webpack_require__(2) })
  /** */ },
/* 408 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
    __webpack_require__(71)('WeakMap')
  /** */ },
/* 409 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
    __webpack_require__(72)('WeakMap')
  /** */ },
/* 410 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
    __webpack_require__(71)('WeakSet')
  /** */ },
/* 411 */
  /** */ function (module, exports, __webpack_require__) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
    __webpack_require__(72)('WeakSet')
  /** */ },
/* 412 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(106)
    var global = __webpack_require__(2)
    var hide = __webpack_require__(22)
    var Iterators = __webpack_require__(45)
    var TO_STRING_TAG = __webpack_require__(9)('toStringTag')

    var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',')

    for (var i = 0; i < DOMIterables.length; i++) {
      var NAME = DOMIterables[i]
      var Collection = global[NAME]
      var proto = Collection && Collection.prototype
      if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME)
      Iterators[NAME] = Iterators.Array
    }
  /** */ },
/* 413 */
  /** */ function (module, exports, __webpack_require__) {
    var $export = __webpack_require__(0)
    var $task = __webpack_require__(103)
    $export($export.G + $export.B, {
      setImmediate: $task.set,
      clearImmediate: $task.clear
    })
  /** */ },
/* 414 */
  /** */ function (module, exports, __webpack_require__) {
// ie9- setTimeout & setInterval additional parameters fix
    var global = __webpack_require__(2)
    var $export = __webpack_require__(0)
    var navigator = global.navigator
    var slice = [].slice
    var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent) // <- dirty ie9- check
    var wrap = function (set) {
      return function (fn, time /* , ...args */) {
        var boundArgs = arguments.length > 2
        var args = boundArgs ? slice.call(arguments, 2) : false
        return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
          (typeof fn === 'function' ? fn : Function(fn)).apply(this, args)
        } : fn, time)
      }
    }
    $export($export.G + $export.B + $export.F * MSIE, {
      setTimeout: wrap(global.setTimeout),
      setInterval: wrap(global.setInterval)
    })
  /** */ },
/* 415 */
  /** */ function (module, exports, __webpack_require__) {
    __webpack_require__(343)
    __webpack_require__(281)
    __webpack_require__(283)
    __webpack_require__(282)
    __webpack_require__(285)
    __webpack_require__(287)
    __webpack_require__(292)
    __webpack_require__(286)
    __webpack_require__(284)
    __webpack_require__(294)
    __webpack_require__(293)
    __webpack_require__(289)
    __webpack_require__(290)
    __webpack_require__(288)
    __webpack_require__(280)
    __webpack_require__(291)
    __webpack_require__(295)
    __webpack_require__(296)
    __webpack_require__(248)
    __webpack_require__(250)
    __webpack_require__(249)
    __webpack_require__(298)
    __webpack_require__(297)
    __webpack_require__(268)
    __webpack_require__(278)
    __webpack_require__(279)
    __webpack_require__(269)
    __webpack_require__(270)
    __webpack_require__(271)
    __webpack_require__(272)
    __webpack_require__(273)
    __webpack_require__(274)
    __webpack_require__(275)
    __webpack_require__(276)
    __webpack_require__(277)
    __webpack_require__(251)
    __webpack_require__(252)
    __webpack_require__(253)
    __webpack_require__(254)
    __webpack_require__(255)
    __webpack_require__(256)
    __webpack_require__(257)
    __webpack_require__(258)
    __webpack_require__(259)
    __webpack_require__(260)
    __webpack_require__(261)
    __webpack_require__(262)
    __webpack_require__(263)
    __webpack_require__(264)
    __webpack_require__(265)
    __webpack_require__(266)
    __webpack_require__(267)
    __webpack_require__(330)
    __webpack_require__(335)
    __webpack_require__(342)
    __webpack_require__(333)
    __webpack_require__(325)
    __webpack_require__(326)
    __webpack_require__(331)
    __webpack_require__(336)
    __webpack_require__(338)
    __webpack_require__(321)
    __webpack_require__(322)
    __webpack_require__(323)
    __webpack_require__(324)
    __webpack_require__(327)
    __webpack_require__(328)
    __webpack_require__(329)
    __webpack_require__(332)
    __webpack_require__(334)
    __webpack_require__(337)
    __webpack_require__(339)
    __webpack_require__(340)
    __webpack_require__(341)
    __webpack_require__(243)
    __webpack_require__(245)
    __webpack_require__(244)
    __webpack_require__(247)
    __webpack_require__(246)
    __webpack_require__(232)
    __webpack_require__(230)
    __webpack_require__(236)
    __webpack_require__(233)
    __webpack_require__(239)
    __webpack_require__(241)
    __webpack_require__(229)
    __webpack_require__(235)
    __webpack_require__(226)
    __webpack_require__(240)
    __webpack_require__(224)
    __webpack_require__(238)
    __webpack_require__(237)
    __webpack_require__(231)
    __webpack_require__(234)
    __webpack_require__(223)
    __webpack_require__(225)
    __webpack_require__(228)
    __webpack_require__(227)
    __webpack_require__(242)
    __webpack_require__(106)
    __webpack_require__(314)
    __webpack_require__(320)
    __webpack_require__(315)
    __webpack_require__(316)
    __webpack_require__(317)
    __webpack_require__(318)
    __webpack_require__(319)
    __webpack_require__(299)
    __webpack_require__(153)
    __webpack_require__(154)
    __webpack_require__(155)
    __webpack_require__(355)
    __webpack_require__(344)
    __webpack_require__(345)
    __webpack_require__(350)
    __webpack_require__(353)
    __webpack_require__(354)
    __webpack_require__(348)
    __webpack_require__(351)
    __webpack_require__(349)
    __webpack_require__(352)
    __webpack_require__(346)
    __webpack_require__(347)
    __webpack_require__(300)
    __webpack_require__(301)
    __webpack_require__(302)
    __webpack_require__(303)
    __webpack_require__(304)
    __webpack_require__(307)
    __webpack_require__(305)
    __webpack_require__(306)
    __webpack_require__(308)
    __webpack_require__(309)
    __webpack_require__(310)
    __webpack_require__(311)
    __webpack_require__(313)
    __webpack_require__(312)
    __webpack_require__(358)
    __webpack_require__(356)
    __webpack_require__(357)
    __webpack_require__(399)
    __webpack_require__(402)
    __webpack_require__(401)
    __webpack_require__(403)
    __webpack_require__(404)
    __webpack_require__(400)
    __webpack_require__(405)
    __webpack_require__(406)
    __webpack_require__(380)
    __webpack_require__(383)
    __webpack_require__(379)
    __webpack_require__(377)
    __webpack_require__(378)
    __webpack_require__(381)
    __webpack_require__(382)
    __webpack_require__(364)
    __webpack_require__(398)
    __webpack_require__(363)
    __webpack_require__(397)
    __webpack_require__(409)
    __webpack_require__(411)
    __webpack_require__(362)
    __webpack_require__(396)
    __webpack_require__(408)
    __webpack_require__(410)
    __webpack_require__(361)
    __webpack_require__(407)
    __webpack_require__(360)
    __webpack_require__(365)
    __webpack_require__(366)
    __webpack_require__(367)
    __webpack_require__(368)
    __webpack_require__(369)
    __webpack_require__(371)
    __webpack_require__(370)
    __webpack_require__(372)
    __webpack_require__(373)
    __webpack_require__(374)
    __webpack_require__(376)
    __webpack_require__(375)
    __webpack_require__(385)
    __webpack_require__(386)
    __webpack_require__(387)
    __webpack_require__(388)
    __webpack_require__(390)
    __webpack_require__(389)
    __webpack_require__(392)
    __webpack_require__(391)
    __webpack_require__(393)
    __webpack_require__(394)
    __webpack_require__(395)
    __webpack_require__(359)
    __webpack_require__(384)
    __webpack_require__(414)
    __webpack_require__(413)
    __webpack_require__(412)
    module.exports = __webpack_require__(15)
  /** */ },
/* 416 */
  /** */ function (module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(417)(undefined)
// imports

// module
    exports.push([module.i, "body {\n  margin: 0;\n}\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n#mocha .hidden {\n  display: none;\n}\n#mocha #stats {\n  position: absolute;\n}\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0;\n  }\n}\n#mocha > ul,\n#mocha .suite > ul,\n#mocha .suite {\n  margin: 0;\n  padding: 0;\n}\n#mocha > ul,\n#mocha .suite > ul {\n  list-style: none;\n}\n#mocha .suite > h1,\n#mocha li.test > h2 {\n  margin: 0;\n}\n#mocha .suite {\n  margin-left: 15px;\n}\n#mocha .suite > h1 {\n  font-size: 1em;\n  font-weight: 200;\n  margin-top: 15px;\n}\n#mocha .suite > h1 a {\n  color: inherit;\n  text-decoration: none;\n}\n#mocha .suite > h1 a:hover {\n  text-decoration: underline;\n}\n#mocha .suite .suite > h1 {\n  font-size: 0.8em;\n  margin-top: 0;\n}\n#mocha li.test {\n  margin-left: 15px;\n  overflow: hidden;\n/**\n    * (1): approximate for browsers not supporting calc\n    * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n    *      ^^ seriously\n    */\n}\n#mocha li.test > pre {\n  border: 1px solid #eee;\n  border-bottom-color: #ddd;\n  border-radius: 3px;\n  box-shadow: 0 1px 3px #eee;\n  clear: left;\n  display: block;\n  float: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  max-width: calc(100% - 42px); /*(2)*/\n  padding: 15px;\n  word-wrap: break-word;\n}\n#mocha li.test > pre code .comment {\n  color: #ddd;\n}\n#mocha li.test > pre code .init {\n  color: #2f6fad;\n}\n#mocha li.test > pre code .string {\n  color: #5890ad;\n}\n#mocha li.test > pre code .keyword {\n  color: #8a6343;\n}\n#mocha li.test > pre code .number {\n  color: #2f6fad;\n}\n#mocha li.test:hover > h2 a.replay {\n  opacity: 1;\n}\n#mocha li.test.pass.medium > h2 > .duration {\n  background: #c09853;\n}\n#mocha li.test.pass.slow > h2 > .duration {\n  background: #b94a48;\n}\n#mocha li.test.pass::before {\n  color: #00d6b2;\n  content: '\\2713';\n  display: block;\n  float: left;\n  font-size: 12px;\n  margin-right: 5px;\n}\n#mocha li.test.pass > h2 > .duration {\n  border-radius: 5px;\n  box-shadow: inset 0 1px 1px rgba(0,0,0,0.2);\n  color: #fff;\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n}\n#mocha li.test.pass.fast > h2 > .duration {\n  display: none;\n}\n#mocha li.test.pending > pre,\n#mocha li.test.pending > h2 {\n  color: #0b97c4;\n}\n#mocha li.test.pending::before {\n  color: #0b97c4;\n  content: '\\25E6';\n}\n#mocha li.test.pending:hover > h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n#mocha li.test.fail > pre,\n#mocha li.test.fail > h2 {\n  color: #c00;\n}\n#mocha li.test.fail > pre {\n  color: #000;\n}\n#mocha li.test.fail > pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n#mocha li.test.fail::before {\n  color: #c00;\n  content: '\\2716';\n  display: block;\n  float: left;\n  font-size: 12px;\n  margin-right: 5px;\n}\n#mocha li.test > html-error {\n  border: 1px solid #eee;\n  border-bottom-color: #ddd;\n  border-radius: 3px;\n  box-shadow: 0 1px 3px #eee;\n  clear: left;\n  color: #000;\n  display: block;\n  float: left;\n  font: 12px/1.5 monaco, monospace;\n  line-height: 1.5;\n  margin: 5px;\n  max-height: 300px;\n  max-width: calc(100% - 42px); /*(2)*/\n  overflow: auto;\n  padding: 15px;\n  word-wrap: break-word;\n}\n#mocha li.test > html-error pre.error {\n  border: none;\n  border-radius: 0;\n  box-shadow: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n  padding: 0;\n}\n#mocha li.test > h2 {\n  cursor: pointer;\n  font-size: 12px;\n  font-weight: normal;\n  position: relative;\n}\n#mocha li.test > h2 > a.replay {\n  background: #eee;\n  border-radius: 15px;\n  color: #888;\n  display: block;\n  font-size: 15px;\n  height: 15px;\n  line-height: 15px;\n  opacity: 0.3;\n  position: absolute;\n  right: 0;\n  text-align: center;\n  text-decoration: none;\n  top: 3px;\n  transition: opacity 200ms;\n  vertical-align: middle;\n  width: 15px;\n}\n#mocha-report.pass .test.fail {\n  display: none;\n}\n#mocha-report.fail .test.pass {\n  display: none;\n}\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n#mocha-stats {\n  color: #888;\n  font-size: 12px;\n  margin: 0;\n  position: fixed;\n  right: 10px;\n  top: 15px;\n  z-index: 1;\n}\n#mocha-stats .progress {\n  background-color: initial;\n  box-shadow: none;\n  float: right;\n  height: auto;\n  padding-top: 0;\n/**\n    * Set safe initial values, so mochas .progress does not inherit these\n    * properties from Bootstrap .progress (which causes .progress height to\n    * equal line height set in Bootstrap).\n    */\n}\n#mocha-stats em {\n  color: #000;\n}\n#mocha-stats a {\n  color: inherit;\n  text-decoration: none;\n}\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n#mocha-stats > li {\n  display: inline-block;\n  list-style: none;\n  margin: 0 5px;\n  padding-top: 11px;\n}\n#mocha-stats canvas {\n  height: 40px;\n  width: 40px;\n}\n", ''])

// exports
  /** */ },
/* 417 */
  /** */ function (module, exports) {
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
    module.exports = function (useSourceMap) {
      var list = []

	// return the list of modules as css string
      list.toString = function toString () {
        return this.map(function (item) {
          var content = cssWithMappingToString(item, useSourceMap)
          if (item[2]) {
            return '@media ' + item[2] + '{' + content + '}'
          } else {
            return content
          }
        }).join('')
      }

	// import a list of modules into the list
      list.i = function (modules, mediaQuery) {
        if (typeof modules === 'string') { modules = [[null, modules, '']] }
        var alreadyImportedModules = {}
        for (var i = 0; i < this.length; i++) {
          var id = this[i][0]
          if (typeof id === 'number') { alreadyImportedModules[id] = true }
        }
        for (i = 0; i < modules.length; i++) {
          var item = modules[i]
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
          if (typeof item[0] !== 'number' || !alreadyImportedModules[item[0]]) {
            if (mediaQuery && !item[2]) {
              item[2] = mediaQuery
            } else if (mediaQuery) {
              item[2] = '(' + item[2] + ') and (' + mediaQuery + ')'
            }
            list.push(item)
          }
        }
      }
      return list
    }

    function cssWithMappingToString (item, useSourceMap) {
      var content = item[1] || ''
      var cssMapping = item[3]
      if (!cssMapping) {
        return content
      }

      if (useSourceMap && typeof btoa === 'function') {
        var sourceMapping = toComment(cssMapping)
        var sourceURLs = cssMapping.sources.map(function (source) {
          return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
        })

        return [content].concat(sourceURLs).concat([sourceMapping]).join('\n')
      }

      return [content].join('\n')
    }

// Adapted from convert-source-map (MIT)
    function toComment (sourceMap) {
	// eslint-disable-next-line no-undef
      var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))
      var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64

      return '/*# ' + data + ' */'
    }
  /** */ },
/* 418 */
  /** */ function (module, exports, __webpack_require__) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug
    exports.coerce = coerce
    exports.disable = disable
    exports.enable = enable
    exports.enabled = enabled
    exports.humanize = __webpack_require__(426)

/**
 * The currently active debug mode names, and names to skip.
 */

    exports.names = []
    exports.skips = []

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

    exports.formatters = {}

/**
 * Previous log timestamp.
 */

    var prevTime

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

    function selectColor (namespace) {
      var hash = 0, i

      for (i in namespace) {
        hash = ((hash << 5) - hash) + namespace.charCodeAt(i)
        hash |= 0 // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length]
    }

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

    function createDebug (namespace) {
      function debug () {
    // disabled?
        if (!debug.enabled) return

        var self = debug

    // set `diff` timestamp
        var curr = +new Date()
        var ms = curr - (prevTime || curr)
        self.diff = ms
        self.prev = prevTime
        self.curr = curr
        prevTime = curr

    // turn the `arguments` into a proper Array
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }

        args[0] = exports.coerce(args[0])

        if (typeof args[0] !== 'string') {
      // anything else let's inspect with %O
          args.unshift('%O')
        }

    // apply any `formatters` transformations
        var index = 0
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match
          index++
          var formatter = exports.formatters[format]
          if (typeof formatter === 'function') {
            var val = args[index]
            match = formatter.call(self, val)

        // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1)
            index--
          }
          return match
        })

    // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args)

        var logFn = debug.log || exports.log || console.log.bind(console)
        logFn.apply(self, args)
      }

      debug.namespace = namespace
      debug.enabled = exports.enabled(namespace)
      debug.useColors = exports.useColors()
      debug.color = selectColor(namespace)

  // env-specific initialization logic for debug instances
      if (typeof exports.init === 'function') {
        exports.init(debug)
      }

      return debug
    }

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

    function enable (namespaces) {
      exports.save(namespaces)

      exports.names = []
      exports.skips = []

      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/)
      var len = split.length

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?')
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'))
        }
      }
    }

/**
 * Disable debug output.
 *
 * @api public
 */

    function disable () {
      exports.enable('')
    }

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

    function enabled (name) {
      var i, len
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true
        }
      }
      return false
    }

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

    function coerce (val) {
      if (val instanceof Error) return val.stack || val.message
      return val
    }
  /** */ },
/* 419 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(420)
  /** */ },
/* 420 */
  /** */ function (module, exports, __webpack_require__) {
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

    var type = __webpack_require__(421)

/*!
 * Buffer.isBuffer browser shim
 */

    var Buffer
    try { Buffer = __webpack_require__(185).Buffer } catch (ex) {
      Buffer = {}
      Buffer.isBuffer = function () { return false }
    }

/*!
 * Primary Export
 */

    module.exports = deepEqual

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

    function deepEqual (a, b, m) {
      if (sameValue(a, b)) {
        return true
      } else if (type(a) === 'date') {
        return dateEqual(a, b)
      } else if (type(a) === 'regexp') {
        return regexpEqual(a, b)
      } else if (Buffer.isBuffer(a)) {
        return bufferEqual(a, b)
      } else if (type(a) === 'arguments') {
        return argumentsEqual(a, b, m)
      } else if (!typeEqual(a, b)) {
        return false
      } else if ((type(a) !== 'object' && type(b) !== 'object') &&
  (type(a) !== 'array' && type(b) !== 'array')) {
        return sameValue(a, b)
      } else {
        return objectEqual(a, b, m)
      }
    }

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

    function sameValue (a, b) {
      if (a === b) return a !== 0 || 1 / a === 1 / b
      return a !== a && b !== b
    }

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

    function typeEqual (a, b) {
      return type(a) === type(b)
    }

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

    function dateEqual (a, b) {
      if (type(b) !== 'date') return false
      return sameValue(a.getTime(), b.getTime())
    }

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

    function regexpEqual (a, b) {
      if (type(b) !== 'regexp') return false
      return sameValue(a.toString(), b.toString())
    }

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

    function argumentsEqual (a, b, m) {
      if (type(b) !== 'arguments') return false
      a = [].slice.call(a)
      b = [].slice.call(b)
      return deepEqual(a, b, m)
    }

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

    function enumerable (a) {
      var res = []
      for (var key in a) res.push(key)
      return res
    }

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

    function iterableEqual (a, b) {
      if (a.length !== b.length) return false

      var i = 0
      var match = true

      for (; i < a.length; i++) {
        if (a[i] !== b[i]) {
          match = false
          break
        }
      }

      return match
    }

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

    function bufferEqual (a, b) {
      if (!Buffer.isBuffer(b)) return false
      return iterableEqual(a, b)
    }

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

    function isValue (a) {
      return a !== null && a !== undefined
    }

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

    function objectEqual (a, b, m) {
      if (!isValue(a) || !isValue(b)) {
        return false
      }

      if (a.prototype !== b.prototype) {
        return false
      }

      var i
      if (m) {
        for (i = 0; i < m.length; i++) {
          if ((m[i][0] === a && m[i][1] === b) ||
      (m[i][0] === b && m[i][1] === a)) {
            return true
          }
        }
      } else {
        m = []
      }

      try {
        var ka = enumerable(a)
        var kb = enumerable(b)
      } catch (ex) {
        return false
      }

      ka.sort()
      kb.sort()

      if (!iterableEqual(ka, kb)) {
        return false
      }

      m.push([a, b])

      var key
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i]
        if (!deepEqual(a[key], b[key], m)) {
          return false
        }
      }

      return true
    }
  /** */ },
/* 421 */
  /** */ function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(422)
  /** */ },
/* 422 */
  /** */ function (module, exports) {
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

    var exports = module.exports = getType

/*!
 * Detectable javascript natives
 */

    var natives = {
      '[object Array]': 'array',
      '[object RegExp]': 'regexp',
      '[object Function]': 'function',
      '[object Arguments]': 'arguments',
      '[object Date]': 'date'
    }

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

    function getType (obj) {
      var str = Object.prototype.toString.call(obj)
      if (natives[str]) return natives[str]
      if (obj === null) return 'null'
      if (obj === undefined) return 'undefined'
      if (obj === Object(obj)) return 'object'
      return typeof obj
    }

    exports.Library = Library

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

    function Library () {
      this.tests = {}
    }

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

    Library.prototype.of = getType

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

    Library.prototype.define = function (type, test) {
      if (arguments.length === 1) return this.tests[type]
      this.tests[type] = test
      return this
    }

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

    Library.prototype.test = function (obj, type) {
      if (type === getType(obj)) return true
      var test = this.tests[type]

      if (test && getType(test) === 'regexp') {
        return test.test(obj)
      } else if (test && getType(test) === 'function') {
        return test(obj)
      } else {
        throw new ReferenceError('Type test "' + type + '" not defined or invalid.')
      }
    }
  /** */ },
/* 423 */
  /** */ function (module, exports) {
    var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams']
    var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830]

    var alphaIndex = {}
    var numIndex = {}

    var i = 0
    var length = HTML_ALPHA.length
    while (i < length) {
      var a = HTML_ALPHA[i]
      var c = HTML_CODES[i]
      alphaIndex[a] = String.fromCharCode(c)
      numIndex[c] = a
      i++
    }

/**
 * @constructor
 */
    function Html4Entities () {}

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.prototype.decode = function (str) {
      if (!str || !str.length) {
        return ''
      }
      return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
        var chr
        if (entity.charAt(0) === '#') {
          var code = entity.charAt(1).toLowerCase() === 'x'
                ? parseInt(entity.substr(2), 16)
                : parseInt(entity.substr(1))

          if (!(isNaN(code) || code < -32768 || code > 65535)) {
            chr = String.fromCharCode(code)
          }
        } else {
          chr = alphaIndex[entity]
        }
        return chr || s
      })
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.decode = function (str) {
      return new Html4Entities().decode(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.prototype.encode = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)]
        result += alpha ? '&' + alpha + ';' : str.charAt(i)
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.encode = function (str) {
      return new Html4Entities().encode(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.prototype.encodeNonUTF = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var cc = str.charCodeAt(i)
        var alpha = numIndex[cc]
        if (alpha) {
          result += '&' + alpha + ';'
        } else if (cc < 32 || cc > 126) {
          result += '&#' + cc + ';'
        } else {
          result += str.charAt(i)
        }
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.encodeNonUTF = function (str) {
      return new Html4Entities().encodeNonUTF(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.prototype.encodeNonASCII = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var c = str.charCodeAt(i)
        if (c <= 255) {
          result += str[i++]
          continue
        }
        result += '&#' + c + ';'
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    Html4Entities.encodeNonASCII = function (str) {
      return new Html4Entities().encodeNonASCII(str)
    }

    module.exports = Html4Entities
  /** */ },
/* 424 */
  /** */ function (module, exports) {
    var ALPHA_INDEX = {
      '&lt': '<',
      '&gt': '>',
      '&quot': '"',
      '&apos': '\'',
      '&amp': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&apos;': '\'',
      '&amp;': '&'
    }

    var CHAR_INDEX = {
      60: 'lt',
      62: 'gt',
      34: 'quot',
      39: 'apos',
      38: 'amp'
    }

    var CHAR_S_INDEX = {
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&apos;',
      '&': '&amp;'
    }

/**
 * @constructor
 */
    function XmlEntities () {}

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.prototype.encode = function (str) {
      if (!str || !str.length) {
        return ''
      }
      return str.replace(/<|>|"|'|&/g, function (s) {
        return CHAR_S_INDEX[s]
      })
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.encode = function (str) {
      return new XmlEntities().encode(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.prototype.decode = function (str) {
      if (!str || !str.length) {
        return ''
      }
      return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
        if (s.charAt(1) === '#') {
          var code = s.charAt(2).toLowerCase() === 'x'
                ? parseInt(s.substr(3), 16)
                : parseInt(s.substr(2))

          if (isNaN(code) || code < -32768 || code > 65535) {
            return ''
          }
          return String.fromCharCode(code)
        }
        return ALPHA_INDEX[s] || s
      })
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.decode = function (str) {
      return new XmlEntities().decode(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.prototype.encodeNonUTF = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLength = str.length
      var result = ''
      var i = 0
      while (i < strLength) {
        var c = str.charCodeAt(i)
        var alpha = CHAR_INDEX[c]
        if (alpha) {
          result += '&' + alpha + ';'
          i++
          continue
        }
        if (c < 32 || c > 126) {
          result += '&#' + c + ';'
        } else {
          result += str.charAt(i)
        }
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.encodeNonUTF = function (str) {
      return new XmlEntities().encodeNonUTF(str)
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.prototype.encodeNonASCII = function (str) {
      if (!str || !str.length) {
        return ''
      }
      var strLenght = str.length
      var result = ''
      var i = 0
      while (i < strLenght) {
        var c = str.charCodeAt(i)
        if (c <= 255) {
          result += str[i++]
          continue
        }
        result += '&#' + c + ';'
        i++
      }
      return result
    }

/**
 * @param {String} str
 * @returns {String}
 */
    XmlEntities.encodeNonASCII = function (str) {
      return new XmlEntities().encodeNonASCII(str)
    }

    module.exports = XmlEntities
  /** */ },
/* 425 */
  /** */ function (module, exports) {
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]

      i += d

      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

      value = Math.abs(value)

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }

        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128
    }
  /** */ },
/* 426 */
  /** */ function (module, exports) {
/**
 * Helpers.
 */

    var s = 1000
    var m = s * 60
    var h = m * 60
    var d = h * 24
    var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

    module.exports = function (val, options) {
      options = options || {}
      var type = typeof val
      if (type === 'string' && val.length > 0) {
        return parse(val)
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val)
      }
      throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  )
    }

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

    function parse (str) {
      str = String(str)
      if (str.length > 100) {
        return
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  )
      if (!match) {
        return
      }
      var n = parseFloat(match[1])
      var type = (match[2] || 'ms').toLowerCase()
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y
        case 'days':
        case 'day':
        case 'd':
          return n * d
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n
        default:
          return undefined
      }
    }

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

    function fmtShort (ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd'
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h'
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm'
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's'
      }
      return ms + 'ms'
    }

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

    function fmtLong (ms) {
      return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
    }

/**
 * Pluralization helper.
 */

    function plural (ms, n, name) {
      if (ms < n) {
        return
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name
      }
      return Math.ceil(ms / n) + ' ' + name + 's'
    }
  /** */ },
/* 427 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (module, global) {
      var __WEBPACK_AMD_DEFINE_RESULT__/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {
	/** Detect free variables */
  var freeExports = typeof exports === 'object' && exports &&
		!exports.nodeType && exports
  var freeModule = typeof module === 'object' && module &&
		!module.nodeType && module
  var freeGlobal = typeof global === 'object' && global
  if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
    root = freeGlobal
  }

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
  var punycode,

	/** Highest positive signed 32-bit float value */
    maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
    base = 36,
    tMin = 1,
    tMax = 26,
    skew = 38,
    damp = 700,
    initialBias = 72,
    initialN = 128, // 0x80
    delimiter = '-', // '\x2D'

	/** Regular expressions */
    regexPunycode = /^xn--/,
    regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
    errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    },

	/** Convenience shortcuts */
    baseMinusTMin = base - tMin,
    floor = Math.floor,
    stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
    key

	/* --------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
  function error (type) {
    throw new RangeError(errors[type])
  }

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
  function map (array, fn) {
    var length = array.length
    var result = []
    while (length--) {
      result[length] = fn(array[length])
    }
    return result
  }

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
  function mapDomain (string, fn) {
    var parts = string.split('@')
    var result = ''
    if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@'
      string = parts[1]
    }
		// Avoid `split(regex)` for IE8 compatibility. See #17.
    string = string.replace(regexSeparators, '\x2E')
    var labels = string.split('.')
    var encoded = map(labels, fn).join('.')
    return result + encoded
  }

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
  function ucs2decode (string) {
    var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra
    while (counter < length) {
      value = string.charCodeAt(counter++)
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
        extra = string.charCodeAt(counter++)
        if ((extra & 0xFC00) == 0xDC00) { // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000)
        } else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
          output.push(value)
          counter--
        }
      } else {
        output.push(value)
      }
    }
    return output
  }

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
  function ucs2encode (array) {
    return map(array, function (value) {
      var output = ''
      if (value > 0xFFFF) {
        value -= 0x10000
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800)
        value = 0xDC00 | value & 0x3FF
      }
      output += stringFromCharCode(value)
      return output
    }).join('')
  }

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
  function basicToDigit (codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22
    }
    if (codePoint - 65 < 26) {
      return codePoint - 65
    }
    if (codePoint - 97 < 26) {
      return codePoint - 97
    }
    return base
  }

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
  function digitToBasic (digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
  }

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
  function adapt (delta, numPoints, firstTime) {
    var k = 0
    delta = firstTime ? floor(delta / damp) : delta >> 1
    delta += floor(delta / numPoints)
    for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin)
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew))
  }

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
  function decode (input) {
		// Don't use UCS-2
    var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

    basic = input.lastIndexOf(delimiter)
    if (basic < 0) {
      basic = 0
    }

    for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic')
      }
      output.push(input.charCodeAt(j))
    }

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
        if (index >= inputLength) {
          error('invalid-input')
        }

        digit = basicToDigit(input.charCodeAt(index++))

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow')
        }

        i += digit * w
        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias)

        if (digit < t) {
          break
        }

        baseMinusT = base - t
        if (w > floor(maxInt / baseMinusT)) {
          error('overflow')
        }

        w *= baseMinusT
      }

      out = output.length + 1
      bias = adapt(i - oldi, out, oldi == 0)

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
      if (floor(i / out) > maxInt - n) {
        error('overflow')
      }

      n += floor(i / out)
      i %= out

			// Insert `n` at position `i` of the output
      output.splice(i++, 0, n)
    }

    return ucs2encode(output)
  }

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
  function encode (input) {
    var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT

		// Convert the input in UCS-2 to Unicode
    input = ucs2decode(input)

		// Cache the length
    inputLength = input.length

		// Initialize the state
    n = initialN
    delta = 0
    bias = initialBias

		// Handle the basic code points
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j]
      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue))
      }
    }

    handledCPCount = basicLength = output.length

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
    if (basicLength) {
      output.push(delimiter)
    }

		// Main encoding loop:
    while (handledCPCount < inputLength) {
			// All non-basic code points < n have been handled already. Find the next
			// larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j]
        if (currentValue >= n && currentValue < m) {
          m = currentValue
        }
      }

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
      handledCPCountPlusOne = handledCPCount + 1
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow')
      }

      delta += (m - n) * handledCPCountPlusOne
      n = m

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j]

        if (currentValue < n && ++delta > maxInt) {
          error('overflow')
        }

        if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
          for (q = delta, k = base; /* no condition */; k += base) {
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias)
            if (q < t) {
              break
            }
            qMinusT = q - t
            baseMinusT = base - t
            output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						)
            q = floor(qMinusT / baseMinusT)
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)))
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength)
          delta = 0
          ++handledCPCount
        }
      }

      ++delta
      ++n
    }
    return output.join('')
  }

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
  function toUnicode (input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string
    })
  }

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
  function toASCII (input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string
    })
  }

	/* --------------------------------------------------------------------------*/

	/** Define the public API */
  punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
    'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  }

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
  if (
		true
	) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return punycode
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else if (freeExports && freeModule) {
    if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
      freeModule.exports = punycode
    } else {
			// in Narwhal or RingoJS v0.7.0-
      for (key in punycode) {
        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key])
      }
    }
  } else {
		// in Rhino or a web browser
    root.punycode = punycode
  }
}(this))
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(172)(module), __webpack_require__(6)))
  /** */ },
/* 428 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop)
    }

    module.exports = function (qs, sep, eq, options) {
      sep = sep || '&'
      eq = eq || '='
      var obj = {}

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj
      }

      var regexp = /\+/g
      qs = qs.split(sep)

      var maxKeys = 1000
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys
      }

      var len = qs.length
  // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr, vstr, k, v

        if (idx >= 0) {
          kstr = x.substr(0, idx)
          vstr = x.substr(idx + 1)
        } else {
          kstr = x
          vstr = ''
        }

        k = decodeURIComponent(kstr)
        v = decodeURIComponent(vstr)

        if (!hasOwnProperty(obj, k)) {
          obj[k] = v
        } else if (isArray(obj[k])) {
          obj[k].push(v)
        } else {
          obj[k] = [obj[k], v]
        }
      }

      return obj
    }

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]'
    }
  /** */ },
/* 429 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    var stringifyPrimitive = function (v) {
      switch (typeof v) {
        case 'string':
          return v

        case 'boolean':
          return v ? 'true' : 'false'

        case 'number':
          return isFinite(v) ? v : ''

        default:
          return ''
      }
    }

    module.exports = function (obj, sep, eq, name) {
      sep = sep || '&'
      eq = eq || '='
      if (obj === null) {
        obj = undefined
      }

      if (typeof obj === 'object') {
        return map(objectKeys(obj), function (k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq
          if (isArray(obj[k])) {
            return map(obj[k], function (v) {
              return ks + encodeURIComponent(stringifyPrimitive(v))
            }).join(sep)
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
          }
        }).join(sep)
      }

      if (!name) return ''
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj))
    }

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]'
    }

    function map (xs, f) {
      if (xs.map) return xs.map(f)
      var res = []
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i))
      }
      return res
    }

    var objectKeys = Object.keys || function (obj) {
      var res = []
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key)
      }
      return res
    }
  /** */ },
/* 430 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    exports.decode = exports.parse = __webpack_require__(428)
    exports.encode = exports.stringify = __webpack_require__(429)
  /** */ },
/* 431 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var has = Object.prototype.hasOwnProperty,
      undef

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
    function decode (input) {
      return decodeURIComponent(input.replace(/\+/g, ' '))
    }

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
    function querystring (query) {
      var parser = /([^=?&]+)=?([^&]*)/g,
        result = {},
        part

      while (part = parser.exec(query)) {
        var key = decode(part[1]),
          value = decode(part[2])

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
        if (key in result) continue
        result[key] = value
      }

      return result
    }

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
    function querystringify (obj, prefix) {
      prefix = prefix || ''

      var pairs = [],
        value,
        key

  //
  // Optionally prefix with a '?' if needed
  //
      if (typeof prefix !== 'string') prefix = '?'

      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key]

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = ''
          }

          pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value))
        }
      }

      return pairs.length ? prefix + pairs.join('&') : ''
    }

//
// Expose the module.
//
    exports.stringify = querystringify
    exports.parse = querystring
  /** */ },
/* 432 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
    module.exports = function required (port, protocol) {
      protocol = protocol.split(':')[0]
      port = +port

      if (!port) return false

      switch (protocol) {
        case 'http':
        case 'ws':
          return port !== 80

        case 'https':
        case 'wss':
          return port !== 443

        case 'ftp':
          return port !== 21

        case 'gopher':
          return port !== 70

        case 'file':
          return false
      }

      return port !== 0
    }
  /** */ },
/* 433 */
  /** */ function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (global, process) {
      (function (global, undefined) {
        'use strict'

        if (global.setImmediate) {
          return
        }

        var nextHandle = 1 // Spec says greater than zero
        var tasksByHandle = {}
        var currentlyRunningATask = false
        var doc = global.document
        var registerImmediate

        function setImmediate (callback) {
      // Callback can either be a function or a string
          if (typeof callback !== 'function') {
            callback = new Function('' + callback)
          }
      // Copy function arguments
          var args = new Array(arguments.length - 1)
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1]
          }
      // Store and register the task
          var task = { callback: callback, args: args }
          tasksByHandle[nextHandle] = task
          registerImmediate(nextHandle)
          return nextHandle++
        }

        function clearImmediate (handle) {
          delete tasksByHandle[handle]
        }

        function run (task) {
          var callback = task.callback
          var args = task.args
          switch (args.length) {
            case 0:
              callback()
              break
            case 1:
              callback(args[0])
              break
            case 2:
              callback(args[0], args[1])
              break
            case 3:
              callback(args[0], args[1], args[2])
              break
            default:
              callback.apply(undefined, args)
              break
          }
        }

        function runIfPresent (handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
          if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle)
          } else {
            var task = tasksByHandle[handle]
            if (task) {
              currentlyRunningATask = true
              try {
                run(task)
              } finally {
                clearImmediate(handle)
                currentlyRunningATask = false
              }
            }
          }
        }

        function installNextTickImplementation () {
          registerImmediate = function (handle) {
            process.nextTick(function () { runIfPresent(handle) })
          }
        }

        function canUsePostMessage () {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
          if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true
            var oldOnMessage = global.onmessage
            global.onmessage = function () {
              postMessageIsAsynchronous = false
            }
            global.postMessage('', '*')
            global.onmessage = oldOnMessage
            return postMessageIsAsynchronous
          }
        }

        function installPostMessageImplementation () {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

          var messagePrefix = 'setImmediate$' + Math.random() + '$'
          var onGlobalMessage = function (event) {
            if (event.source === global &&
                typeof event.data === 'string' &&
                event.data.indexOf(messagePrefix) === 0) {
              runIfPresent(+event.data.slice(messagePrefix.length))
            }
          }

          if (global.addEventListener) {
            global.addEventListener('message', onGlobalMessage, false)
          } else {
            global.attachEvent('onmessage', onGlobalMessage)
          }

          registerImmediate = function (handle) {
            global.postMessage(messagePrefix + handle, '*')
          }
        }

        function installMessageChannelImplementation () {
          var channel = new MessageChannel()
          channel.port1.onmessage = function (event) {
            var handle = event.data
            runIfPresent(handle)
          }

          registerImmediate = function (handle) {
            channel.port2.postMessage(handle)
          }
        }

        function installReadyStateChangeImplementation () {
          var html = doc.documentElement
          registerImmediate = function (handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement('script')
            script.onreadystatechange = function () {
              runIfPresent(handle)
              script.onreadystatechange = null
              html.removeChild(script)
              script = null
            }
            html.appendChild(script)
          }
        }

        function installSetTimeoutImplementation () {
          registerImmediate = function (handle) {
            setTimeout(runIfPresent, 0, handle)
          }
        }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global)
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global

    // Don't get fooled by e.g. browserify environments.
        if ({}.toString.call(global.process) === '[object process]') {
        // For Node.js before 0.9
          installNextTickImplementation()
        } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
          installPostMessageImplementation()
        } else if (global.MessageChannel) {
        // For web workers, where supported
          installMessageChannelImplementation()
        } else if (doc && 'onreadystatechange' in doc.createElement('script')) {
        // For IE 68
          installReadyStateChangeImplementation()
        } else {
        // For older browsers
          installSetTimeoutImplementation()
        }

        attachTo.setImmediate = setImmediate
        attachTo.clearImmediate = clearImmediate
      }(typeof self === 'undefined' ? typeof global === 'undefined' ? this : global : self))
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(6), __webpack_require__(7)))
  /** */ },
/* 434 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      Event = __webpack_require__(107)

    function CloseEvent () {
      Event.call(this)
      this.initEvent('close', false, false)
      this.wasClean = false
      this.code = 0
      this.reason = ''
    }

    inherits(CloseEvent, Event)

    module.exports = CloseEvent
  /** */ },
/* 435 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var inherits = __webpack_require__(3),
      Event = __webpack_require__(107)

    function TransportMessageEvent (data) {
      Event.call(this)
      this.initEvent('message', false, false)
      this.data = data
    }

    inherits(TransportMessageEvent, Event)

    module.exports = TransportMessageEvent
  /** */ },
/* 436 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'

    var JSON3 = __webpack_require__(33),
      iframeUtils = __webpack_require__(63)

    function FacadeJS (transport) {
      this._transport = transport
      transport.on('message', this._transportMessage.bind(this))
      transport.on('close', this._transportClose.bind(this))
    }

    FacadeJS.prototype._transportClose = function (code, reason) {
      iframeUtils.postMessage('c', JSON3.stringify([code, reason]))
    }
    FacadeJS.prototype._transportMessage = function (frame) {
      iframeUtils.postMessage('t', frame)
    }
    FacadeJS.prototype._send = function (data) {
      this._transport.send(data)
    }
    FacadeJS.prototype._close = function () {
      this._transport.close()
      this._transport.removeAllListeners()
    }

    module.exports = FacadeJS
  /** */ },
/* 437 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var urlUtils = __webpack_require__(24),
        eventUtils = __webpack_require__(41),
        JSON3 = __webpack_require__(33),
        FacadeJS = __webpack_require__(436),
        InfoIframeReceiver = __webpack_require__(159),
        iframeUtils = __webpack_require__(63),
        loc = __webpack_require__(160)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:iframe-bootstrap')
      }

      module.exports = function (SockJS, availableTransports) {
        var transportMap = {}
        availableTransports.forEach(function (at) {
          if (at.facadeTransport) {
            transportMap[at.facadeTransport.transportName] = at.facadeTransport
          }
        })

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
        transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver
        var parentOrigin

  /* eslint-disable camelcase */
        SockJS.bootstrap_iframe = function () {
    /* eslint-enable camelcase */
          var facade
          iframeUtils.currentWindowId = loc.hash.slice(1)
          var onMessage = function (e) {
            if (e.source !== parent) {
              return
            }
            if (typeof parentOrigin === 'undefined') {
              parentOrigin = e.origin
            }
            if (e.origin !== parentOrigin) {
              return
            }

            var iframeMessage
            try {
              iframeMessage = JSON3.parse(e.data)
            } catch (ignored) {
              debug('bad json', e.data)
              return
            }

            if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
              return
            }
            switch (iframeMessage.type) {
              case 's':
                var p
                try {
                  p = JSON3.parse(iframeMessage.data)
                } catch (ignored) {
                  debug('bad json', iframeMessage.data)
                  break
                }
                var version = p[0]
                var transport = p[1]
                var transUrl = p[2]
                var baseUrl = p[3]
                debug(version, transport, transUrl, baseUrl)
        // change this to semver logic
                if (version !== SockJS.version) {
                  throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".')
                }

                if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
                  throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')')
                }
                facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl))
                break
              case 'm':
                facade._send(iframeMessage.data)
                break
              case 'c':
                if (facade) {
                  facade._close()
                }
                facade = null
                break
            }
          }

          eventUtils.attachEvent('message', onMessage)

    // Start
          iframeUtils.postMessage('s')
        }
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 438 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process, global) {
      var EventEmitter = __webpack_require__(17).EventEmitter,
        inherits = __webpack_require__(3),
        JSON3 = __webpack_require__(33),
        utils = __webpack_require__(41),
        IframeTransport = __webpack_require__(165),
        InfoReceiverIframe = __webpack_require__(159)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:info-iframe')
      }

      function InfoIframe (baseUrl, url) {
        var self = this
        EventEmitter.call(this)

        var go = function () {
          var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl)

          ifr.once('message', function (msg) {
            if (msg) {
              var d
              try {
                d = JSON3.parse(msg)
              } catch (e) {
                debug('bad json', msg)
                self.emit('finish')
                self.close()
                return
              }

              var info = d[0], rtt = d[1]
              self.emit('finish', info, rtt)
            }
            self.close()
          })

          ifr.once('close', function () {
            self.emit('finish')
            self.close()
          })
        }

  // TODO this seems the same as the 'needBody' from transports
        if (!global.document.body) {
          utils.attachEvent('load', go)
        } else {
          go()
        }
      }

      inherits(InfoIframe, EventEmitter)

      InfoIframe.enabled = function () {
        return IframeTransport.enabled()
      }

      InfoIframe.prototype.close = function () {
        if (this.ifr) {
          this.ifr.close()
        }
        this.removeAllListeners()
        this.ifr = null
      }

      module.exports = InfoIframe
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7), __webpack_require__(6)))
  /** */ },
/* 439 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process) {
      var EventEmitter = __webpack_require__(17).EventEmitter,
        inherits = __webpack_require__(3),
        urlUtils = __webpack_require__(24),
        XDR = __webpack_require__(109),
        XHRCors = __webpack_require__(77),
        XHRLocal = __webpack_require__(61),
        XHRFake = __webpack_require__(451),
        InfoIframe = __webpack_require__(438),
        InfoAjax = __webpack_require__(158)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:info-receiver')
      }

      function InfoReceiver (baseUrl, urlInfo) {
        debug(baseUrl)
        var self = this
        EventEmitter.call(this)

        setTimeout(function () {
          self.doXhr(baseUrl, urlInfo)
        }, 0)
      }

      inherits(InfoReceiver, EventEmitter)

// TODO this is currently ignoring the list of available transports and the whitelist

      InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
        if (urlInfo.sameOrigin) {
          return new InfoAjax(url, XHRLocal)
        }
        if (XHRCors.enabled) {
          return new InfoAjax(url, XHRCors)
        }
        if (XDR.enabled && urlInfo.sameScheme) {
          return new InfoAjax(url, XDR)
        }
        if (InfoIframe.enabled()) {
          return new InfoIframe(baseUrl, url)
        }
        return new InfoAjax(url, XHRFake)
      }

      InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {
        var self = this,
          url = urlUtils.addPath(baseUrl, '/info')

        debug('doXhr', url)

        this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo)

        this.timeoutRef = setTimeout(function () {
          debug('timeout')
          self._cleanup(false)
          self.emit('finish')
        }, InfoReceiver.timeout)

        this.xo.once('finish', function (info, rtt) {
          debug('finish', info, rtt)
          self._cleanup(true)
          self.emit('finish', info, rtt)
        })
      }

      InfoReceiver.prototype._cleanup = function (wasClean) {
        debug('_cleanup')
        clearTimeout(this.timeoutRef)
        this.timeoutRef = null
        if (!wasClean && this.xo) {
          this.xo.close()
        }
        this.xo = null
      }

      InfoReceiver.prototype.close = function () {
        debug('close')
        this.removeAllListeners()
        this._cleanup(false)
      }

      InfoReceiver.timeout = 8000

      module.exports = InfoReceiver
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7)))
  /** */ },
/* 440 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict';
    /* WEBPACK VAR INJECTION */(function (process, global) {
      __webpack_require__(441)

      var URL = __webpack_require__(171),
        inherits = __webpack_require__(3),
        JSON3 = __webpack_require__(33),
        random = __webpack_require__(55),
        escape = __webpack_require__(456),
        urlUtils = __webpack_require__(24),
        eventUtils = __webpack_require__(41),
        transport = __webpack_require__(458),
        objectUtils = __webpack_require__(110),
        browser = __webpack_require__(62),
        log = __webpack_require__(457),
        Event = __webpack_require__(107),
        EventTarget = __webpack_require__(157),
        loc = __webpack_require__(160),
        CloseEvent = __webpack_require__(434),
        TransportMessageEvent = __webpack_require__(435),
        InfoReceiver = __webpack_require__(439)

      var debug = function () {}
      if (process.env.NODE_ENV !== 'production') {
        debug = __webpack_require__(10)('sockjs-client:main')
      }

      var transports

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
      function SockJS (url, protocols, options) {
        if (!(this instanceof SockJS)) {
          return new SockJS(url, protocols, options)
        }
        if (arguments.length < 1) {
          throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present")
        }
        EventTarget.call(this)

        this.readyState = SockJS.CONNECTING
        this.extensions = ''
        this.protocol = ''

  // non-standard extension
        options = options || {}
        if (options.protocols_whitelist) {
          log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.")
        }
        this._transportsWhitelist = options.transports
        this._transportOptions = options.transportOptions || {}

        var sessionId = options.sessionId || 8
        if (typeof sessionId === 'function') {
          this._generateSessionId = sessionId
        } else if (typeof sessionId === 'number') {
          this._generateSessionId = function () {
            return random.string(sessionId)
          }
        } else {
          throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.')
        }

        this._server = options.server || random.numberString(1000)

  // Step 1 of WS spec - parse and validate the url. Issue #8
        var parsedUrl = new URL(url)
        if (!parsedUrl.host || !parsedUrl.protocol) {
          throw new SyntaxError("The URL '" + url + "' is invalid")
        } else if (parsedUrl.hash) {
          throw new SyntaxError('The URL must not contain a fragment')
        } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
          throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.")
        }

        var secure = parsedUrl.protocol === 'https:'
  // Step 2 - don't allow secure origin with an insecure protocol
        if (loc.protocol === 'https:' && !secure) {
          throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS')
        }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
        if (!protocols) {
          protocols = []
        } else if (!Array.isArray(protocols)) {
          protocols = [protocols]
        }

  // Step 5 - check protocols argument
        var sortedProtocols = protocols.sort()
        sortedProtocols.forEach(function (proto, i) {
          if (!proto) {
            throw new SyntaxError("The protocols entry '" + proto + "' is invalid.")
          }
          if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
            throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.")
          }
        })

  // Step 6 - convert origin
        var o = urlUtils.getOrigin(loc.href)
        this._origin = o ? o.toLowerCase() : null

  // remove the trailing slash
        parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''))

  // store the sanitized url
        this.url = parsedUrl.href
        debug('using url', this.url)

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
        this._urlInfo = {
          nullOrigin: !browser.hasDomain(),
          sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),
          sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
        }

        this._ir = new InfoReceiver(this.url, this._urlInfo)
        this._ir.once('finish', this._receiveInfo.bind(this))
      }

      inherits(SockJS, EventTarget)

      function userSetCode (code) {
        return code === 1000 || (code >= 3000 && code <= 4999)
      }

      SockJS.prototype.close = function (code, reason) {
  // Step 1
        if (code && !userSetCode(code)) {
          throw new Error('InvalidAccessError: Invalid code')
        }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
        if (reason && reason.length > 123) {
          throw new SyntaxError('reason argument has an invalid length')
        }

  // Step 3.1
        if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
          return
        }

  // TODO look at docs to determine how to set this
        var wasClean = true
        this._close(code || 1000, reason || 'Normal closure', wasClean)
      }

      SockJS.prototype.send = function (data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
        if (typeof data !== 'string') {
          data = '' + data
        }
        if (this.readyState === SockJS.CONNECTING) {
          throw new Error('InvalidStateError: The connection has not been established yet')
        }
        if (this.readyState !== SockJS.OPEN) {
          return
        }
        this._transport.send(escape.quote(data))
      }

      SockJS.version = __webpack_require__(169)

      SockJS.CONNECTING = 0
      SockJS.OPEN = 1
      SockJS.CLOSING = 2
      SockJS.CLOSED = 3

      SockJS.prototype._receiveInfo = function (info, rtt) {
        debug('_receiveInfo', rtt)
        this._ir = null
        if (!info) {
          this._close(1002, 'Cannot connect to server')
          return
        }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
        this._rto = this.countRTO(rtt)
  // allow server to override url used for the actual transport
        this._transUrl = info.base_url ? info.base_url : this.url
        info = objectUtils.extend(info, this._urlInfo)
        debug('info', info)
  // determine list of desired and supported transports
        var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info)
        this._transports = enabledTransports.main
        debug(this._transports.length + ' enabled transports')

        this._connect()
      }

      SockJS.prototype._connect = function () {
        for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
          debug('attempt', Transport.transportName)
          if (Transport.needBody) {
            if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
              debug('waiting for body')
              this._transports.unshift(Transport)
              eventUtils.attachEvent('load', this._connect.bind(this))
              return
            }
          }

    // calculate timeout based on RTO and round trips. Default to 5s
          var timeoutMs = (this._rto * Transport.roundTrips) || 5000
          this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs)
          debug('using timeout', timeoutMs)

          var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId())
          var options = this._transportOptions[Transport.transportName]
          debug('transport url', transportUrl)
          var transportObj = new Transport(transportUrl, this._transUrl, options)
          transportObj.on('message', this._transportMessage.bind(this))
          transportObj.once('close', this._transportClose.bind(this))
          transportObj.transportName = Transport.transportName
          this._transport = transportObj

          return
        }
        this._close(2000, 'All transports failed', false)
      }

      SockJS.prototype._transportTimeout = function () {
        debug('_transportTimeout')
        if (this.readyState === SockJS.CONNECTING) {
          if (this._transport) {
            this._transport.close()
          }

          this._transportClose(2007, 'Transport timed out')
        }
      }

      SockJS.prototype._transportMessage = function (msg) {
        debug('_transportMessage', msg)
        var self = this,
          type = msg.slice(0, 1),
          content = msg.slice(1),
          payload

  // first check for messages that don't need a payload
        switch (type) {
          case 'o':
            this._open()
            return
          case 'h':
            this.dispatchEvent(new Event('heartbeat'))
            debug('heartbeat', this.transport)
            return
        }

        if (content) {
          try {
            payload = JSON3.parse(content)
          } catch (e) {
            debug('bad json', content)
          }
        }

        if (typeof payload === 'undefined') {
          debug('empty payload', content)
          return
        }

        switch (type) {
          case 'a':
            if (Array.isArray(payload)) {
              payload.forEach(function (p) {
                debug('message', self.transport, p)
                self.dispatchEvent(new TransportMessageEvent(p))
              })
            }
            break
          case 'm':
            debug('message', this.transport, payload)
            this.dispatchEvent(new TransportMessageEvent(payload))
            break
          case 'c':
            if (Array.isArray(payload) && payload.length === 2) {
              this._close(payload[0], payload[1], true)
            }
            break
        }
      }

      SockJS.prototype._transportClose = function (code, reason) {
        debug('_transportClose', this.transport, code, reason)
        if (this._transport) {
          this._transport.removeAllListeners()
          this._transport = null
          this.transport = null
        }

        if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
          this._connect()
          return
        }

        this._close(code, reason)
      }

      SockJS.prototype._open = function () {
        debug('_open', this._transport.transportName, this.readyState)
        if (this.readyState === SockJS.CONNECTING) {
          if (this._transportTimeoutId) {
            clearTimeout(this._transportTimeoutId)
            this._transportTimeoutId = null
          }
          this.readyState = SockJS.OPEN
          this.transport = this._transport.transportName
          this.dispatchEvent(new Event('open'))
          debug('connected', this.transport)
        } else {
    // The server might have been restarted, and lost track of our
    // connection.
          this._close(1006, 'Server lost session')
        }
      }

      SockJS.prototype._close = function (code, reason, wasClean) {
        debug('_close', this.transport, code, reason, wasClean, this.readyState)
        var forceFail = false

        if (this._ir) {
          forceFail = true
          this._ir.close()
          this._ir = null
        }
        if (this._transport) {
          this._transport.close()
          this._transport = null
          this.transport = null
        }

        if (this.readyState === SockJS.CLOSED) {
          throw new Error('InvalidStateError: SockJS has already been closed')
        }

        this.readyState = SockJS.CLOSING
        setTimeout(function () {
          this.readyState = SockJS.CLOSED

          if (forceFail) {
            this.dispatchEvent(new Event('error'))
          }

          var e = new CloseEvent('close')
          e.wasClean = wasClean || false
          e.code = code || 1000
          e.reason = reason

          this.dispatchEvent(e)
          this.onmessage = this.onclose = this.onerror = null
          debug('disconnected')
        }.bind(this), 0)
      }

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
      SockJS.prototype.countRTO = function (rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
        if (rtt > 100) {
          return 4 * rtt // rto > 400msec
        }
        return 300 + rtt // 300msec < rto <= 400msec
      }

      module.exports = function (availableTransports) {
        transports = transport(availableTransports)
        __webpack_require__(437)(SockJS, availableTransports)
        return SockJS
      }
    /* WEBPACK VAR INJECTION */ }.call(exports, __webpack_require__(7), __webpack_require__(6)))
  /** */ },
/* 441 */
  /** */ function (module, exports, __webpack_require__) {
    'use strict'
/* eslint-disable */
/* jscs: disable */


// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);


/***/ },
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [
  // streaming transports
  __webpack_require__(452)
, __webpack_require__(454)
, __webpack_require__(167)
, __webpack_require__(163)
, __webpack_require__(108)(__webpack_require__(163))

  // polling transports
, __webpack_require__(164)
, __webpack_require__(108)(__webpack_require__(164))
, __webpack_require__(168)
, __webpack_require__(453)
, __webpack_require__(108)(__webpack_require__(168))
, __webpack_require__(444)
];


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = __webpack_require__(3)
  , SenderReceiver = __webpack_require__(166)
  , JsonpReceiver = __webpack_require__(449)
  , jsonpSender = __webpack_require__(450)
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var inherits = __webpack_require__(3)
  , EventEmitter = __webpack_require__(17).EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var inherits = __webpack_require__(3)
  , EventEmitter = __webpack_require__(17).EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var inherits = __webpack_require__(3)
  , EventEmitter = __webpack_require__(17).EventEmitter
  , EventSourceDriver = __webpack_require__(162)
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

var inherits = __webpack_require__(3)
  , iframeUtils = __webpack_require__(63)
  , urlUtils = __webpack_require__(24)
  , EventEmitter = __webpack_require__(17).EventEmitter
  , random = __webpack_require__(55)
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(6)))

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

var utils = __webpack_require__(63)
  , random = __webpack_require__(55)
  , browser = __webpack_require__(62)
  , urlUtils = __webpack_require__(24)
  , inherits = __webpack_require__(3)
  , EventEmitter = __webpack_require__(17).EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(6)))

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {

var random = __webpack_require__(55)
  , urlUtils = __webpack_require__(24)
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(6)))

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(17).EventEmitter
  , inherits = __webpack_require__(3)
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;


/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(41)
  , urlUtils = __webpack_require__(24)
  , inherits = __webpack_require__(3)
  , EventEmitter = __webpack_require__(17).EventEmitter
  , WebsocketDriver = __webpack_require__(443)
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(3)
  , AjaxBasedTransport = __webpack_require__(54)
  , XdrStreamingTransport = __webpack_require__(167)
  , XhrReceiver = __webpack_require__(76)
  , XDRObject = __webpack_require__(109)
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var inherits = __webpack_require__(3)
  , AjaxBasedTransport = __webpack_require__(54)
  , XhrReceiver = __webpack_require__(76)
  , XHRCorsObject = __webpack_require__(77)
  , XHRLocalObject = __webpack_require__(61)
  , browser = __webpack_require__(62)
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var JSON3 = __webpack_require__(33);

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = __webpack_require__(10)('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 459 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 460 */
/***/ (function(module, exports) {

/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let "new String('')" return 'object'
  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
  // PhantomJS has type "DOMWindow" for null
  if (obj === null) return 'null';
  // PhantomJS has type "DOMWindow" for undefined
  if (obj === undefined) return 'undefined';
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 462 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 463 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__;

/***/ })
/******/ ]);
//# sourceMappingURL=vuePluginTemplateDeps.dll.js.map